
# This is a shell archive.  Remove anything before this line,
# then unpack it by saving it in a file and typing "sh file".
#
# Wrapped by Doug Young <dayoung@hplday> on Thu Mar 15 13:58:19 1990
#
# This archive contains:
#	AppDefaults	ERRATA		FILELIST	Makefile	
#	README		ch10		ch11		ch12		
#	ch13		ch14		ch2		ch3		
#	ch4		ch5		ch6		ch7		
#	ch9		lib		more		
#

LANG=""; export LANG
PATH=/bin:/usr/bin:$PATH; export PATH

echo mkdir - AppDefaults
mkdir AppDefaults


rm -f /tmp/uud$$
(echo "begin 777 /tmp/uud$$\n \nend" | uudecode) >/dev/null 2>&1
if [ -f /tmp/uud$$ ]
then
	rm -f /tmp/uud$$
	unpacker=uudecode
else
	echo Compiling unpacker for non-ascii files
	pwd=`pwd`; cd /tmp
	cat >unpack$$.c <<-'EOF'
	#include <stdio.h>
	#define DEC(c)	(((c) - ' ') & 077)
	main()
	{
		int n;
		char dest[128], a,b,c,d;

		scanf("begin %o ", &n);
		gets(dest);

		if (freopen(dest, "w", stdout) == NULL) {
			perror(dest);
			exit(1);
		}

		while ((n=getchar()) != EOF && (n=DEC(n))!=0)  {
			while (n>0) {
				a = DEC(getchar());
				b = DEC(getchar());
				c = DEC(getchar());
				d = DEC(getchar());
				if (n-- > 0) putchar(a << 2 | b >> 4);
				if (n-- > 0) putchar(b << 4 | c >> 2);
				if (n-- > 0) putchar(c << 6 | d);
			}
			n=getchar();
		}
		exit(0);
	}
	EOF
	cc -o unpack$$ unpack$$.c
	rm unpack$$.c
	cd $pwd
	unpacker=/tmp/unpack$$
fi

echo x - AppDefaults/Chooseone '[non-ascii]'
$unpacker <<'@eof'
begin 664 AppDefaults/Chooseone
M(2$A(2$A(2$A(2$A(2$A(2$A(2$A(2$A(2$A(2$A(2$A(2$A(2$A(2$A(2$A
M(2$A(2$A(2$A(2$A(2$A(2$A(2$A(2$A(2$*(2!#:&]O<V5O;F4Z($-L87-S
M(')E<V]U<F-E(&9I;&4@9F]R('1H92!C:&]O<V]N92!L:7-T('=I9&=E="!E
M>&%M<&QE"B$A(2$A(2$A(2$A(2$A(2$A(2$A(2$A(2$A(2$A(2$A(2$A(2$A
M(2$A(2$A(2$A(2$A(2$A(2$A(2$A(2$A(2$A(2$A(2$A"B$*"BIG96]M971R
+>3H@/3$P,'@S,# A
 
end
@eof

chmod 664 AppDefaults/Chooseone

echo x - AppDefaults/Coloredit
cat >AppDefaults/Coloredit <<'@EOF'
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
! Coloredit: Resources for the coloredit program
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!
*base.geometry:             =400x400
!
*colorpanel*numColumns: 16
*colorpanel*adjustLast: False
*colorpanel*packing: pack_column
!
! Set the location of the digital display
!
*display*x:                 180
*display*y:                  60
*display*height:             30
*display*width:             140
!
! Position the color controls
!
*sliderpanel.x:              10
*sliderpanel.y:              60
*sliderpanel*numColumns:      1
*sliderpanel*packing:        pack_column
*sliderpanel.orientation:    vertical
!
! Specify the valuator orientation and size
!
*XmScale*orientation: horizontal
*XmScale*processingDirection: max_on_bottom
!
! Place the quit button.
*quit*x:                    180
*quit*y:                    100
@EOF

chmod 664 AppDefaults/Coloredit

echo x - AppDefaults/Controldata
cat >AppDefaults/Controldata <<'@EOF'
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
! Controldata: Resource File for controldata program
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
Controldata*orientation:                     horizontal
Controldata*panel*RowColumn.orientation:     vertical
Controldata*XmScrollbar*orientation:         horizontal
Controldata*speed*label*labelString:         Speed
Controldata*direction*label*labelString:     Direction
Controldata*altitude*label*labelString:      Altitude
Controldata*speed.orientation:	             vertical
Controldata*direction.orientation:	     vertical
Controldata*altitude.orientation:	     vertical
@EOF

chmod 664 AppDefaults/Controldata

echo x - AppDefaults/Dialog '[non-ascii]'
$unpacker <<'@eof'
begin 664 AppDefaults/Dialog
M1&EA;&]G*F)U='1O;BYL86)E;%-T<FEN9SH@(" @4'5S:"!-90H*1&EA;&]G
M*F)U='1O;C$J;&%B96Q3=')I;F<Z(" @3F%M93H*1&EA;&]G*F)U='1O;C(J
M;&%B96Q3=')I;F<Z(" @4&AO;F4Z"D1I86QO9RIB=71T;VXS*FQA8F5L4W1R
M:6YG.B @($%D9')E<W,Z"B$*(2!3<&5C:69Y('!O<VET:6]N<R!F;W(@96%C
M:"!W:61G970N"B$*1&EA;&]G*EAM5&5X="IX.B @(" @(" @,3(P"D1I86QO
M9RIF:65L9#$J>3H@(" @(" @(" Q, I$:6%L;V<J9FEE;&0R*GDZ(" @(" @
M(" @-# *1&EA;&]G*F9I96QD,RIY.B @(" @(" @(#<P"D1I86QO9RI8;5!U
M<VA"=71T;VXN>#H@(" Q, I$:6%L;V<J8G5T=&]N,2IY.B @(" @(" @,3 *
M1&EA;&]G*F)U='1O;C(J>3H@(" @(" @(#0P"D1I86QO9RIB=71T;VXS*GDZ
M(" @(" @(" W, I$:6%L;V<J:&5L<"IX.B @(" @(" @(" @,3 *1&EA;&]G
M*FAE;' J>3H@(" @(" @(" @,C P"D1I86QO9RID;VYE*G@Z(" @(" @(" @
@(" Q, I$:6%L;V<J9&]N92IY.B @(" @(" @(" Q,#!E
 
end
@eof

chmod 664 AppDefaults/Dialog

echo x - AppDefaults/Formedit
cat >AppDefaults/Formedit <<'@EOF'
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
! Formedit: Class resource file for the formedit example
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!
! Specify labels for each button.
!
Formedit*button1*labelString:   Name:
Formedit*button2*labelString:   Phone:
Formedit*button3*labelString:   Address:
!
! Specify positions for each widget.
!
Formedit*XmText*x:        100
Formedit*field1*y:         10
Formedit*field2*y:         40
Formedit*field3*y:         70
Formedit*XmPushButton*x:   10
Formedit*button1*y:        10
Formedit*button2*y:        40
Formedit*button3*y:        70
@EOF

chmod 664 AppDefaults/Formedit

echo x - AppDefaults/Formtest '[non-ascii]'
$unpacker <<'@eof'
begin 664 AppDefaults/Formtest
M(2$A(2$A(2$A(2$A(2$A(2$A(2$A(2$A(2$A(2$A(2$A(2$A(2$A(2$A(2$A
M"B$@1F]R;71E<W0Z(&-L87-S(')E<V]U<F-E(&9I;&4@9F]R(&9O<FUE9&ET
M"B$A(2$A(2$A(2$A(2$A(2$A(2$A(2$A(2$A(2$A(2$A(2$A(2$A(2$A(2$A
M(0HA"B$@36%K92!A;&P@8VAI;&1R96X@<F5S:7IA8FQE(&%N9"!S<&5C:69Y
M"B$@86QL(&%T=&%C:&UE;G1S(&%S(&%T=&%C:%]P;W-I=&EO;@HA"D9O<FUT
M97-T*G)E<VEZ86)L93H@(" @(" @(" @(" @("!44E5%"D9O<FUT97-T*G1O
M<$%T=&%C:&UE;G0Z(" @(" @(" @("!A='1A8VA?<&]S:71I;VX*1F]R;71E
M<W0J8F]T=&]M071T86-H;65N=#H@(" @(" @(&%T=&%C:%]P;W-I=&EO;@I&
M;W)M=&5S="IL969T071T86-H;65N=#H@(" @(" @(" @871T86-H7W!O<VET
M:6]N"D9O<FUT97-T*G)I9VAT071T86-H;65N=#H@(" @(" @("!A='1A8VA?
M<&]S:71I;VX*(0HA(%-E="!U<"!T:&4@8G5T=&]N<R!T;R!S=')E=&-H(&%C
M<F]S<R!T:&4@96YT:7)E(&9O<FT*(2!A;F0@96%C:"!O8V-U<'D@,S @)2!O
M9B!T:&4@:&5I9VAT+@HA"D9O<FUT97-T*F)U='1O;C$N;&5F=%!O<VET:6]N
M.B @(" @,0I&;W)M=&5S="IB=71T;VXQ+G)I9VAT4&]S:71I;VXZ(" @.3D*
M1F]R;71E<W0J8G5T=&]N,2YT;W!0;W-I=&EO;CH@(" @(" Q"D9O<FUT97-T
M*F)U='1O;C$N8F]T=&]M4&]S:71I;VXZ(" S,0H*1F]R;71E<W0J8G5T=&]N
M,BYL969T4&]S:71I;VXZ(" @(#$*1F]R;71E<W0J8G5T=&]N,BYR:6=H=%!O
M<VET:6]N.B @(#DY"D9O<FUT97-T*F)U='1O;C(N=&]P4&]S:71I;VXZ(" @
M(" S-0I&;W)M=&5S="IB=71T;VXR+F)O='1O;5!O<VET:6]N.B @-C4*"D9O
M<FUT97-T*F)U='1O;C,N;&5F=%!O<VET:6]N.B @(" @,0I&;W)M=&5S="IB
M=71T;VXS+G)I9VAT4&]S:71I;VXZ(" @.3D*1F]R;71E<W0J8G5T=&]N,RYT
M;W!0;W-I=&EO;CH@(" @(#8Y"D9O<FUT97-T*F)U='1O;C,N8F]T=&]M4&]S
*:71I;VXZ(" Y.3H@
 
end
@eof

chmod 664 AppDefaults/Formtest

echo x - AppDefaults/Generic
cat >AppDefaults/Generic <<'@EOF'
!
! Generic: Simply put up a window (a Core widget)
!

!
! The Core widget doesn't specify a geometry
!

*geometry:   =100x100

@EOF

chmod 664 AppDefaults/Generic

echo x - AppDefaults/Helptest
cat >AppDefaults/Helptest <<'@EOF'
*Helptest*button.labelString:    Push Me
*Helptest*help.labelString:      Help
*Helptest*done.labelString:      Done
Helptest*button1*labelString:   Name:
Helptest*button2*labelString:   Phone:
Helptest*button3*labelString:   Address:
#
# Specify positions for each widget.
#
*Helptest*XmText*x:      120
*Helptest*field1*y:         10
*Helptest*field2*y:         40
*Helptest*field3*y:         70
*Helptest*XmPushButton.x:     10
*Helptest*button1*y:        10
*Helptest*button2*y:        40
*Helptest*button3*y:        70
*Help*x: 10
*Help*y: 100
Helptest*help*x:           10
Helptest*help*y:          200
Helptest*done*x:           10D
Helptest*done*y:          100
@EOF

chmod 664 AppDefaults/Helptest

echo x - AppDefaults/Memo
cat >AppDefaults/Memo <<'@EOF'
!
! Memo:  No particular resources required
!
@EOF

chmod 664 AppDefaults/Memo

echo x - AppDefaults/Menu '[non-ascii]'
$unpacker <<'@eof'
begin 664 AppDefaults/Menu
@(0HA($UE;G4*(0H**F=E;VUE=')Y.B @/3$P,'@Q,##_
 
end
@eof

chmod 664 AppDefaults/Menu

echo x - AppDefaults/MenuTest '[non-ascii]'
$unpacker <<'@eof'
begin 664 AppDefaults/MenuTest
M(0HA($UE;G5497-T.B!296%L;'D@=&AE('=R;VYG(&YA;64@86-C;W)D:6YG
M('1O(&-L87-S(&YA;64@8V]N=F5N=&EO;G,*(0H**F=E;VUE=')Y.B @/3(P
%,'@Q,#!L
 
end
@eof

chmod 664 AppDefaults/MenuTest

echo x - AppDefaults/Notepad
cat >AppDefaults/Notepad <<'@EOF'
*Notepad*commands*orientation:        horizontal
*Notepad*base.numcolumns:             1
*Notepad*base*packing:                 pack_tight
*Notepad*base*commands*numcolumns:        4
*Notepad*commands*adjustLast:             False
*Notepad*packing:                         pack_tight
@EOF

chmod 664 AppDefaults/Notepad

echo x - AppDefaults/Rctest '[non-ascii]'
$unpacker <<'@eof'
begin 664 AppDefaults/Rctest
M(2$A(2$A(2$A(2$A(2$A(2$A(2$A(2$A(2$A(2$A(2$A(2$A(2$A(2$A(2$A
M(2$A(2$A"B$@4F-T97-T.B!#;&%S<R!297-O=7)C97,@9F]R(')C=&5S="YC
M"B$A(2$A(2$A(2$A(2$A(2$A(2$A(2$A(2$A(2$A(2$A(2$A(2$A(2$A(2$A
M(2$A(2$A(0HA"B$@4W!E8VEF>2!L86)E;',@9F]R(&%L;"!B=71T;VYS+@HA
M"BI28W1E<W0J8G5T=&]N,2YL86)E;%-T<FEN9SH@(" @0G5T=&]N($]N90HJ
M4F-T97-T*F)U='1O;C(N;&%B96Q3=')I;F<Z(" @($)U='1O;B!4=V\**E)C
M=&5S="IB=71T;VXS+FQA8F5L4W1R:6YG.B @("!"=71T;VX@5&AR964**E)C
M=&5S="IB=71T;VXT+FQA8F5L4W1R:6YG.B @("!"=71T;VX@1F]U<@HJ4F-T
M97-T*F)U='1O;C4N;&%B96Q3=')I;F<Z(" @($)U='1O;B!&:79E"BI28W1E
M<W0J8G5T=&]N-BYL86)E;%-T<FEN9SH@(" @0G5T=&]N(%-I>"!7:71H(&$@
M3&]N9R!,86)E; HA"B$@4F5Q=65S="!B=71T;VYS(&EN(#,@<F]W<RP@8GD@
M<V5T=&EN9R!O<FEE;G1A=&EO;B!T;PHA(&AO<FEZ;VYT86P@86YD(')E<75E
M<W1I;F<@,R!C;VQU;6YS("AM:6YO<BUD:6UE;G-I;VXI"B$**E)C=&5S="IO
M<FEE;G1A=&EO;CH@(" @(" @("!H;W)I>F]N=&%L"BI28W1E<W0J<F]W8V]L
M*FYU;4-O;'5M;G,Z(" @,PHJ4F-T97-T*G)O=V-O;"IP86-K:6YG.B @(" @
M('!A8VM?8V]L=6UN"@HA"B$J4F-T97-T*G)O=V-O;"IP86-K:6YG.B @(" @
,<&%C:U]T:6=H= HA
 
end
@eof

chmod 664 AppDefaults/Rctest

echo x - AppDefaults/Rmtest
cat >AppDefaults/Rmtest <<'@EOF'
!
! Rmtest:  No particular resources required
!
@EOF

chmod 664 AppDefaults/Rmtest

echo x - AppDefaults/Rowtest
cat >AppDefaults/Rowtest <<'@EOF'
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
! Rowtest: Class Resources for rowtest.c
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!
! Request buttons in 3 columns.
!
*Rowtest*orientation:         horizontal
*Rowtest*rowcol*numColumns:   3
*Rowtest*rowcol*packing:     pack_column
!
! Specify labels for all buttons.
!
*Rowtest*button1.labelString:    Button One
*Rowtest*button2.labelString:    Button Two
*Rowtest*button3.labelString:    Button Three
*Rowtest*button4.labelString:    Button Four
*Rowtest*button5.labelString:    Button Five
*Rowtest*button6.labelString:    Button Six With a Long Label

! step 2
*Rowtest*rowcol*packing:     pack_tight

!Step 3
!*Rowtest*rowcol*adjustLast:     True






@EOF

chmod 664 AppDefaults/Rowtest

echo x - AppDefaults/Stopwatch
cat >AppDefaults/Stopwatch <<'@EOF'
!
! Stopwatch
!
*panel*numColumns:          1
*panel*commands*numColumns: 3
*adjustLast:                False
*packing:                   pack_column

@EOF

chmod 664 AppDefaults/Stopwatch

echo x - AppDefaults/Traverse '[non-ascii]'
$unpacker <<'@eof'
begin 664 AppDefaults/Traverse
M(0HA(%1R879E<G-E.B @87!P+61E9F%U;'1S(&9O<B!K97EB;V%R9"!T<F%V
M97)S86P@97AA;7!L90HA"@HJ=')A=F5R<V%L3VXZ(%1R=64*"BIH:6=H;&EG
M:'1#;VQO<CH@4F5D"BIH:6=H;&EG:'14:&EC:VYE<W,Z(" R"BIH:6=H;&EG
M:'1/;D5N=&5R.B @5')U90H*(0HA(%-E="!T:&ES('1O(&AA=F4@=&AE(&9O
M8W5S(&9O;&QW('1H92!P;VEN=&5R"B$*(2IK97EB;V%R9$9O8W5S4&]L:6-Y
M.B!P;VEN=&5R"@HA"B$@4V5T('1H:7,@=&\@:&%V92!E>'!L:6-I="!F;V-U
C<R *(0HJ:V5Y8F]A<F1&;V-U<U!O;&EC>3H@97AP;&EC:71L
 
end
@eof

chmod 664 AppDefaults/Traverse

echo x - AppDefaults/Twoshells
cat >AppDefaults/Twoshells <<'@EOF'
!
! Twoshells: Simply put up two window ( Core widgets)
!

!
! The Core widget doesn't specify a geometry
!

*geometry:   =100x100

@EOF

chmod 664 AppDefaults/Twoshells

echo x - AppDefaults/XTalk
cat >AppDefaults/XTalk <<'@EOF'
xtalk*command*packing:     pack_tight
xtalk*command*orientation: horizontal
@EOF

chmod 664 AppDefaults/XTalk

echo x - AppDefaults/Xtalk
cat >AppDefaults/Xtalk <<'@EOF'
!
! Xtalk : Guess it should really be XTalk ?? silly conventions
!

*panel*command*orientation:   horizontal

@EOF

chmod 664 AppDefaults/Xtalk

echo x - AppDefaults/Draw
cat >AppDefaults/Draw <<'@EOF'
*Draw*framework.numColumns:  2
*Draw*command*adjustLast:    False
*Draw*framework.packing:     pack_column
@EOF

chmod 666 AppDefaults/Draw

echo x - AppDefaults/Monitordata
cat >AppDefaults/Monitordata <<'@EOF'
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
! Monitordata: Resource File for Monitordata
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
Monitordata*orientation:                     horizontal
Monitordata*panel*RowColumn.orientation:     vertical
Monitordata*XmScrollbar*orientation:         horizontal
Monitordata*speed*label*labelString:         Speed:
Monitordata*direction*label*labelString:     Direction:
Monitordata*altitude*label*labelString:      Altitude:

@EOF

chmod 666 AppDefaults/Monitordata

chmod 775 AppDefaults

echo x - ERRATA
cat >ERRATA <<'@EOF'
The following are various minor changes and problems that have been found
in the accompanying code or the first printing of the book. Code changes
have already been incorporated in the code and will be fixed in later
printings of the text.

Feb 2,1990

** Makefile

On some systems the library may need to be built with the "clq" or other
options to ar rather than the "ruv" options specified in the makefile

** Appendix B

Several widget resource listings specify NULL as the default for resources
such as XmNokLabelString, XmNhelpLabelString, etc. These get defaulted at
run time to "OK", "Help", etc.

** Pg 199.

#include <Xw/Xw.h> is unnecessary and should be removed or changed to Xm/Xm.h


** pg 240

strdup() isn't available on all systems. To be safe, replace

      else
        buf = strdup(text);

with

    else {
      buf = (char *) XtMalloc(strlen(text) +1);
      strcpy(buf, text);
    }


** Pg 318.

The event handler must be registered using ButtonPressMask instead of
ButtonPress.

** pg. 322.

The request_selection function should be registered as a callback, not an
event handler. The correct line is:

 XtAddCallback(request, XmNactivateCallback,
               request_selection, selection);

Also, on the next line, the event handler must be registered using
ButtonPressMask instead of ButtonPress.


** Chapter 12. 

The Dial example has some confused mis-use of GC's. The following changes
should be made:

** Pg 353-354

Replace all XCreateGC() calls in Initialize() with XtGetGC()

** Pg. 355 

Accordingly, change all calls to XFreeGC() in Destroy() to XtReleaseGC():

static void Destroy (w)
     XsDialWidget w;
{
  XtReleaseGC (w, w->dial.indicator_GC);
  XtReleaseGC (w, w->dial.dial_GC);
  XtReleaseGC (w, w->dial.inverse_GC);
  XtRemoveAllCallbacks (w, XtNselectCallback,
                         w->dial.select);
}


** Pg 357.

Add the following text before the last sentence, first paragraph

"However, in this example, the graphics contexts have been created using
XtGetGC(), which creates GCs that may be shared by others.  Therefore we
must not alter the GC in any way, or at least we must undo any changes
immediately. For this example we will take the easy way out and simply not
use the information in the region argument, redrawing the entire face of
the dial instead."

** Finally,

Eliminate the calls to XSetRegion() in the Redisplay() method.

** pg 376

The heading of section 13.2.2 should say "Public" not "Private"

** pg 382: 

The first field of the XtWidgetGeometry structure is request_mode, not
mask. The structure also has a border_width member.

** Pg. 382.

Second to the last sentence, last full paragraph should read:

"If the changes are unacceptable, or if the child's current geometry is
identical to the child's preferred geometry, the method should return
XtGeometryNo."

** Pg 383.

The comparison on the last two lines of code is incorrect in the book. It
should be

if(preferred->width <= request->width &&  
            preferred->height <= request->height){

similarly, in the same routine, the logic should be

if(request->request_mode & CWWidth){
      if(preferred->width <= request->width){
         	preferred->width = request->width;
         return (XtGeometryYes);

and 

if(request->request_mode & CWHeight){
      if(preferred->height <= request->height){
         	preferred->height = request->height;
         	return (XtGeometryYes);






@EOF

chmod 664 ERRATA

echo x - FILELIST
cat >FILELIST <<'@EOF'
			       EXAMPLE FILES

AppDefaults:

Chooseone     Formedit      Memo          Rctest        Traverse
Coloredit     Formtest      Menu          Rmtest        Twoshells
Controldata   Generic       MenuTest      Rowtest       XTalk
Dialog        Helptest      Notepad       Stopwatch     Xtalk


ch2:

Makefile   memo.c     memo1.c    memo2.c    memo3.c    memo4.c    memo5.c

ch3:

Makefile    draw.c      rmtest.c    rmtest2.c   rmtest3*    rmtest3.c

ch4:

Makefile       formedit.c     generic.c      menu2.c        rctest.c
chooseone.c    formtest.c     helptest.c     menu3.c        traverse.c
dialog.c       formtest1.c    menu.c         pushbutton.c   twoshells.c

ch5:

Makefile        select.c        tracker1.c      tracker3.c      xclock.c
mousetracks.c   stopwatch.c     tracker2.c      xbc.c

ch6:

Makefile      coloredit.c   coloredit.h   getpixel.c

ch7:

Makefile   raster.c   xlogo.c    xlogo2.c   xlogo64

ch9:

Makefile         fileview.c       fileview2.c      fileview4.c
fileview.h       fileview3.c      fileview3.h      fileview5.c

ch10:

Makefile       draw.h         fractal.h      rubberband.c
draw.c         fractal.c      fractal2.c

ch11:

Makefile        controldata.c   memo.c          notepad.c       xtalk.h
clipboard.c     data.h          monitordata.c   xtalk.c

ch12:

Dial.c          DialP.h         SquareDial.c    SquareDialP.h   sqdial.c
Dial.h          Makefile        SquareDial.h    dial.c

ch13:

Makefile    Row.c       Row.h       RowP.h      rowtest.c

ch14:

Makefile   Tree.c     Tree.h     TreeP.h    data       sort.c

lib:

Makefile         invert.c         send_msg.c       wprintf.c
concat.c         libXs.h          xmstr_to_str.c
concat.convert   menus.c          str2flt.c        xor.c
help_dialog.c    pix_buttons.c    strtoxmstr.c
insert.c         quit.c           talkto.c







@EOF

chmod 664 FILELIST

echo x - Makefile
cat >Makefile <<'@EOF'
#
# Makefile for widget examples
#
SHELL=/bin/sh

all: libXs chapter2 chapter4 chapter6 chapter8 chapter3 chapter5 \
     chapter7 chapter9 chapter10 chapter11 chapter12 chapter13 chapter14 
	

libXs: 
	cd lib; make ; cd ..

chapter2: libXs
	cd  ch2; make; cd ..
chapter4: libXs
	cd  ch4; make; cd ..
chapter6: libXs
	cd  ch6; make; cd ..
chapter8: libXs
	cd  ch8; make; cd ..
chapter3: libXs
	cd  ch3; make ; cd ..
chapter5: libXs
	cd  ch5; make ; cd ..
chapter7: libXs
	cd  ch7; make ; cd ..
chapter9: libXs
	cd  ch9; make ; cd ..
chapter10: libXs
	cd  ch10; make; cd ..
chapter11: libXs
	cd  ch11; make; cd ..
chapter12: libXs
	cd  ch12; make; cd ..
chapter13: libXs
	cd  ch13; make; cd ..
chapter14: libXs
	cd  ch14; make; cd ..
 
@EOF

chmod 664 Makefile

echo x - README
cat >README <<'@EOF'
This directory contains the source code for the examples in the book:

 "The X Window System: Programming and Applications with Xt, Motif Edition" 
   by Douglas Young

publisher: Prentice Hall, 1990
ISBN  0-13-497-074-8
Availability Date:  Jan 14, 1990
Prentice Hall order line: 201-767-5937

These examples are similar to those in the original version of the book, "X
Window Systems Programming and Applications with Xt", which used the HP
widget set. However, these examples now use the Motif widget set entirely.
In many cases, you can probably follow along from the old book. However,
I've not made any attempt to keep the examples exactly as in the original
book. In some cases the examples are identical, except for the use of
Motif. In other cases, the examples had to be altered drastically to
accomodate Motif. In still other cases, I simple decided to try a
different, hopefully better way to do things. And then a few examples are
all new for this edition.

Note that these programs are examples used to illustrate various aspects of
X, Xt, and Motif for the book. They don't necessarily represent the best
way to write certain tools, nor are the programs necessarily useful in
their own right (tho I hope some are). Each program was intended to
illustrate some point, and therefore the programs are often somewhat
contrived in order to do just that and also to fit into the space allotment
within a chapter.  It's not that any example is necessary the wrong way to
do something, but the goal was to demonstrate a particular feature of Xt or
Motif, not necessary to show the best way to design a graphics editor, or a
file viewer, or whatever.  I hope the examples are useful for the purpose
they were intended to serve.

I've caught a few bugs and made minor changes to a few of the programs
since the book went to press many months ago. These are noted in the
programs where they occur, with the old code ifdef'd as

#ifdef JUST_LIKE_BOOK
 /* Code described in book */
#else
 /* Fixed or improved version */
#endif

There are also a few extra programs, variations of examples that didn't
make it into the book for one reason or another.

To build the programs:

1. Copy the files in the AppDefaults directory to /usr/lib/X11/app-defaults

2. If you have lots of disc space, just do a make in this directroy.

3. Otherwise, go to the lib directory and do a make

4. Then go to a directory of interest and make the directory or an
   individual program








@EOF

chmod 664 README

echo mkdir - ch10
mkdir ch10

echo x - ch10/fractal.h
cat >ch10/fractal.h <<'@EOF'
/**********************************************************************************
 * fractal.h: declarations for the fractal program
  *         From:
  *                   The X Window System, 
  *            Programming and Applications with Xt
  *                   OSF/Motif Edition
  *         by
  *                Douglas Young
  *              Prentice Hall, 1990
  *
  *                 Example described on pages:  247-253
  *
  *
  *  Copyright 1989 by Prentice Hall
  *  All Rights Reserved
  *
  * This code is based on the OSF/Motif widget set and the X Window System
  *
  * Permission to use, copy, modify, and distribute this software for 
  * any purpose and without fee is hereby granted, provided that the above
  * copyright notice appear in all copies and that both the copyright notice
  * and this permission notice appear in supporting documentation.
  *
  * Prentice Hall and the author disclaim all warranties with regard to 
  * this software, including all implied warranties of merchantability and fitness.
  * In no event shall Prentice Hall or the author be liable for any special,
  * indirect or cosequential damages or any damages whatsoever resulting from 
  * loss of use, data or profits, whether in an action of contract, negligence 
  * or other tortious action, arising out of or in connection with the use 
  * or performance of this software.
  *
  * Open Software Foundation is a trademark of The Open Software Foundation, Inc.
  * OSF is a trademark of Open Software Foundation, Inc.
  * OSF/Motif is a trademark of Open Software Foundation, Inc.
  * Motif is a trademark of Open Software Foundation, Inc.
  * DEC is a registered trademark of Digital Equipment Corporation
  * HP is a registered trademark of the Hewlett Packard Company
  * DIGITAL is a registered trademark of Digital Equipment Corporation
  * X Window System is a trademark of the Massachusetts Institute of Technology
  **********************************************************************************/




#include <X11/StringDefs.h> 
#include <X11/Intrinsic.h> 
#include <Xm/Xm.h> 
#include <Xm/DrawingA.h> 
#include <X11/Xutil.h>
#include "libXs.h"

void     resize();
void     redisplay();
void     create_image ();
/*
 * Structure to represent a complex number.
 */
typedef struct {
  float  real, imag;
} complex;
/*
 * Assorted information needed to generate and draw the image.
 */
typedef struct {
  int          depth, ncolors;
  float        range, max_distance;
  complex      origin;
  GC           gc;
  Pixmap       pix;
  Dimension    width, height;
} image_data, *image_data_ptr;
/*
 * Resource that affect the appearance of the fractal image.
 */
static XtResource resources[] = {
 {"depth", "Depth", XtRInt, sizeof (int),
   XtOffset(image_data_ptr, depth), XtRString, "20"         },
 {"real_origin", "RealOrigin", XtRFloat, sizeof (float),
   XtOffset(image_data_ptr, origin.real), XtRString, "-1.4" },
 {"imaginary_origin","ImaginaryOrigin",XtRFloat,sizeof(float),
   XtOffset(image_data_ptr, origin.imag), XtRString, "1.0"  },
 {"range", "Range", XtRFloat, sizeof(float),
   XtOffset(image_data_ptr,range), XtRString, "2.0"         },
 {"max_distance", "MaxDistance", XtRFloat, sizeof (float),
   XtOffset(image_data_ptr, max_distance),XtRString, "4.0"  }
 };
@EOF

chmod 644 ch10/fractal.h

echo x - ch10/Makefile '[non-ascii]'
$unpacker <<'@eof'
begin 644 ch10/Makefile
M0T,@/2!C8R *6%-,24)$25(@/2 N+B]L:6(*1$5"54<@/2 *(R!(4"!-86-H
M:6YE<PI#1DQ!1U,@/2 D*$1%0E5'*2 M1%-94U8@("U))"A84TQ)0D1)4BD@
M"B,@1$5#(&%N9"!3=6X*(T-&3$%'4R ]("0H1$5"54<I("U))"A84TQ)0D1)
M4BD*"DQ)0E,@/2 N+B]L:6(O;&EB6',N82 M;%AM("UL6'0@+6Q8,3$*"BYO
M.BYC"@IA;&PZ(&9R86-T86P@9G)A8W1A;#(@<G5B8F5R8F%N9"!D<F%W"@IF
M<F%C=&%L(#H@9G)A8W1A;"YO"@DD*$-#*2 D*$-&3$%'4RD@+6\@)$ @)$ N
M;R D*$Q)0E,I"@IF<F%C=&%L,B Z(&9R86-T86PR+F\*"20H0T,I("0H0T9,
M04=3*2 M;R D0" D0"YO("0H3$E"4RD*"G)U8F)E<F)A;F0Z(')U8F)E<F)A
M;F0N;PH))"A#0RD@)"A#1DQ!1U,I("UO("1 ("1 +F\@)"A,24)3*0H*9')A
M=SH@9')A=RYO"@DD*$-#*2 D*$-&3$%'4RD@+6\@)$ @)$ N;R D*$Q)0E,I
M"@ID<F%W,CH@9')A=S(N;PH))"A#0RD@)"A#1DQ!1U,I("UO("1 ("1 +F\@
/)"A,24)3*2 @"@H*(" @
 
end
@eof

chmod 644 ch10/Makefile

echo x - ch10/fractal.c
cat >ch10/fractal.c <<'@EOF'
/**********************************************************************************
  * fractal.c: A simple fractal generator
  *         From:
  *                   The X Window System, 
  *            Programming and Applications with Xt
  *                   OSF/Motif Edition
  *         by
  *                Douglas Young
  *              Prentice Hall, 1990
  *
  *                 Example described on pages:  247-253
  *
  *
  *  Copyright 1989 by Prentice Hall
  *  All Rights Reserved
  *
  * This code is based on the OSF/Motif widget set and the X Window System
  *
  * Permission to use, copy, modify, and distribute this software for 
  * any purpose and without fee is hereby granted, provided that the above
  * copyright notice appear in all copies and that both the copyright notice
  * and this permission notice appear in supporting documentation.
  *
  * Prentice Hall and the author disclaim all warranties with regard to 
  * this software, including all implied warranties of merchantability and fitness.
  * In no event shall Prentice Hall or the author be liable for any special,
  * indirect or cosequential damages or any damages whatsoever resulting from 
  * loss of use, data or profits, whether in an action of contract, negligence 
  * or other tortious action, arising out of or in connection with the use 
  * or performance of this software.
  *
  * Open Software Foundation is a trademark of The Open Software Foundation, Inc.
  * OSF is a trademark of Open Software Foundation, Inc.
  * OSF/Motif is a trademark of Open Software Foundation, Inc.
  * Motif is a trademark of Open Software Foundation, Inc.
  * DEC is a registered trademark of Digital Equipment Corporation
  * HP is a registered trademark of the Hewlett Packard Company
  * DIGITAL is a registered trademark of Digital Equipment Corporation
  * X Window System is a trademark of the Massachusetts Institute of Technology
  **********************************************************************************/

#include "fractal.h"

main(argc, argv)
     int   argc;
     char *argv[];
{
  Widget     toplevel, canvas;
  image_data data;
  toplevel = XtInitialize(argv[0], "Fractal", NULL, 0, 
                          &argc, argv);
 /*
  *  Add the string to float type converter.
  */
 XtAddConverter(XtRString, XtRFloat, xs_cvt_str_to_float, 
                NULL, 0);
 XtGetApplicationResources(toplevel, &data, resources, 
                           XtNumber(resources), NULL, 0);
 /*
  * Create the widget to display the fractal and register
  * callbacks for resize and refresh.
  */
 canvas = XtCreateManagedWidget("canvas", 
                                xmDrawingAreaWidgetClass, 
                                toplevel, NULL, 0);
 init_data(canvas, &data);  
 XtAddCallback(canvas, XmNexposeCallback, redisplay, &data); 
 XtAddCallback(canvas, XmNresizeCallback, resize, &data); 
 XtRealizeWidget(toplevel);
 resize(canvas, &data, NULL);
 XtMainLoop();
}

init_data(w, data)
    Widget      w;
    image_data *data;
{
  int y;
  Arg wargs[2];
  /*
   * Get the size of the drawing area.
   */
  XtSetArg(wargs[0], XtNwidth,  &data->width);
  XtSetArg(wargs[1], XtNheight, &data->height);
  XtGetValues(w, wargs,2);
  /*
   * Find out how many colors we have to work with, and  
   * create a default, writable, graphics context.
   */
  data->ncolors = XDisplayCells(XtDisplay(w), 
                                XDefaultScreen(XtDisplay(w)));
  data->gc = XCreateGC(XtDisplay(w),
                       DefaultRootWindow(XtDisplay(w)),
                       NULL, NULL); 
  /*
   *  Initialize the pixmap to NULL.
   */
  data->pix = NULL;
}

void create_image (w, data)
     Widget          w;
     image_data     *data;
{
 int  x, y, iteration;
 /*
  * For each pixel on the window....
  */
 for (y = 0; y < data->height; y++) {
  for (x = 0; x < data->width; x++) {
    complex z, k;
   /*
    * Initialize K to the normalized, floating coordinate
    * in the x, y plane. Init Z to (0.0, 0.0).
    */
    z.real =  z.imag = 0.0;
    k.real =  data->origin.real + (float) x / 
                 (float) data->width * data->range;
    k.imag =  data->origin.imag - (float) y / 
                 (float) data->height * data->range;
   /*
    * Calculate z = (z + k) * (z + k) over and over.
    */
   for (iteration = 0; iteration < data->depth; iteration++){
      float   distance, real_part, imag_part;

      real_part = z.real + k.real;
      imag_part = z.imag + k.imag;
      z.real = real_part * real_part - imag_part * imag_part;
      z.imag = 2 * real_part * imag_part;
      distance  = z.real * z.real + z.imag * z.imag;     
     /*
      * If the z point has moved off the plane, set the 
      * current foreground color to the distance (coerced to 
      * an int and modulo the number of colors available),
      * and draw a point in both the window and the pixmap.
      */
     if (distance  >= data->max_distance){ 
       int color = (int) distance % data->ncolors;

       XSetForeground(XtDisplay(w), data->gc, color);
       XDrawPoint (XtDisplay(w), data->pix, data->gc, x, y);
       if(XtIsRealized(w))
        XDrawPoint (XtDisplay(w), XtWindow(w), data->gc,x,y);
       break;
     }
   }
  }
 }
}

void redisplay (w, data, call_data)
     Widget          w;
     image_data     *data;
     XmDrawingAreaCallbackStruct    *call_data;
{
 XExposeEvent  *event = (XExposeEvent *) call_data->event;
 /*
  * Extract the exposed area from the event and copy
  * from the saved pixmap to the window.
  */
  XCopyArea(XtDisplay(w), data->pix, XtWindow(w), data->gc, 
            event->x, event->y, event->width, event->height, 
            event->x, event->y);
}

void resize(w, data, call_data)
     Widget         w;
     image_data    *data;
     caddr_t        call_data;
{
  Arg wargs[10];
  /*
   *  Get the new window size.
   */
  XtSetArg(wargs[0], XtNwidth,  &data->width);
  XtSetArg(wargs[1], XtNheight, &data->height);
  XtGetValues(w, wargs, 2);
  /*
   * Clear the window.
   */
   if(XtIsRealized(w))
       XClearArea(XtDisplay(w), XtWindow(w), 0, 0, 0, 0, TRUE);
  /*
   *  Free the old pixmap and create a new pixmap 
   *  the size of the window.
   */
  if(data->pix)
     XFreePixmap(XtDisplay(w), data->pix);
  data->pix= XCreatePixmap(XtDisplay(w),
                           DefaultRootWindow(XtDisplay(w)),
                           data->width, data->height, 
                           DefaultDepthOfScreen(XtScreen(w)));
  XSetForeground(XtDisplay(w), data->gc,
                 BlackPixelOfScreen(XtScreen(w)));
  XFillRectangle(XtDisplay(w), data->pix, data->gc, 0, 0, 
                 data->width,  data->height);
  /*
   * Generate a new image.
    */
  create_image(w, data);
}

@EOF

chmod 644 ch10/fractal.c

echo x - ch10/draw.c
cat >ch10/draw.c <<'@EOF'
/**********************************************************************************
  * draw.c: a simple graphics drawing program.
  *         From:
  *                   The X Window System, 
  *            Programming and Applications with Xt
  *                   OSF/Motif Edition
  *         by
  *                Douglas Young
  *              Prentice Hall, 1990
  *
  *                 Example described on pages:  266-279
  *
  *
  *  Copyright 1989 by Prentice Hall
  *  All Rights Reserved
  *
  * This code is based on the OSF/Motif widget set and the X Window System
  *
  * Permission to use, copy, modify, and distribute this software for 
  * any purpose and without fee is hereby granted, provided that the above
  * copyright notice appear in all copies and that both the copyright notice
  * and this permission notice appear in supporting documentation.
  *
  * Prentice Hall and the author disclaim all warranties with regard to 
  * this software, including all implied warranties of merchantability and fitness.
  * In no event shall Prentice Hall or the author be liable for any special,
  * indirect or cosequential damages or any damages whatsoever resulting from 
  * loss of use, data or profits, whether in an action of contract, negligence 
  * or other tortious action, arising out of or in connection with the use 
  * or performance of this software.
  *
  * Open Software Foundation is a trademark of The Open Software Foundation, Inc.
  * OSF is a trademark of Open Software Foundation, Inc.
  * OSF/Motif is a trademark of Open Software Foundation, Inc.
  * Motif is a trademark of Open Software Foundation, Inc.
  * DEC is a registered trademark of Digital Equipment Corporation
  * HP is a registered trademark of the Hewlett Packard Company
  * DIGITAL is a registered trademark of Digital Equipment Corporation
  * X Window System is a trademark of the Massachusetts Institute of Technology
  **********************************************************************************/


#include "draw.h"

main(argc, argv)
   int   argc;
   char *argv[];
{
  Widget        toplevel, canvas, framework, command, tiles;
  graphics_data data;
  int           n;
  Arg           wargs[10];
    
  toplevel = XtInitialize(argv[0], "Draw", NULL, 0, 
                          &argc, argv);
  framework = XtCreateManagedWidget("framework", 
                                    xmFormWidgetClass, 
                                    toplevel, NULL, 0);
  /*
   * Create the column to hold the commands.
   */
  command = XtCreateManagedWidget("command", 
                                  xmRowColumnWidgetClass, 
                                  framework, NULL, 0);
  /*
   * Create the drawing surface and add the 
   * rubber banding callbacks.
   */
  canvas = XtCreateManagedWidget("canvas",
                                 xmDrawingAreaWidgetClass, 
                                 framework, NULL, 0);
  XtAddCallback(canvas, XmNexposeCallback, refresh, &data);

  XtAddEventHandler(canvas, ButtonPressMask, FALSE,
                    start_rubber_band, &data);
  XtAddEventHandler(canvas, ButtonMotionMask, FALSE,
                    track_rubber_band, &data);
  XtAddEventHandler(canvas, ButtonReleaseMask, FALSE,
                    end_rubber_band, &data);
  n = 0;
  XtSetArg(wargs[n], XmNtopAttachment,    XmATTACH_FORM);n++;
  XtSetArg(wargs[n], XmNbottomAttachment, XmATTACH_FORM);n++;
  XtSetArg(wargs[n], XmNleftAttachment,   XmATTACH_FORM);n++;
  XtSetValues(command, wargs, n);

  n = 0;
  XtSetArg(wargs[n], XmNtopAttachment,   XmATTACH_FORM);  n++;
  XtSetArg(wargs[n], XmNbottomAttachment,XmATTACH_FORM);  n++;
  XtSetArg(wargs[n], XmNleftAttachment,  XmATTACH_WIDGET);n++;
  XtSetArg(wargs[n], XmNleftWidget,     command);         n++;
  XtSetArg(wargs[n], XmNrightAttachment,  XmATTACH_FORM); n++;
  XtSetValues(canvas, wargs, n);
  /*
   * Initialize the graphics buffer and other data.
   */
  init_data(canvas, &data);
  /*
   * Add a quit button.
   */
  xs_create_quit_button(command);
  /*
   * Add the drawing command panel.
   */ 
  create_drawing_commands(command, &data);
  /*
   * Add a palette of fill patterns.
   */
  xs_register_pattern(toplevel, "foreground", fg_bitmap,
                     fg_width, fg_height);
  tiles = xs_create_pixmap_browser(command, 
                                   patterns,
                                   XtNumber(patterns), 
                                   set_fill_pattern, &data);
  XtManageChild(tiles);
  XtRealizeWidget(toplevel);
  /*
   * Establish a passive grab on the drawing canvas window.
   */
  XGrabButton(XtDisplay(canvas), AnyButton, AnyModifier, 
              XtWindow(canvas), TRUE, 
              ButtonPressMask | ButtonMotionMask | 
              ButtonReleaseMask,
              GrabModeAsync, GrabModeAsync,
              XtWindow(canvas), 
              XCreateFontCursor(XtDisplay(canvas),
                                XC_crosshair));
  XtMainLoop();
}

struct {
  char   *name;
  void   (*func)();
}  command_info[] = {
      "Line",             draw_line,
      "Circle",           draw_circle,
      "Rectangle",        draw_rectangle,
      "Filled Circle",    draw_filled_circle,
      "Filled Rectangle", draw_filled_rectangle
 };

create_drawing_commands(parent, data)
     Widget         parent;
     graphics_data *data;
{
  Widget  w, commands;
  Arg     wargs[2];
  int     i;
  /*
   * Group all commands in a column.
   */
  XtSetArg(wargs[0], XmNentryClass, xmToggleButtonWidgetClass);
    commands = XmCreateRadioBox(parent, "commands", 
                              wargs, 1);
  XtManageChild(commands);
  /*
   * Create a button for each drawing function.
   */
  for(i=0;i < XtNumber(command_info); i++){
    XtSetArg(wargs[0], XmNuserData, command_info[i].func);
    w = XtCreateManagedWidget(command_info[i].name,
                              xmToggleButtonWidgetClass, 
                              commands, wargs, 1);
    XtAddCallback(w, XmNvalueChangedCallback, activate, data);
  }
}

void set_fill_pattern(w, data, call_data)
     Widget         w;
     graphics_data *data;
     XmToggleButtonCallbackStruct  *call_data;
{
  Pixmap    tile;
  int       i;
  XGCValues values;
  Arg       wargs[1];

 static int mask = GCForeground | GCBackground | 
                   GCTile | GCFillStyle;

 if(call_data->reason==XmCR_VALUE_CHANGED && call_data->set){
   XtSetArg(wargs[0], XmNuserData, &tile);
   XtGetValues(w, wargs, 1);
   /* 
    * Get a GC using this tile pattern 
    */
   values.foreground = data->foreground;
   values.background = data->background;
   values.fill_style = FillTiled;
   values.tile       = tile;
   data->gc = XtGetGC(w, mask, &values);   
 }
}

init_data(w, data)
     Widget          w;
     graphics_data  *data;
{
  XGCValues values;
  Arg       wargs[5];
  data->current_func = NULL;
  data->next_pos     = 0;
  /*
   * Get the colors the user has set for the widget. 
   */
  XtSetArg(wargs[0], XtNforeground, &data->foreground);
  XtSetArg(wargs[1], XtNbackground, &data->background);
  XtGetValues(w, wargs,2);
  /*
   * Fill in the values structure
   */  
  values.foreground = data->foreground;
  values.background = data->background;
  values.fill_style = FillTiled;
  /*
   * Get the GC used for drawing.
   */
  data->gc= XtGetGC(w, GCForeground | GCBackground |
                       GCFillStyle, &values);
  /*
   * Get a second GC in XOR mode for rubber banding.
   */
  data->xorgc = xs_create_xor_gc(w);
}

void start_rubber_band(w, data, event)
        Widget          w;
        graphics_data  *data;
        XEvent         *event;
{
  if(data->current_func){
    /*
     * Store the starting point and draw the initial figure.
     */
    data->last_x = data->start_x = event->xbutton.x;
    data->last_y = data->start_y = event->xbutton.y;
    (*(data->current_func))(w, data->xorgc,
                            data->start_x, data->start_y, 
                            data->last_x, data->last_y);
  }
}

void track_rubber_band(w, data, event)
        Widget          w;
        graphics_data  *data;
        XEvent         *event;
{ 
 if(data->current_func){
   /*
    * Erase the previous figure.
    */
   (*(data->current_func))(w, data->xorgc,
                           data->start_x, data->start_y, 
                           data->last_x, data->last_y);
    /*
     * Update the last point.
     */
    data->last_x  =  event->xbutton.x;
    data->last_y  =  event->xbutton.y;
    /*
     * Draw the figure in the new position.
     */
    (*(data->current_func))(w, data->xorgc,
                            data->start_x, data->start_y, 
                            data->last_x, data->last_y);
  }
}

void end_rubber_band(w, data, event)
        Widget          w;
        graphics_data  *data;
        XEvent         *event;
{
  if(data->current_func){
    /*
     * Erase the XOR image. 
     */
    (*(data->current_func))(w, data->xorgc,
                            data->start_x, data->start_y, 
                            data->last_x, data->last_y);
    /*
     * Draw the figure using the normal GC. 
     */
    (*(data->current_func))(w, data->gc,
                            data->start_x, data->start_y, 
                            event->xbutton.x, 
                            event->xbutton.y);
    /*
     * Update the data, and store the object in 
     * the graphics buffer.
     */
    data->last_x  =  event->xbutton.x;
    data->last_y  =  event->xbutton.y;
    store_object(data);
  }
}

void draw_line(w, gc, x, y, x2, y2)
     Widget  w;
     GC      gc;
     int     x, y, x2, y2;
{
  Display *dpy = XtDisplay(w);
  Window   win = XtWindow(w);
  XDrawLine(dpy, win, gc, x, y, x2, y2);
}

void draw_rectangle(w, gc, x, y, x2, y2)
     Widget w;
     GC     gc;
     int    x, y, x2, y2;
{
  Display *dpy = XtDisplay(w);
  Window   win = XtWindow(w);

  check_points(&x, &y, &x2, &y2);
  XDrawRectangle(dpy, win, gc,  x, y, x2 - x, y2 - y);
}

void draw_filled_rectangle(w, gc, x, y, x2, y2)
     Widget  w;
     GC      gc;
     int     x, y, x2, y2;
{
  Display *dpy = XtDisplay(w);
  Window   win = XtWindow(w);

  check_points(&x, &y, &x2, &y2);
  XFillRectangle(dpy, win, gc, x, y, x2 - x, y2 - y);
}

check_points(x, y, x2, y2)
   int *x, *y, *x2, *y2;
{
  if(*x2 < *x){ int tmp = *x; *x = *x2; *x2 = tmp;}
  if(*y2 < *y){ int tmp = *y; *y = *y2; *y2 = tmp;}
}

void draw_circle(w, gc, x, y, x2, y2)
     Widget  w;
     GC      gc;
     int     x, y, x2, y2;
{
  Display *dpy = XtDisplay(w);
  Window   win = XtWindow(w);

  check_points(&x, &y, &x2, &y2);
  XDrawArc(dpy, win, gc, x, y, x2 - x, y2 - y, 0, 64 * 360);
}

void draw_filled_circle(w, gc, x, y, x2, y2)
     Widget  w;
     GC      gc;
     int     x, y, x2, y2;
{
  Display *dpy = XtDisplay(w);
  Window   win = XtWindow(w);

  check_points(&x, &y, &x2, &y2);
  XFillArc(dpy, win, gc, x, y, x2 - x, y2 - y, 0, 64 * 360);
}

void activate(w, data, call_data)
     Widget          w;
     graphics_data  *data;
     XmToggleButtonCallbackStruct   *call_data;
{
  int (*func)();
  Arg wargs[5];

  if(!call_data->set) return;

  XtSetArg(wargs[0], XmNuserData, &func);
  XtGetValues(w, wargs, 1);
  data->current_func = func; 
}

store_object(data)
     graphics_data *data;
{
  /* 
   * Check for space.
   */
  if(data->next_pos >= MAXOBJECTS){
   printf("Warning: Graphics buffer is full\n");
   return;
  }
  /*
   * Save everything we need to draw this object again.
   */
  data->buffer[data->next_pos].x1 = data->start_x;
  data->buffer[data->next_pos].y1 = data->start_y;
  data->buffer[data->next_pos].x2 = data->last_x;
  data->buffer[data->next_pos].y2 = data->last_y;
  data->buffer[data->next_pos].func = data->current_func;
  data->buffer[data->next_pos].gc = data->gc;
  /*
   * Increment the next position index.
   */
  data->next_pos++;
}

void refresh(w, data, call_data)
   Widget          w;
   graphics_data  *data;
   caddr_t         call_data;
{
  int i;
  for(i=0;i<data->next_pos;i++)
    (* (data->buffer[i].func))(w, data->buffer[i].gc,
                              data->buffer[i].x1,
                              data->buffer[i].y1,
                              data->buffer[i].x2,
                              data->buffer[i].y2);
}
@EOF

chmod 644 ch10/draw.c

echo x - ch10/fractal2.c
cat >ch10/fractal2.c <<'@EOF'
/**********************************************************************************
  * fractal2.c: A simple fractal generator, improved
  *         From:
  *                   The X Window System, 
  *            Programming and Applications with Xt
  *                   OSF/Motif Edition
  *         by
  *                Douglas Young
  *              Prentice Hall, 1990
  *
  *                 Example described on pages:  253-258
  *
  *
  *  Copyright 1989 by Prentice Hall
  *  All Rights Reserved
  *
  * This code is based on the OSF/Motif widget set and the X Window System
  *
  * Permission to use, copy, modify, and distribute this software for 
  * any purpose and without fee is hereby granted, provided that the above
  * copyright notice appear in all copies and that both the copyright notice
  * and this permission notice appear in supporting documentation.
  *
  * Prentice Hall and the author disclaim all warranties with regard to 
  * this software, including all implied warranties of merchantability and fitness.
  * In no event shall Prentice Hall or the author be liable for any special,
  * indirect or cosequential damages or any damages whatsoever resulting from 
  * loss of use, data or profits, whether in an action of contract, negligence 
  * or other tortious action, arising out of or in connection with the use 
  * or performance of this software.
  *
  * Open Software Foundation is a trademark of The Open Software Foundation, Inc.
  * OSF is a trademark of Open Software Foundation, Inc.
  * OSF/Motif is a trademark of Open Software Foundation, Inc.
  * Motif is a trademark of Open Software Foundation, Inc.
  * DEC is a registered trademark of Digital Equipment Corporation
  * HP is a registered trademark of the Hewlett Packard Company
  * DIGITAL is a registered trademark of Digital Equipment Corporation
  * X Window System is a trademark of the Massachusetts Institute of Technology
  **********************************************************************************/

#include "fractal.h"

main(argc, argv)
     int   argc;
     char *argv[];
{
  Widget     toplevel, canvas;
  image_data data;
  toplevel = XtInitialize(argv[0], "Fractal", NULL, 0, 
                          &argc, argv);
 /*
  *  Add the string to float type converter.
  */
 XtAddConverter(XtRString, XtRFloat, xs_cvt_str_to_float, 
                NULL, 0);
 XtGetApplicationResources(toplevel, &data, resources, 
                           XtNumber(resources), NULL, 0);
 /*
  * Create the widget to display the fractal and register
  * callbacks for resize and refresh.
  */
 canvas = XtCreateManagedWidget("canvas", 
                                xmDrawingAreaWidgetClass, 
                                toplevel, NULL, 0);
 init_data(canvas, &data);  
 XtAddCallback(canvas, XmNexposeCallback, redisplay, &data); 
 XtAddCallback(canvas, XmNresizeCallback, resize, &data); 
 XtRealizeWidget(toplevel);
 resize(canvas, &data, NULL);
 XtMainLoop();
}

init_data(w, data)
    Widget      w;
    image_data *data;
{
  int y;
  Arg wargs[2];
  /*
   * Get the size of the drawing area.
   */
  XtSetArg(wargs[0], XtNwidth,  &data->width);
  XtSetArg(wargs[1], XtNheight, &data->height);
  XtGetValues(w, wargs,2);
  /*
   * Find out how many colors we have to work with, and  
   * create a default, writable, graphics context.
   */
  data->ncolors = XDisplayCells(XtDisplay(w), 
                                XDefaultScreen(XtDisplay(w)));
  data->gc = XCreateGC(XtDisplay(w),
                       DefaultRootWindow(XtDisplay(w)),
                       NULL, NULL); 
  /*
   *  Initialize the pixmap to NULL.
   */
  data->pix = NULL;
}


void redisplay (w, data, call_data)
     Widget          w;
     image_data     *data;
     XmDrawingAreaCallbackStruct    *call_data;
{
 XExposeEvent  *event = (XExposeEvent *) call_data->event;
 /*
  * Extract the exposed area from the event and copy
  * from the saved pixmap to the window.
  */
  XCopyArea(XtDisplay(w), data->pix, XtWindow(w), data->gc, 
            event->x, event->y, event->width, event->height, 
            event->x, event->y);
}

void resize(w, data, call_data)
     Widget         w;
     image_data    *data;
     caddr_t        call_data;
{
  Arg wargs[10];
  /*
   *  Get the new window size.
   */
  XtSetArg(wargs[0], XtNwidth,  &data->width);
  XtSetArg(wargs[1], XtNheight, &data->height);
  XtGetValues(w, wargs, 2);
  /*
   * Clear the window.
   */
   if(XtIsRealized(w))
       XClearArea(XtDisplay(w), XtWindow(w), 0, 0, 0, 0, TRUE);
  /*
   *  Free the old pixmap and create a new pixmap 
   *  the size of the window.
   */
  if(data->pix)
     XFreePixmap(XtDisplay(w), data->pix);
  data->pix= XCreatePixmap(XtDisplay(w),
                           DefaultRootWindow(XtDisplay(w)),
                           data->width, data->height, 
                           DefaultDepthOfScreen(XtScreen(w)));
  XSetForeground(XtDisplay(w), data->gc,
                 BlackPixelOfScreen(XtScreen(w)));
  XFillRectangle(XtDisplay(w), data->pix, data->gc, 0, 0, 
                 data->width,  data->height);
  /*
   * Generate a new image.
    */
  create_image(w, data);
}


void create_image (w, data)
     Widget          w;
     image_data           *data;
{
 int x, y, iteration;
 /*
  * We have to buffer all points of the same color, until
  * enough points are available to draw efficiently. Start
  * by zeroing all buffers.
  */
 init_buffer(data);
  /*
   * For each pixel on the window....
   */
 for (y = 0; y < data->height; y++) {
  for (x = 0; x < data->width; x++) {
   complex z, k;
   /*
    *  Initialize K to the normalized, floating coordinate in 
    *  the x,y plane. Init Z to (0.0, 0.0).
    */
   z.real = z.imag = 0.0;
   k.real =  data->origin.real + (float) x / 
                 (float) data->width * data->range;
   k.imag =  data->origin.imag - (float) y / 
                (float) data->height * data->range;
   /*
    * Calculate z = (z + k) * (z + k) over and over.
    */
   for (iteration = 0; iteration < data->depth; iteration++){
    float distance, real_part, imag_part;
    real_part = z.real + k.real;
    imag_part = z.imag + k.imag;
    z.real    = real_part * real_part - imag_part * imag_part;
    z.imag    = 2 * real_part * imag_part;
    distance  = z.real * z.real + z.imag * z.imag;     
    /*
     * If the z point has moved off the plane, buffer the
     * point using the integerized distance (modulo the 
     * number of colors we have) as the color.
     */
    if (distance  >= data->max_distance){ 
      buffer_point(w, data, (int) distance % data->ncolors,
                   x, y);
      break;
    }
   }
  }
}
/*
 * Display all remaining points.
 */
 flush_buffer(w, data);
}

#define MAXPOINTS 500
#define MAXCOLOR  256

struct{
   XPoint  data[MAXCOLOR][MAXPOINTS];
   int     npoints[MAXCOLOR];
} points;

init_buffer(data)
     image_data *data;
{
  int i;
  if (data->ncolors > MAXCOLOR)
     XtError("This display has too many colors");
  for(i=0;i<MAXCOLOR;i++)
    points.npoints[i] = 0;
}

buffer_point(w, data, color, x , y)
     Widget      w;
     image_data *data;
     int         color, x,y;
{
  if(points.npoints[color] == MAXPOINTS - 1){
    /*
     * If the buffer is full, set the foreground color
     * of the graphics context and draw the points in both
     * the window and the pixmap.
     */
    XSetForeground(XtDisplay(w), data->gc, color);
    if(XtIsRealized(w))
      XDrawPoints (XtDisplay(w), XtWindow(w), data->gc, 
                   points.data[color], points.npoints[color], 
                   CoordModeOrigin);
    XDrawPoints (XtDisplay(w), data->pix, data->gc, 
                 points.data[color], points.npoints[color], 
                 CoordModeOrigin);
    /*
     * Reset the buffer.
     */
    points.npoints[color] = 0;
  }
  /*
   * Store the point in the buffer according to its color.
   */
  points.data[color][points.npoints[color]].x = x;
  points.data[color][points.npoints[color]].y = y;
  points.npoints[color] += 1;
}

flush_buffer(w, data)
     Widget      w;
     image_data *data;
{ 
  int i;
  /*
   * Check each buffer.
   */
  for(i=0;i<data->ncolors;i++)
    /*
     * If there are any points in this buffer, display them
     * in the window and the pixmap.
     */
    if(points.npoints[i]){
      XSetForeground(XtDisplay(w), data->gc, i);
      if(XtIsRealized(w))
        XDrawPoints (XtDisplay(w), XtWindow(w), data->gc, 
                     points.data[i], points.npoints[i], 
                     CoordModeOrigin);
        XDrawPoints (XtDisplay(w), data->pix, data->gc, 
                     points.data[i], points.npoints[i], 
                     CoordModeOrigin);
      points.npoints[i] = 0;
    }
}
@EOF

chmod 644 ch10/fractal2.c

echo x - ch10/rubberband.c
cat >ch10/rubberband.c <<'@EOF'
/**********************************************************************************
  * rubberband.c: rubberband line example
  *         From:
  *                   The X Window System, 
  *            Programming and Applications with Xt
  *                   OSF/Motif Edition
  *         by
  *                Douglas Young
  *              Prentice Hall, 1990
  *
  *                 Example described on pages:  259-263
  *
  *
  *  Copyright 1989 by Prentice Hall
  *  All Rights Reserved
  *
  * This code is based on the OSF/Motif widget set and the X Window System
  *
  * Permission to use, copy, modify, and distribute this software for 
  * any purpose and without fee is hereby granted, provided that the above
  * copyright notice appear in all copies and that both the copyright notice
  * and this permission notice appear in supporting documentation.
  *
  * Prentice Hall and the author disclaim all warranties with regard to 
  * this software, including all implied warranties of merchantability and fitness.
  * In no event shall Prentice Hall or the author be liable for any special,
  * indirect or cosequential damages or any damages whatsoever resulting from 
  * loss of use, data or profits, whether in an action of contract, negligence 
  * or other tortious action, arising out of or in connection with the use 
  * or performance of this software.
  *
  * Open Software Foundation is a trademark of The Open Software Foundation, Inc.
  * OSF is a trademark of Open Software Foundation, Inc.
  * OSF/Motif is a trademark of Open Software Foundation, Inc.
  * Motif is a trademark of Open Software Foundation, Inc.
  * DEC is a registered trademark of Digital Equipment Corporation
  * HP is a registered trademark of the Hewlett Packard Company
  * DIGITAL is a registered trademark of Digital Equipment Corporation
  * X Window System is a trademark of the Massachusetts Institute of Technology
  **********************************************************************************/

#include <X11/StringDefs.h>
#include <X11/Intrinsic.h> 
#include <X11/cursorfont.h>
#include <Xm/Xm.h>
#include <Xm/DrawingA.h>
#include "libXs.h"

typedef struct {
    int start_x, start_y, last_x, last_y;
    GC  gc;
  } rubber_band_data;

void start_rubber_band();
void end_rubber_band();
void track_rubber_band();


main(argc, argv)
 int   argc;
 char *argv[];
{
  Widget           toplevel, canvas;
  rubber_band_data data;
   
  toplevel = XtInitialize(argv[0], "Rubberband", NULL, 0, 
                          &argc, argv);
  /*
   * Create a drawing surface, and add event handlers for
   * ButtonPress, ButtonRelease and MotionNotify events.
   */
  canvas = XtCreateManagedWidget("canvas", 
                                 xmDrawingAreaWidgetClass, 
                                 toplevel, NULL, 0);
  XtAddEventHandler(canvas, ButtonPressMask, FALSE,
                    start_rubber_band, &data);
  XtAddEventHandler(canvas, ButtonMotionMask, FALSE,
                    track_rubber_band, &data);
  XtAddEventHandler(canvas, ButtonReleaseMask,
                    FALSE, end_rubber_band, &data);
  XtRealizeWidget(toplevel);
  /*
   * Establish a passive grab, for any button press.
   * Force the sprite to stay within the canvas window, and
   * change the sprite to a cross_hair.
   */
   XGrabButton(XtDisplay(canvas), AnyButton, AnyModifier, 
               XtWindow(canvas), TRUE, 
               ButtonPressMask | ButtonMotionMask | 
               ButtonReleaseMask,
               GrabModeAsync, GrabModeAsync,
               XtWindow(canvas), 
               XCreateFontCursor(XtDisplay(canvas),
                                 XC_crosshair));
  /*
   * Create the GC used by the rubber banding functions.
   */
  data.gc = xs_create_xor_gc(canvas); 
  XtMainLoop();
}

void start_rubber_band(w, data, event)
    Widget             w;
    rubber_band_data   *data;
    XEvent             *event;
{
  data->last_x  =  data->start_x = event->xbutton.x;
  data->last_y  =  data->start_y = event->xbutton.y;
   XDrawLine(XtDisplay(w), XtWindow(w), 
            data->gc, data->start_x, 
            data->start_y, data->last_x, data->last_y);
}

void track_rubber_band(w, data, event)
    Widget             w;
    rubber_band_data  *data;
    XEvent            *event;
{
  /*
   * Draw once to clear the previous line.
   */
  XDrawLine(XtDisplay(w), XtWindow(w), data->gc, 
            data->start_x,data->start_y, 
            data->last_x, data->last_y);
  /*
   * Update the endpoints.
   */
  data->last_x  =  event->xbutton.x;
  data->last_y  =  event->xbutton.y;
  /*
   * Draw the new line.
   */
  XDrawLine(XtDisplay(w), XtWindow(w), data->gc, 
            data->start_x, data->start_y, 
            data->last_x, data->last_y);
}

void end_rubber_band(w, data, event)
   Widget            w;
   rubber_band_data *data;
   XEvent           *event;
{
 /*
  * Clear the current line and update the endpoint info.
  */
  XDrawLine(XtDisplay(w), XtWindow(w), data->gc, 
            data->start_x, data->start_y, 
            data->last_x, data->last_y);
  data->last_x  =  event->xbutton.x;
  data->last_y  =  event->xbutton.y;
}
@EOF

chmod 644 ch10/rubberband.c

echo x - ch10/draw.h
cat >ch10/draw.h <<'@EOF'
/**********************************************************************************
  * draw.h: declarations for the draw program
  *         From:
  *                   The X Window System, 
  *            Programming and Applications with Xt
  *                   OSF/Motif Edition
  *         by
  *                Douglas Young
  *              Prentice Hall, 1990
  *
  *                 Example described on pages:  266-279
  *
  *
  *  Copyright 1989 by Prentice Hall
  *  All Rights Reserved
  *
  * This code is based on the OSF/Motif widget set and the X Window System
  *
  * Permission to use, copy, modify, and distribute this software for 
  * any purpose and without fee is hereby granted, provided that the above
  * copyright notice appear in all copies and that both the copyright notice
  * and this permission notice appear in supporting documentation.
  *
  * Prentice Hall and the author disclaim all warranties with regard to 
  * this software, including all implied warranties of merchantability and fitness.
  * In no event shall Prentice Hall or the author be liable for any special,
  * indirect or cosequential damages or any damages whatsoever resulting from 
  * loss of use, data or profits, whether in an action of contract, negligence 
  * or other tortious action, arising out of or in connection with the use 
  * or performance of this software.
  *
  * Open Software Foundation is a trademark of The Open Software Foundation, Inc.
  * OSF is a trademark of Open Software Foundation, Inc.
  * OSF/Motif is a trademark of Open Software Foundation, Inc.
  * Motif is a trademark of Open Software Foundation, Inc.
  * DEC is a registered trademark of Digital Equipment Corporation
  * HP is a registered trademark of the Hewlett Packard Company
  * DIGITAL is a registered trademark of Digital Equipment Corporation
  * X Window System is a trademark of the Massachusetts Institute of Technology
  **********************************************************************************/




#include <X11/StringDefs.h>
#include <X11/cursorfont.h>
#include <X11/Intrinsic.h> 
#include <X11/Xutil.h>
#include <Xm/Xm.h>
#include <Xm/DrawingA.h>
#include <Xm/RowColumn.h>
#include <Xm/Form.h>
#include <Xm/PushB.h>
#include <Xm/ToggleB.h>
#include <Xm/Label.h>
#include "libXs.h"

#define MAXOBJECTS 1000

static unsigned char fg_bitmap[32] = {
      0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, /* 
solid foreground  */
      0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
      0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
      0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff  
};
#define fg_width  16
#define fg_height 16

static char *patterns[] = {  "foreground", 
                             "background",
                             "25_foreground",
                             "50_foreground",
                             "75_foreground",
                             "vertical",
                             "horizontal",
                             "slant_right",
                             "slant_left",
                           };

typedef struct {
  int  x1, y1, x2, y2;
  int  (*func) ();
  GC   gc;
} GBUFFER;

typedef struct {
  int          start_x, start_y, last_x, last_y;
  GC           xorgc;
  GC           gc;
  int          (*current_func)();
  int          foreground, background;
  GBUFFER      buffer[MAXOBJECTS];
  int          next_pos;
} graphics_data;

void  draw_line();
void  draw_circle();
void  draw_rectangle();
void  draw_filled_circle();
void  draw_filled_rectangle();

void  activate();
void  refresh();
void  set_stipple();
void  start_rubber_band();
void  track_rubber_band();
void  end_rubber_band();
void  set_fill_pattern();
@EOF

chmod 644 ch10/draw.h

chmod 775 ch10

echo mkdir - ch11
mkdir ch11

echo x - ch11/Makefile
cat >ch11/Makefile <<'@EOF'
CC = cc 
XSLIBDIR = ../lib
DEBUG = -g
# HP Machines
CFLAGS = $(DEBUG) -DSYSV  -I$(XSLIBDIR) 
# DEC and Sun
#CFLAGS = $(DEBUG) -I$(XSLIBDIR)

LIBS = ../lib/libXs.a -lXm -lXt -lX11

.o:.c

all: controldata monitordata xtalk memo clipboard notepad

controldata : controldata.o
	$(CC) $(CFLAGS) -o $@ $@.o $(LIBS)

monitordata : monitordata.o
	$(CC) $(CFLAGS) -o $@ $@.o $(LIBS)

xtalk : xtalk.o
	$(CC) $(CFLAGS) -o $@ $@.o $(LIBS)

memo : memo.o
	$(CC) $(CFLAGS) -o $@ $@.o $(LIBS)

clipboard : clipboard.o
	$(CC) $(CFLAGS) -o $@ $@.o $(LIBS)

notepad : notepad.o
	$(CC) $(CFLAGS) -o $@ $@.o $(LIBS)



@EOF

chmod 644 ch11/Makefile

echo x - ch11/data.h
cat >ch11/data.h <<'@EOF'
/**********************************************************************************
  *  data.h: declarations for shared data example
  *         From:
  *                   The X Window System, 
  *            Programming and Applications with Xt
  *                   OSF/Motif Edition
  *         by
  *                Douglas Young
  *              Prentice Hall, 1990
  *
  *                 Example described on pages:  285-290
  *
  *
  *  Copyright 1989 by Prentice Hall
  *  All Rights Reserved
  *
  * This code is based on the OSF/Motif widget set and the X Window System
  *
  * Permission to use, copy, modify, and distribute this software for 
  * any purpose and without fee is hereby granted, provided that the above
  * copyright notice appear in all copies and that both the copyright notice
  * and this permission notice appear in supporting documentation.
  *
  * Prentice Hall and the author disclaim all warranties with regard to 
  * this software, including all implied warranties of merchantability and fitness.
  * In no event shall Prentice Hall or the author be liable for any special,
  * indirect or cosequential damages or any damages whatsoever resulting from 
  * loss of use, data or profits, whether in an action of contract, negligence 
  * or other tortious action, arising out of or in connection with the use 
  * or performance of this software.
  *
  * Open Software Foundation is a trademark of The Open Software Foundation, Inc.
  * OSF is a trademark of Open Software Foundation, Inc.
  * OSF/Motif is a trademark of Open Software Foundation, Inc.
  * Motif is a trademark of Open Software Foundation, Inc.
  * DEC is a registered trademark of Digital Equipment Corporation
  * HP is a registered trademark of the Hewlett Packard Company
  * DIGITAL is a registered trademark of Digital Equipment Corporation
  * X Window System is a trademark of the Massachusetts Institute of Technology
  **********************************************************************************/


#include <X11/StringDefs.h>
#include <X11/Intrinsic.h>
#include <Xm/Xm.h>
#include <Xm/ScrollBar.h>
#include <Xm/RowColumn.h>
#include <Xm/Label.h>
#include "libXs.h"

/* Maximum settings */
#define MAX_SPEED 100
#define MAX_ANGLE 359
#define MAX_ALT   200
/* 
 *  Data structure to be stored in a property 
 */
typedef struct {
   int             speed;
   int             angle;
   float           altitude;
}  flight_data;
/* 
 * Atoms representing the property name and data type.
 */
Atom       FLIGHT_DATA, FLIGHT_DATA_TYPE;
@EOF

chmod 644 ch11/data.h

echo x - ch11/controldata.c
cat >ch11/controldata.c <<'@EOF'
/**********************************************************************************
 *  controldata.c: The data controller using properties
  *         From:
  *                   The X Window System, 
  *            Programming and Applications with Xt
  *                   OSF/Motif Edition
  *         by
  *                Douglas Young
  *              Prentice Hall, 1990
  *
  *                 Example described on pages:  285-290
  *
  *
  *  Copyright 1989 by Prentice Hall
  *  All Rights Reserved
  *
  * This code is based on the OSF/Motif widget set and the X Window System
  *
  * Permission to use, copy, modify, and distribute this software for 
  * any purpose and without fee is hereby granted, provided that the above
  * copyright notice appear in all copies and that both the copyright notice
  * and this permission notice appear in supporting documentation.
  *
  * Prentice Hall and the author disclaim all warranties with regard to 
  * this software, including all implied warranties of merchantability and fitness.
  * In no event shall Prentice Hall or the author be liable for any special,
  * indirect or cosequential damages or any damages whatsoever resulting from 
  * loss of use, data or profits, whether in an action of contract, negligence 
  * or other tortious action, arising out of or in connection with the use 
  * or performance of this software.
  *
  * Open Software Foundation is a trademark of The Open Software Foundation, Inc.
  * OSF is a trademark of Open Software Foundation, Inc.
  * OSF/Motif is a trademark of Open Software Foundation, Inc.
  * Motif is a trademark of Open Software Foundation, Inc.
  * DEC is a registered trademark of Digital Equipment Corporation
  * HP is a registered trademark of the Hewlett Packard Company
  * DIGITAL is a registered trademark of Digital Equipment Corporation
  * X Window System is a trademark of the Massachusetts Institute of Technology
  **********************************************************************************/

#include "data.h"

void       slider_moved();
Widget     speed_ctl, angle_ctl, temp_ctl;
Widget     create_control();
Widget     make_controller();
main(argc, argv)
     int             argc;
     char          *argv[];
{
  Widget          toplevel, row_col;
  flight_data    data;

  data.speed = data.angle = data.altitude = 0;
  toplevel = XtInitialize(argv[0], "Controldata", NULL, 0, 
                          &argc, argv);
  /*
   * Create the atoms to represent the properties 
   * used to store the data.
   */  
  create_atoms(toplevel);
  row_col = XtCreateManagedWidget("panel", 
                                  xmRowColumnWidgetClass,
                                  toplevel, NULL, 0);
  /*
   *  Make three columns, each containing a label and a 
   *  slider control to control: speed, direction, 
   *  and altitude.
   */	   
  speed_ctl = make_controller("speed",     MAX_SPEED, 
                              row_col, &data);
  angle_ctl = make_controller("direction", MAX_ANGLE, 
                              row_col, &data);
  temp_ctl  = make_controller("altitude",  MAX_ALT,  
                              row_col, &data);
  xs_create_quit_button(row_col);

  XtRealizeWidget(toplevel);
  XtMainLoop();
}

create_atoms(w)
    Widget w;
{
 Display * dpy = XtDisplay(w);
 FLIGHT_DATA      = XInternAtom(dpy, "Flight Data",      0);
 FLIGHT_DATA_TYPE = XInternAtom(dpy, "Flight Data Type", 0);
}

Widget make_controller(name, max, parent, data)
   char          *name;
   int            max;
   Widget         parent;
   flight_data  *data;   
{
 Widget rc, w;
 /*
  * Create an XmRowColumn widget to manage a single 
  * control and a label.
  */
 rc = XtCreateManagedWidget(name, xmRowColumnWidgetClass, 
                            parent, NULL, 0);
 XtCreateManagedWidget("label", xmLabelWidgetClass, 
                       rc, NULL, 0);  
 w = create_control(rc, "control", 0, max, data);
 
 return (w);
}

Widget create_control(parent, name, minimum, maximum, data)
     Widget        parent;
     char         *name;
     int           minimum, maximum;
     flight_data *data;
{
  int    n;
  Arg    wargs[2];
  Widget w;
  /*
   * Create a scroll bar with range minimum to maximum. 
   */
  n = 0;
  XtSetArg(wargs[n], XmNminimum, minimum); n++;
  XtSetArg(wargs[n], XmNmaximum, maximum); n++;
  w = XtCreateManagedWidget(name, xmScrollBarWidgetClass, 
                            parent, wargs, n);
  /*
   * Register callback function for when the user moves the
   * scrollbar slider.
   */
  XtAddCallback(w,XmNvalueChangedCallback,slider_moved,data);
  XtAddCallback(w, XmNdragCallback, slider_moved, data);
  return (w);
}

void slider_moved(w, data, call_data)
     Widget        w;
     flight_data  *data;
     XmScaleCallbackStruct *call_data;
{
  /*
   * Set the member of the flight_data corresponding to
   * the slider that invoked this callback.
   */
  if(w == angle_ctl)  
     data->angle = call_data->value;
  else if(w == speed_ctl)  
     data->speed = call_data->value;
  else if(w == temp_ctl)   
     data->altitude = (float) call_data->value / 10.0;
  /*
   * Replace the previous contents of the property
   * with the new data.
   */
  XChangeProperty(XtDisplay(w),
                  DefaultRootWindow(XtDisplay(w)), 
                  FLIGHT_DATA, FLIGHT_DATA_TYPE,
                  32, PropModeReplace,
                  (unsigned char *) data,
                  sizeof(flight_data) / 4);
}

@EOF

chmod 644 ch11/controldata.c

echo x - ch11/xtalk.c
cat >ch11/xtalk.c <<'@EOF'
/**********************************************************************************
  *  xtalk.c
  *         From:
  *                   The X Window System, 
  *            Programming and Applications with Xt
  *                   OSF/Motif Edition
  *         by
  *                Douglas Young
  *              Prentice Hall, 1990
  *
  *                 Example described on pages:  ??
  *
  *
  *  Copyright 1989 by Prentice Hall
  *  All Rights Reserved
  *
  * This code is based on the OSF/Motif widget set and the X Window System
  *
  * Permission to use, copy, modify, and distribute this software for 
  * any purpose and without fee is hereby granted, provided that the above
  * copyright notice appear in all copies and that both the copyright notice
  * and this permission notice appear in supporting documentation.
  *
  * Prentice Hall and the author disclaim all warranties with regard to 
  * this software, including all implied warranties of merchantability and fitness.
  * In no event shall Prentice Hall or the author be liable for any special,
  * indirect or cosequential damages or any damages whatsoever resulting from 
  * loss of use, data or profits, whether in an action of contract, negligence 
  * or other tortious action, arising out of or in connection with the use 
  * or performance of this software.
  *
  * Open Software Foundation is a trademark of The Open Software Foundation, Inc.
  * OSF is a trademark of Open Software Foundation, Inc.
  * OSF/Motif is a trademark of Open Software Foundation, Inc.
  * Motif is a trademark of Open Software Foundation, Inc.
  * DEC is a registered trademark of Digital Equipment Corporation
  * HP is a registered trademark of the Hewlett Packard Company
  * DIGITAL is a registered trademark of Digital Equipment Corporation
  * X Window System is a trademark of the Massachusetts Institute of Technology
  **********************************************************************************/

#include "xtalk.h"

main(argc, argv)
     int   argc;
     char *argv[];
{
  Widget toplevel, vpane, talk, listen;
  Arg    wargs[10];
  /*
   * Open display and save display and display name.
   */
  toplevel = XtInitialize(argv[0], "XTalk", NULL, 0,
                          &argc, argv);

  my_display = XtDisplay(toplevel);
  my_displayname = XDisplayName(my_display);
  /*
   * Create a pane to hold all other widgets.
   */
  vpane = XtCreateManagedWidget("panel", 
                                xmPanedWindowWidgetClass, 
                                toplevel, NULL,0);  
  create_command_panel(vpane);
  /*
   * Create the text panes used to talk.
   */
  XtSetArg(wargs[0], XmNeditMode, XmMULTI_LINE_EDIT);
  talk = XtCreateManagedWidget("talk", 
                               xmTextWidgetClass, 
                               vpane, wargs, 1);
  XtAddEventHandler(talk, KeyPressMask | 
                          ButtonPressMask | 
                          ButtonReleaseMask | 
                          PointerMotionMask, 
                   FALSE, send_to_remote, NULL); 
  XtSetArg(wargs[0], XmNeditMode, XmMULTI_LINE_EDIT);   
  listen = XtCreateManagedWidget("listen", 
                                 xmTextWidgetClass, 
                                vpane, NULL, 0); 
  XtAddEventHandler(listen, KeyPressMask, FALSE, 
                    warn_wrong_pane, NULL);    
  XtAddEventHandler(listen, NoEventMask, TRUE, 
                    client_message_handler, NULL);    
  XtRealizeWidget(toplevel);
  /*
   * Store the listen window ID in a public place.
   */
  register_talker_window(listen);
  XtMainLoop();
}

create_command_panel(parent)
   Widget parent;
{
 Widget  command, quit;  
 Arg     wargs[3];
 int     n;
 /*
  * Create a row widget to hold the command buttons.
  */
 command = XtCreateManagedWidget("command", 
                                  xmRowColumnWidgetClass, 
                                  parent, NULL, 0);

 quit = xs_create_quit_button (command);
 XtAddCallback(quit, XmNactivateCallback, quit_callback,NULL);
 /*
  * Create the buttons.
  */
 connect_button=XtCreateManagedWidget("connect",
                                      xmPushButtonWidgetClass,
                                      command, NULL, 0);
 XtAddCallback(connect_button, XmNactivateCallback,
               connect_callback, NULL);  
 XtSetArg(wargs[0], XtNsensitive, FALSE);
 disconnect_button =
   XtCreateManagedWidget("disconnect",xmPushButtonWidgetClass,
                         command, wargs, 1);
 XtAddCallback(disconnect_button, XmNactivateCallback,
               disconnect_callback, NULL);
 XtSetArg(wargs[0], XtNsensitive, FALSE);
 accept_button= XtCreateManagedWidget("accept", 
                                      xmPushButtonWidgetClass,
                                      command, wargs, 1);
 XtAddCallback(accept_button, XmNactivateCallback,
                accept_callback, NULL);  
 /* 
  * Create a text field in which the user can 
  * enter new machine names.
  */
 name_field = XtCreateManagedWidget("name", xmTextWidgetClass,
                                    command, NULL, 0);
 /*
  * Create the message area.
  */
 msg_field = XtCreateManagedWidget("messages", 
                                    xmLabelWidgetClass, 
                                    command, NULL, 0);
 xs_wprintf(msg_field, "No Current Connection");  
}

register_talker_window(w)
     Widget w;
{
 Window   window = XtWindow(w);
 Display *dpy    = XtDisplay(w);
 /*
  * Intern the atoms used for communication.
  */
 XTALK_WINDOW       = XInternAtom(dpy, XtNtalkWindow, 0);
 CONNECTION_REQUEST = XInternAtom(dpy,XtNconnectionRequest,0);
 CONNECTION_ACCEPT  = XInternAtom(dpy, XtNconnectionAccept,0);
 DISCONNECT_NOTIFY  = XInternAtom(dpy, XtNdisconnect, 0);
  /*
   * Store the listen window ID on our root window.
   */
  XChangeProperty(dpy, DefaultRootWindow(dpy),
                  XTALK_WINDOW, XA_WINDOW,
                  32, PropModeReplace,
                  &window, 1); 
} 

void connect_callback(w, client_data, call_data)
   Widget   w;
   caddr_t  client_data, call_data;
{  
  int        type, format, nitems, left, fail;
  Window    *retdata;
  Arg        wargs[2];
  char       *msg;
  Atom        REMOTE_XTALK_WINDOW;
  /*
   * Get the name of the display to connect to.
   */
  strcpy(othermachine, XmTextGetString(name_field));
  /*
   * Make sure the string isn't empty, so we don't connect
  * to ourselves.
   */
  if(strlen(othermachine) > 0){
    xs_wprintf(msg_field, "%s", "Trying To Open Connection");
    /*
     * Attempt to open the remote display.
     */
    if((remote_display = XOpenDisplay(othermachine)) == NULL){
        xs_wprintf(msg_field, "%s", "Connection Failed");
        return;
    }
    /*
     *  Get the REMOTE property containing THEIR listen ID.
     */
    REMOTE_XTALK_WINDOW  = 
          XInternAtom(remote_display, XtNtalkWindow, 0);
    if(XGetWindowProperty(remote_display, 
                          DefaultRootWindow(remote_display),
                          REMOTE_XTALK_WINDOW,		      
                          0, 4, FALSE, XA_WINDOW,
                          &type, &format, &nitems, &left,
                          &retdata) == Success &&
         type == XA_WINDOW){
      remote_talker_window = *retdata;
      /*
       *  If all went well, request a connection.
       */
      xs_wprintf(msg_field, "Waiting for a response");
      connection_accepted = FALSE;
      xs_send_message(remote_display, remote_talker_window,
                      XtNconnectionRequest, my_displayname);
     }
    /*
     *  If something went wrong, disconnect.
     */
    else
      disconnect_callback(disconnect_button, NULL, NULL);
  }
}

void client_message_handler(w, client_data, event)
     Widget          w;
     caddr_t         client_data;
     XEvent         *event;
{
  Arg wargs[10];
  if(event->type != ClientMessage) return;
  if(event->xclient.message_type == CONNECTION_REQUEST){
   /*
    * Notify the user of the incoming request and
    * enable the "accept" button.
    */
    XBell(XtDisplay(w), 0);
    strcpy(othermachine, event->xclient.data.b);
    xs_wprintf(msg_field, "Connection Request from: %s", 
	               othermachine);
    XtSetSensitive(accept_button, TRUE);
  }
  else
    if(event->xclient.message_type == CONNECTION_ACCEPT){
      /*
       * Notify the user that the connection has
       * been accepted. Enable the "disconnect" button 
       * and disable the "connect" button.
       */
      XBell(XtDisplay(w), 0);
      connection_accepted = TRUE;
      strcpy(othermachine, event->xclient.data.b);
      xs_wprintf(msg_field, "Connected to %s", othermachine);
      XtSetSensitive(connect_button, FALSE);
      XtSetSensitive(disconnect_button, TRUE);
    }
  else
    if(event->xclient.message_type == DISCONNECT_NOTIFY){
      /*
       * Close the remote display and reset 
       * all command buttons to their initial state.
       */
      XBell(XtDisplay(w), 0);
      if(remote_display)
          	XCloseDisplay(remote_display);
      remote_display = NULL;
      connection_accepted = FALSE;
      othermachine[0] = '\0';
      xs_wprintf(msg_field, "%s", "Disconnected");

      XtSetSensitive(connect_button, TRUE);
      XtSetSensitive(disconnect_button, FALSE);
    }
}

void accept_callback(w, client_data, call_data)
     Widget    w;
     caddr_t   client_data, call_data;
{  
  int      type, format, nitems, left, fail;
  Window  *retdata;
  Atom     REMOTE_XTALK_WINDOW;
  Arg      wargs[10];
  /*
   * Make sure there really is another machine.
   */
  if(strlen(othermachine) > 0 ){
   /*
    * Attempt to open the remote display.
    */
   if((remote_display = XOpenDisplay(othermachine)) == NULL){
       xs_wprintf(msg_field, "%s", "Connection Failed");
       return;
   }
   /*
    *  Get the window ID of the remote xtalk program
    */
   REMOTE_XTALK_WINDOW  = 
                XInternAtom(remote_display, XtNtalkWindow, 0);
   if(XGetWindowProperty(remote_display,
                         DefaultRootWindow(remote_display),
                         REMOTE_XTALK_WINDOW,		      
                         0, 4, FALSE, XA_WINDOW,
                         &type, &format, &nitems, &left,
                         &retdata) == Success &&
           type ==  XA_WINDOW) {
     connection_accepted = TRUE;
     remote_talker_window = *retdata;
    /*
     * Notify the remote xtalk that we accept the connection.
     */
     connection_accepted = TRUE;
     xs_send_message(remote_display, remote_talker_window,
                     XtNconnectionAccept, my_displayname);
     xs_wprintf(msg_field, "Connected to %s", othermachine);

     XtSetSensitive(accept_button, FALSE);
     XtSetSensitive(connect_button, FALSE);
     XtSetSensitive(disconnect_button, TRUE);
    }
    else
      disconnect_callback(disconnect_button, NULL, NULL);
  }
}

void send_to_remote(w, client_data, event)
   Widget     w;
   caddr_t    client_data;
   XEvent    *event;
{  
  /*
   * Make sure that we have a valid connection 
   * before sending the event.
   */
  if(remote_display && remote_talker_window && 
       connection_accepted){
    event->xany.display = remote_display;
    event->xany.window  = remote_talker_window;
    XSendEvent(remote_display, remote_talker_window, 
               TRUE, XtAllEvents, event);
    XFlush(remote_display);
  }
}

void warn_wrong_pane(w, client_data, event)
   Widget     w;
   caddr_t    client_data;
   XEvent     *event;
{  
  /*
   * Just beep if the user types into the wrong pane.
   */
  if (!event->xany.send_event)
     XBell(XtDisplay(w), 0);
}

void disconnect_callback(w, client_data, call_data)
        Widget          w;
        caddr_t         client_data, call_data;
{  
  Arg wargs[10];
  /*
   * Send a disconnect notice and close the display.
   */
  if(remote_display){
    connection_accepted = FALSE;
    xs_send_message(remote_display, remote_talker_window,
                    XtNdisconnect, my_displayname);
    XCloseDisplay(remote_display);
    xs_wprintf(msg_field, "%s", "Disconnected");
    othermachine[0] = '\0';
    remote_display = NULL;
    XtSetSensitive(connect_button, TRUE);
    XtSetSensitive(disconnect_button, FALSE);
  }
}

void quit_callback(w, client_data, call_data)
        Widget          w;
        caddr_t         client_data, call_data;
{ 
  Display *dpy = XtDisplay(w); 
  /* 
   * Inform the remote connection that we are shutting down.
   */
  if(remote_display && remote_talker_window){
    connection_accepted = FALSE;
    xs_send_message(remote_display, remote_talker_window,
                    XtNdisconnect, my_displayname);
  }
   /*
    * Clean up.
    */
   XDeleteProperty(dpy, DefaultRootWindow(dpy), XTALK_WINDOW);
}

@EOF

chmod 644 ch11/xtalk.c

echo x - ch11/monitordata.c
cat >ch11/monitordata.c <<'@EOF'
/**********************************************************************************
  *  monitordata.c: display the data set by controldata
  *         From:
  *                   The X Window System, 
  *            Programming and Applications with Xt
  *                   OSF/Motif Edition
  *         by
  *                Douglas Young
  *              Prentice Hall, 1990
  *
  *                 Example described on pages:  290-294
  *
  *
  *  Copyright 1989 by Prentice Hall
  *  All Rights Reserved
  *
  * This code is based on the OSF/Motif widget set and the X Window System
  *
  * Permission to use, copy, modify, and distribute this software for 
  * any purpose and without fee is hereby granted, provided that the above
  * copyright notice appear in all copies and that both the copyright notice
  * and this permission notice appear in supporting documentation.
  *
  * Prentice Hall and the author disclaim all warranties with regard to 
  * this software, including all implied warranties of merchantability and fitness.
  * In no event shall Prentice Hall or the author be liable for any special,
  * indirect or cosequential damages or any damages whatsoever resulting from 
  * loss of use, data or profits, whether in an action of contract, negligence 
  * or other tortious action, arising out of or in connection with the use 
  * or performance of this software.
  *
  * Open Software Foundation is a trademark of The Open Software Foundation, Inc.
  * OSF is a trademark of Open Software Foundation, Inc.
  * OSF/Motif is a trademark of Open Software Foundation, Inc.
  * Motif is a trademark of Open Software Foundation, Inc.
  * DEC is a registered trademark of Digital Equipment Corporation
  * HP is a registered trademark of the Hewlett Packard Company
  * DIGITAL is a registered trademark of Digital Equipment Corporation
  * X Window System is a trademark of the Massachusetts Institute of Technology
  **********************************************************************************/

#include "data.h"

Widget    make_display();

main(argc, argv)
        int             argc;
        char           *argv[];
{
  Widget      toplevel, rc, speed, direction,  altitude;
  Window      root;
  XEvent      event;
  /* 
   * Initialize the Intrinsics,saving the default root window.
   */
  toplevel = XtInitialize(argv[0], "Monitordata", NULL, 0, 
                          &argc, argv);
  root =  DefaultRootWindow(XtDisplay(toplevel));
  /*
   * Initialize the Atoms used for the properties.
   */
  create_atoms(toplevel);
  rc = XtCreateManagedWidget("panel", xmRowColumnWidgetClass,
                              toplevel,  NULL, 0);
  /*
   * Create the display widgets.
   */
  speed      = make_display("speed",     rc);
  direction  = make_display("direction", rc);
  altitude   = make_display("altitude",  rc);
  xs_create_quit_button(rc);

  XtRealizeWidget(toplevel);
  /*
   * Request property change event for the ROOT window.
   */
  XSelectInput(XtDisplay(toplevel), root, PropertyChangeMask);
  /*
   *  Get the initial value of the data.
   */
  update_data(speed, direction, altitude);
  /*
   * We must use our own event loop to get properties 
   * events for the ROOT window.
   */
  while(TRUE){
    XtNextEvent(&event);
    /*
     * Check for property change events on the ROOT window
     * before dispatching the event through the Intrinsics.
     */
    switch (event.type){
      case PropertyNotify:
        if(event.xproperty.window == root &&
           event.xproperty.atom == FLIGHT_DATA)
         update_data(speed, direction, altitude);
        else
         XtDispatchEvent(&event);
        break;
      default:
         XtDispatchEvent(&event);
    }
  }
}


update_data(speed, direction, altitude)
     Widget speed, direction, altitude;
{
  int            type, format, nitems, left;
  flight_data   *retdata;
  char           str[100];
  Arg            wargs[1];
  /*
   * Retrieve the data from the root window property.
   */
  if(XGetWindowProperty(XtDisplay(speed), 
                        DefaultRootWindow(XtDisplay(speed)),
                        FLIGHT_DATA, 0, sizeof(flight_data), 
                        FALSE, FLIGHT_DATA_TYPE,
                        &type, &format, &nitems, &left,
                        &retdata) == Success &&
       type ==FLIGHT_DATA_TYPE){
    /*
     * If the data exists, display it.
     */
    xs_wprintf(speed,    "%d",     retdata->speed);
    xs_wprintf(direction, "%d",    retdata->angle);
    xs_wprintf(altitude,  "%5.1f", retdata->altitude + 0.05);
    XFree(retdata);
  }
}

Widget make_display(name, parent)
   char     *name;
   Widget    parent;
{
 Widget rc, w;
 /*
  * Create an XmRowColumn widget containing two
  * XmLabelwidgets.
  */
 rc = XtCreateManagedWidget(name, xmRowColumnWidgetClass, 
                            parent, NULL, 0);
 XtCreateManagedWidget("label", xmLabelWidgetClass, 
                       rc, NULL, 0);  
 w = XtCreateManagedWidget("display", xmLabelWidgetClass, 
                           rc, NULL, 0);
 return (w);
}

create_atoms(w)
    Widget w;
{
 Display * dpy = XtDisplay(w);
 FLIGHT_DATA      = XInternAtom(dpy, "Flight Data",      0);
 FLIGHT_DATA_TYPE = XInternAtom(dpy, "Flight Data Type", 0);
}
@EOF

chmod 644 ch11/monitordata.c

echo x - ch11/xtalk.h
cat >ch11/xtalk.h <<'@EOF'
/**********************************************************************************
  *  xtalk.h: declarations used by xtalk
  *         From:
  *                   The X Window System, 
  *            Programming and Applications with Xt
  *                   OSF/Motif Edition
  *         by
  *                Douglas Young
  *              Prentice Hall, 1990
  *
  *                 Example described on pages:  ??
  *
  *
  *  Copyright 1989 by Prentice Hall
  *  All Rights Reserved
  *
  * This code is based on the OSF/Motif widget set and the X Window System
  *
  * Permission to use, copy, modify, and distribute this software for 
  * any purpose and without fee is hereby granted, provided that the above
  * copyright notice appear in all copies and that both the copyright notice
  * and this permission notice appear in supporting documentation.
  *
  * Prentice Hall and the author disclaim all warranties with regard to 
  * this software, including all implied warranties of merchantability and fitness.
  * In no event shall Prentice Hall or the author be liable for any special,
  * indirect or cosequential damages or any damages whatsoever resulting from 
  * loss of use, data or profits, whether in an action of contract, negligence 
  * or other tortious action, arising out of or in connection with the use 
  * or performance of this software.
  *
  * Open Software Foundation is a trademark of The Open Software Foundation, Inc.
  * OSF is a trademark of Open Software Foundation, Inc.
  * OSF/Motif is a trademark of Open Software Foundation, Inc.
  * Motif is a trademark of Open Software Foundation, Inc.
  * DEC is a registered trademark of Digital Equipment Corporation
  * HP is a registered trademark of the Hewlett Packard Company
  * DIGITAL is a registered trademark of Digital Equipment Corporation
  * X Window System is a trademark of the Massachusetts Institute of Technology
  **********************************************************************************/


#include <stdio.h>
#include <X11/Intrinsic.h>
#include <X11/StringDefs.h>
#include <X11/Xatom.h>
#include <Xm/Xm.h>
#include <Xm/RowColumn.h>
#include <Xm/PanedW.h>
#include <Xm/Text.h>
#include <Xm/Label.h>
#include <Xm/PushB.h>
#include "libXs.h"
/* 
 *   Atoms used for communication
 */
Atom      XTALK_WINDOW, CONNECTION_REQUEST, 
          CONNECTION_ACCEPT, DISCONNECT_NOTIFY;
Display  *remote_display = NULL;
Display  *my_display;
Window    remote_talker_window;
/* 
 *  Various widgets
 */
Widget    name_field, msg_field, 
          connect_button, disconnect_button, 
          accept_button;
char     *othermachine[100];
char     *my_displayname;
int       connection_accepted = FALSE;
/*
 *  Define the strings used to create atoms
 */
#define XtNdisconnect        "Disconnect Notify"
#define XtNconnectionAccept  "Connection Accept"
#define XtNconnectionRequest "Connection Request"
#define XtNtalkWindow        "XTalk Window"
/* 
 * Declare the callbacks used in xtalk
 */
void    client_message_handler();
void    warn_wrong_pane();
void    accept_callback();
void    connect_callback();
void    disconnect_callback();
void    send_to_remote();
void    quit_callback();
@EOF

chmod 644 ch11/xtalk.h

echo x - ch11/memo.c
cat >ch11/memo.c <<'@EOF'
/**********************************************************************************
  *  memo.c: Selection Version
  *         From:
  *                   The X Window System, 
  *            Programming and Applications with Xt
  *                   OSF/Motif Edition
  *         by
  *                Douglas Young
  *              Prentice Hall, 1990
  *
  *                 Example described on pages:  317-321
  *
  *
  *  Copyright 1989 by Prentice Hall
  *  All Rights Reserved
  *
  * This code is based on the OSF/Motif widget set and the X Window System
  *
  * Permission to use, copy, modify, and distribute this software for 
  * any purpose and without fee is hereby granted, provided that the above
  * copyright notice appear in all copies and that both the copyright notice
  * and this permission notice appear in supporting documentation.
  *
  * Prentice Hall and the author disclaim all warranties with regard to 
  * this software, including all implied warranties of merchantability and fitness.
  * In no event shall Prentice Hall or the author be liable for any special,
  * indirect or cosequential damages or any damages whatsoever resulting from 
  * loss of use, data or profits, whether in an action of contract, negligence 
  * or other tortious action, arising out of or in connection with the use 
  * or performance of this software.
  *
  * Open Software Foundation is a trademark of The Open Software Foundation, Inc.
  * OSF is a trademark of Open Software Foundation, Inc.
  * OSF/Motif is a trademark of Open Software Foundation, Inc.
  * Motif is a trademark of Open Software Foundation, Inc.
  * DEC is a registered trademark of Digital Equipment Corporation
  * HP is a registered trademark of the Hewlett Packard Company
  * DIGITAL is a registered trademark of Digital Equipment Corporation
  * X Window System is a trademark of the Massachusetts Institute of Technology
  **********************************************************************************/

#include <X11/Intrinsic.h>
#include <X11/StringDefs.h>
#include <Xm/Xm.h>
#include <Xm/PushB.h>
#include <Xm/RowColumn.h>
#include <Xm/Label.h>
#include <X11/Xatom.h>
#include "libXs.h"

void       grab_selection();
Boolean    convert_selection();
void       lose_selection();
Atom       COMPOUND_STRING;

main(argc, argv)
   int         argc;
   char       *argv[];
{
  Widget       toplevel, msg_widget, base;
  Arg          wargs[1];
  int          n;
  XmString     xmstr;
  toplevel = XtInitialize(argv[0],"Memo", NULL, 0, 
                          &argc, argv);
  COMPOUND_STRING = XInternAtom(XtDisplay(toplevel), 
                                "Compound String", FALSE);
  /*
   *  Create a manager for the quit button and message window.
   */
  base = XtCreateManagedWidget("base", xmRowColumnWidgetClass,
                                  toplevel, NULL, 0);
  xs_create_quit_button(base);
  /*
   * Get the contents of the command line and display it in
   * the message window.
   */
  n = 0;
  if((xmstr = xs_concat_words(argc - 1, &argv[1])) != NULL)
    XtSetArg(wargs[n], XmNlabelString, xmstr); n++;

  msg_widget = XtCreateManagedWidget("message", 
                                     xmLabelWidgetClass,
                                     base, wargs, n);
  XtAddEventHandler(msg_widget, ButtonPressMask,
                    FALSE, grab_selection, NULL);
  /*
   * Realize all widgets and enter the event loop.
   */
  XtRealizeWidget(toplevel);
  XtMainLoop();
}

void grab_selection(w, client_data, event)
     Widget    w;
     caddr_t   client_data;
     XEvent   *event;
{
  /*
   * Claim ownership of the PRIMARY selection.
   */
  if(XtOwnSelection(w, XA_PRIMARY, 
                    event->xbutton.time, 
                    convert_selection,  /* handle requests */
                    lose_selection,     /* Give up selection*/
                    NULL)){
    xs_invert_widget(w);
    XtSetSensitive(w, FALSE);
  }
}

static Boolean convert_selection(w, selection, target,
                                 type, value, length, format)
    Widget         w;
    Atom          *selection, *target, *type;
    caddr_t       *value;
    unsigned long *length;
    int           *format;
{
   Arg wargs[10];

  if (*target == COMPOUND_STRING) {
    XmString xmstr;
    XtSetArg(wargs[0], XmNlabelString, &xmstr);
    XtGetValues(w, wargs, 1);
    *type   = COMPOUND_STRING;
    *value  = xmstr;
    *length = XmStringLength(xmstr);
    *format = 8;
    return TRUE;
  }
 else if (*target == XA_STRING) {
    char     *str;
    XmString  xmstr;

    XtSetArg(wargs[0], XmNlabelString, &xmstr);
    XtGetValues(w, wargs, 1);

    *type   = XA_STRING;
    *value  = xs_get_string_from_xmstring (xmstr);
    *length = strlen(*value);
    *format = 8;
    return TRUE;
  }
   else
     return FALSE;
}


static void lose_selection(w, selection)
  Widget   w;
  Atom    *selection;
{
  xs_invert_widget(w);
  XtSetSensitive(w, TRUE);
}


@EOF

chmod 644 ch11/memo.c

echo x - ch11/clipboard.c
cat >ch11/clipboard.c <<'@EOF'
/**********************************************************************************
  * clipboard.c: A simple clipboard using X selections
  *         From:
  *                   The X Window System, 
  *            Programming and Applications with Xt
  *                   OSF/Motif Edition
  *         by
  *                Douglas Young
  *              Prentice Hall, 1990
  *
  *                 Example described on pages:  321-325
  *
  *
  *  Copyright 1989 by Prentice Hall
  *  All Rights Reserved
  *
  * This code is based on the OSF/Motif widget set and the X Window System
  *
  * Permission to use, copy, modify, and distribute this software for 
  * any purpose and without fee is hereby granted, provided that the above
  * copyright notice appear in all copies and that both the copyright notice
  * and this permission notice appear in supporting documentation.
  *
  * Prentice Hall and the author disclaim all warranties with regard to 
  * this software, including all implied warranties of merchantability and fitness.
  * In no event shall Prentice Hall or the author be liable for any special,
  * indirect or cosequential damages or any damages whatsoever resulting from 
  * loss of use, data or profits, whether in an action of contract, negligence 
  * or other tortious action, arising out of or in connection with the use 
  * or performance of this software.
  *
  * Open Software Foundation is a trademark of The Open Software Foundation, Inc.
  * OSF is a trademark of Open Software Foundation, Inc.
  * OSF/Motif is a trademark of Open Software Foundation, Inc.
  * Motif is a trademark of Open Software Foundation, Inc.
  * DEC is a registered trademark of Digital Equipment Corporation
  * HP is a registered trademark of the Hewlett Packard Company
  * DIGITAL is a registered trademark of Digital Equipment Corporation
  * X Window System is a trademark of the Massachusetts Institute of Technology
  **********************************************************************************/

#include <X11/Intrinsic.h>
#include <X11/StringDefs.h>
#include <Xm/Xm.h>
#include <Xm/PushB.h>
#include <Xm/ToggleB.h>
#include <Xm/RowColumn.h>
#include <Xm/Label.h>
#include <X11/Xatom.h>
#include "libXs.h"

void      grab_selection();
void      request_selection();
Boolean   convert_selection();
void      lose_selection();
void      show_selection();
void      toggle_type();
Atom      COMPOUND_STRING;
Atom      current_type = XA_STRING;

main(argc, argv)
    int             argc;
    char           *argv[];
{
  Widget   toplevel, selection, request, row_col, toggle;

  toplevel = XtInitialize(argv[0], "Clipboard", NULL, 
                          0, &argc, argv);
  COMPOUND_STRING = XInternAtom(XtDisplay(toplevel), 
                                "Compound String", FALSE);

  row_col = XtCreateManagedWidget("commands",
                                  xmRowColumnWidgetClass,
                                  toplevel, NULL, 0);
  xs_create_quit_button(row_col); 
  /*
   * Create a button used to request the selection and
   * a text widget to display it.
   */
  request = XtCreateManagedWidget("getselection", 
                                  xmPushButtonWidgetClass,
                                  row_col, NULL, 0); 
  toggle = XtCreateManagedWidget("type", 
                                 xmToggleButtonWidgetClass,
                                 row_col, NULL, 0); 
  xs_wprintf(toggle, "Type: Character String");

  selection = XtCreateManagedWidget("currentselection", 
                                    xmLabelWidgetClass,
                                    row_col, NULL, 0);

  XtAddCallback(toggle, XmNvalueChangedCallback, 
                toggle_type, NULL);
#ifdef JUST_LIKE_BOOK
  XtAddEventHandler(request, ButtonPress, FALSE,
                    request_selection, selection);
  XtAddEventHandler(selection, ButtonPress, FALSE,
                    grab_selection, NULL);
#else
  XtAddCallback(request, XmNactivateCallback,
                    request_selection, selection);
  XtAddEventHandler(selection, ButtonPressMask, FALSE,
                    grab_selection, NULL);
#endif

  
  XtRealizeWidget(toplevel);
  XtMainLoop();
}

void request_selection(w, client_data, call_data)
     Widget          w;
     caddr_t         client_data;
     XmAnyCallbackStruct *call_data;

{
  XtGetSelectionValue(w, XA_PRIMARY, current_type,
                      show_selection, client_data, 
                      call_data->event->xbutton.time);
}

static void show_selection(w, client_data, selection, type,
                           value, length, format)
    Widget         w;
    caddr_t        client_data;
    Atom          *selection, *type;
    caddr_t        value;
    unsigned long *length;
    int           *format;
{
  Arg wargs[2];
  if (*type == COMPOUND_STRING){
     XtSetArg(wargs[0], XmNlabelString, value);
     XtSetValues(client_data, wargs, 1);
  }
  else if (*type == XA_STRING){
     xs_wprintf(client_data, "%s", value);
  }
}

void toggle_type (w, client_data, call_data)
     Widget          w;
     void           *client_data;
     XmToggleButtonCallbackStruct *call_data;
{
   if(call_data->set){
     current_type = COMPOUND_STRING;
     xs_wprintf(w, "Type: Compound String");
   }
   else{
    current_type = XA_STRING;
    xs_wprintf(w, "Type: Character String");
  }
}

void grab_selection(w, client_data, event)
     Widget    w;
     void     *client_data;
     XEvent   *event;
{
  /*
   * Claim ownership of the PRIMARY selection.
   */
  if(XtOwnSelection(w, XA_PRIMARY, 
                    event->xbutton.time, 
                    convert_selection,  /* handle requests */
                    lose_selection,     /* Give up selection*/
                    NULL)){
    xs_invert_widget(w);
    XtSetSensitive(w, FALSE);
  }
}

static Boolean convert_selection(w, selection, target,
                                 type, value, length, format)
    Widget         w;
    Atom          *selection, *target, *type;
    caddr_t       *value;
    unsigned long *length;
    int           *format;
{
   Arg wargs[10];

  if (*target == COMPOUND_STRING) {
    XmString xmstr;
    XtSetArg(wargs[0], XmNlabelString, &xmstr);
    XtGetValues(w, wargs, 1);
    *type   = COMPOUND_STRING;
    *value  = xmstr;
    *length = XmStringLength(xmstr);
    *format = 8;
    return TRUE;
  }
 else if (*target == XA_STRING) {
    char     *str;
    XmString  xmstr;

    XtSetArg(wargs[0], XmNlabelString, &xmstr);
    XtGetValues(w, wargs, 1);

    *type   = XA_STRING;
    *value  = xs_get_string_from_xmstring (xmstr);
    *length = strlen(*value);
    *format = 8;
    return TRUE;
  }
   else
     return FALSE;
}

static void lose_selection(w, selection)
  Widget   w;
  Atom    *selection;
{
  xs_invert_widget(w);
  XtSetSensitive(w, TRUE);
}
@EOF

chmod 644 ch11/clipboard.c

echo x - ch11/notepad.c
cat >ch11/notepad.c <<'@EOF'
/**********************************************************************************
  * notepad.c: Copy text to and from the clipboard
  *         From:
  *                   The X Window System, 
  *            Programming and Applications with Xt
  *                   OSF/Motif Edition
  *         by
  *                Douglas Young
  *              Prentice Hall, 1990
  *
  *                 Example described on pages:  328-332
  *
  *
  *  Copyright 1989 by Prentice Hall
  *  All Rights Reserved
  *
  * This code is based on the OSF/Motif widget set and the X Window System
  *
  * Permission to use, copy, modify, and distribute this software for 
  * any purpose and without fee is hereby granted, provided that the above
  * copyright notice appear in all copies and that both the copyright notice
  * and this permission notice appear in supporting documentation.
  *
  * Prentice Hall and the author disclaim all warranties with regard to 
  * this software, including all implied warranties of merchantability and fitness.
  * In no event shall Prentice Hall or the author be liable for any special,
  * indirect or cosequential damages or any damages whatsoever resulting from 
  * loss of use, data or profits, whether in an action of contract, negligence 
  * or other tortious action, arising out of or in connection with the use 
  * or performance of this software.
  *
  * Open Software Foundation is a trademark of The Open Software Foundation, Inc.
  * OSF is a trademark of Open Software Foundation, Inc.
  * OSF/Motif is a trademark of Open Software Foundation, Inc.
  * Motif is a trademark of Open Software Foundation, Inc.
  * DEC is a registered trademark of Digital Equipment Corporation
  * HP is a registered trademark of the Hewlett Packard Company
  * DIGITAL is a registered trademark of Digital Equipment Corporation
  * X Window System is a trademark of the Massachusetts Institute of Technology
  **********************************************************************************/


#include <stdio.h>
#include <X11/StringDefs.h>
#include <X11/Intrinsic.h>
#include <Xm/Xm.h> 
#include <Xm/RowColumn.h>
#include <Xm/PanedW.h>
#include <Xm/Text.h> 
#include <Xm/PushB.h>
#include <Xm/CutPaste.h> 

extern void copy_to_clipboard (); 
extern void copy_from_clipboard (); 

main (argc, argv) 
   int    argc; 
   char  *argv[]; 
{ 
  Widget toplevel, base, commands, text, copy, get; 
  Arg    wargs[10]; 
  /* 
   * Initialize the Intrinsic and create a paned window 
   * widget as the base of the application. 
   */ 
  toplevel = XtInitialize (argv[0], "Notepad", NULL, 0,
                           &argc, argv); 
  base = XtCreateManagedWidget("base",
                               xmPanedWindowWidgetClass, 
                               toplevel, NULL, 0); 
  /* 
   * Make a row of command buttons. 
   */ 
  commands = XtCreateManagedWidget("commands",
                                   xmRowColumnWidgetClass, 
                                   base, NULL, 0); 
  copy = XtCreateManagedWidget("copy",
                               xmPushButtonWidgetClass, 
                               commands, wargs, 0); 
  get = XtCreateManagedWidget("retrieve",
                              xmPushButtonWidgetClass, 
                              commands, wargs, 0); 
  xs_create_quit_button(commands); 
 /* 
  * Create a multi-line text edit pane to hold notes 
  */ 
  XtSetArg(wargs[0], XmNeditMode, XmMULTI_LINE_EDIT); 
  text = XtCreateManagedWidget("text", xmTextWidgetClass, 
                               base, wargs, 1); 
  XtAddCallback (copy, XmNactivateCallback,
  copy_to_clipboard,  text); 
  XtAddCallback (get, XmNactivateCallback,
  copy_from_clipboard, text); 
  XtRealizeWidget(toplevel); 
  XtMainLoop(); 
} 

void copy_to_clipboard (w, text_w, call_data)
     Widget   w;
     Widget   text_w;
     XmAnyCallbackStruct *call_data;
{
   char    *selection = NULL;
   int     result;
   long    itemid, dataid;
   XButtonEvent *event = (XButtonEvent *) call_data->event;

 if ((selection = XmTextGetSelection (text_w)) != NULL) {
  /*
   * Begin the copy. If the clipboard is locked, 
   * keep trying.
   */
   while ((result = 
           XmClipboardStartCopy (XtDisplay(w), 
                                 XtWindow(text_w),
                                 "Notepad", 
                                 event->time,
                                 text_w, NULL, 
                                &itemid)) != ClipboardSuccess)
      ;
   /*
    * Copy the data.
    */
   while ((result =  
               XmClipboardCopy (XtDisplay(w),  
                                XtWindow(text_w), itemid,
                                XtRString, selection,
                                strlen(selection), 0,
                                &dataid)) != ClipboardSuccess)
      ;
   /*
    * End the transaction.
    */
   while ((result = 
              XmClipboardEndCopy(XtDisplay(w),
                                 XtWindow(text_w),
                                 itemid)) != ClipboardSuccess)
       ;
    }
}

void copy_from_clipboard (w, text_w, call_data) 
      Widget  w; 
      Widget  text_w; 
      caddr_t call_data;
 { 
    char buffer[BUFSIZ]; 
    int  length, id, result; 
    int  done = FALSE; 
    /* 
     * Retrieve the current contents of the clipboard. 
     */ 
    while (!done){ 
      result =  XmClipboardRetrieve (XtDisplay(w),
                                     XtWindow(text_w), 
                                     XtRString, buffer,
                                     BUFSIZ, &length, &id);
    /* 
     * Check the type. If the clipboard is locked, try
     * again. If data is retrieved successfully, append it 
     * to the text buffer. Otherwise abort. 
     */ 
    switch(result){ 
        case ClipboardSuccess: 
          buffer[length] = '\0'; 
          xs_insert_string(text_w, buffer); 
          done = TRUE; 
          break; 
        case   ClipboardTruncate: 
          XtWarning("Insufficient space for clipboard data"); 
          done = TRUE; 
        case   ClipboardNoData: 
          done = TRUE; 
          break; 
        case   ClipboardLocked: 
          break; 
     } 
   }
}
@EOF

chmod 664 ch11/notepad.c

chmod 775 ch11

echo mkdir - ch12
mkdir ch12

echo x - ch12/Dial.h
cat >ch12/Dial.h <<'@EOF'
/**********************************************************************************
  * Dial.h: Public header file for Dial Widget Class
  *         From:
  *                   The X Window System, 
  *            Programming and Applications with Xt
  *                   OSF/Motif Edition
  *         by
  *                Douglas Young
  *              Prentice Hall, 1990
  *
  *                 Example described on pages:  344-362
  *
  *
  *  Copyright 1989 by Prentice Hall
  *  All Rights Reserved
  *
  * This code is based on the OSF/Motif widget set and the X Window System
  *
  * Permission to use, copy, modify, and distribute this software for 
  * any purpose and without fee is hereby granted, provided that the above
  * copyright notice appear in all copies and that both the copyright notice
  * and this permission notice appear in supporting documentation.
  *
  * Prentice Hall and the author disclaim all warranties with regard to 
  * this software, including all implied warranties of merchantability and fitness.
  * In no event shall Prentice Hall or the author be liable for any special,
  * indirect or cosequential damages or any damages whatsoever resulting from 
  * loss of use, data or profits, whether in an action of contract, negligence 
  * or other tortious action, arising out of or in connection with the use 
  * or performance of this software.
  *
  * Open Software Foundation is a trademark of The Open Software Foundation, Inc.
  * OSF is a trademark of Open Software Foundation, Inc.
  * OSF/Motif is a trademark of Open Software Foundation, Inc.
  * Motif is a trademark of Open Software Foundation, Inc.
  * DEC is a registered trademark of Digital Equipment Corporation
  * HP is a registered trademark of the Hewlett Packard Company
  * DIGITAL is a registered trademark of Digital Equipment Corporation
  * X Window System is a trademark of the Massachusetts Institute of Technology
  **********************************************************************************/

#ifndef  DIAL_H
#define  DIAL_H

extern WidgetClass XsdialWidgetClass;
typedef struct _XsDialClassRec * XsDialWidgetClass;
typedef struct _XsDialRec      * XsDialWidget;
/*
 * Define resource strings for the Dial widget.
 */
#define XtNselectCallback "selectCallback"
#define XtNmarkers        "markers"
#define XtNminimum        "minimum"
#define XtNmaximum        "maximum"
#define XtNindicatorColor "indicatorColor"
#define XtNposition       "position"
#define XtNmarkerLength   "markerLength"

#define XtCMarkers        "Markers"
#define XtCMin            "Min"
#define XtCMax            "Max"
#define Xs_SELEC	TED       1

typedef struct {
  int     reason;
  XEvent *event;
  int     position;
}  xsdialCallbackStruct;

#define Xs_SELECTED  1

#endif DIAL_H
@EOF

chmod 644 ch12/Dial.h

echo x - ch12/DialP.h
cat >ch12/DialP.h <<'@EOF'
/**********************************************************************************
 * DialP.h: Private header file for Dial Widget Class
  *         From:
  *                   The X Window System, 
  *            Programming and Applications with Xt
  *                   OSF/Motif Edition
  *         by
  *                Douglas Young
  *              Prentice Hall, 1990
  *
  *                 Example described on pages:  344-362
  *
  *
  *  Copyright 1989 by Prentice Hall
  *  All Rights Reserved
  *
  * This code is based on the OSF/Motif widget set and the X Window System
  *
  * Permission to use, copy, modify, and distribute this software for 
  * any purpose and without fee is hereby granted, provided that the above
  * copyright notice appear in all copies and that both the copyright notice
  * and this permission notice appear in supporting documentation.
  *
  * Prentice Hall and the author disclaim all warranties with regard to 
  * this software, including all implied warranties of merchantability and fitness.
  * In no event shall Prentice Hall or the author be liable for any special,
  * indirect or cosequential damages or any damages whatsoever resulting from 
  * loss of use, data or profits, whether in an action of contract, negligence 
  * or other tortious action, arising out of or in connection with the use 
  * or performance of this software.
  *
  * Open Software Foundation is a trademark of The Open Software Foundation, Inc.
  * OSF is a trademark of Open Software Foundation, Inc.
  * OSF/Motif is a trademark of Open Software Foundation, Inc.
  * Motif is a trademark of Open Software Foundation, Inc.
  * DEC is a registered trademark of Digital Equipment Corporation
  * HP is a registered trademark of the Hewlett Packard Company
  * DIGITAL is a registered trademark of Digital Equipment Corporation
  * X Window System is a trademark of the Massachusetts Institute of Technology
  **********************************************************************************/



#ifndef DIALP_H
#define DIALP_H

#define MAXSEGMENTS 200

typedef struct _XsDialClassPart{
       int ignore;
} XsDialClassPart;

typedef struct _XsDialClassRec{
   CoreClassPart    core_class;
   XsDialClassPart  dial_class;
} XsDialClassRec;

extern XsDialClassRec XsdialClassRec;


typedef struct _XsDialPart {
   Pixel     indicator_color;  /* Color of the           */
   Pixel     foreground;       /*  indicator and markers */
   int       minimum;          /* minimum value          */
   int       maximum;          /* maximum value          */
   int       markers;          /* number of marks        */
   Dimension marker_length;    /* in pixels              */
   Position  position;         /* indicator position     */
   Position  indicator_x;      /* x,y position of tip    */
   Position  indicator_y;      /*     of the indicator   */
   Position  center_x;         /* coordinates of the     */
   Position  center_y;         /*     dial center        */
   Position  inner_diam;       /* inside of markers      */
   Position  outer_diam;       /* outside of markers     */  
   GC        dial_GC;          /* assorted gc's          */
   GC        indicator_GC;
   GC        inverse_GC;
   XPoint    segments[MAXSEGMENTS];
   XtCallbackList select;    /* callback list          */
} XsDialPart;

typedef struct _XsDialRec {
   CorePart          core;
   XsDialPart        dial;
} XsDialRec;

#endif DIALP_H
@EOF

chmod 644 ch12/DialP.h

echo x - ch12/Dial.c
cat >ch12/Dial.c <<'@EOF'
/**********************************************************************************
 * Dial.c: The Dial Widget
  *         From:
  *                   The X Window System, 
  *            Programming and Applications with Xt
  *                   OSF/Motif Edition
  *         by
  *                Douglas Young
  *              Prentice Hall, 1990
  *
  *                 Example described on pages:  344-362
  *
  *
  *  Copyright 1989 by Prentice Hall
  *  All Rights Reserved
  *
  * This code is based on the OSF/Motif widget set and the X Window System
  *
  * Permission to use, copy, modify, and distribute this software for 
  * any purpose and without fee is hereby granted, provided that the above
  * copyright notice appear in all copies and that both the copyright notice
  * and this permission notice appear in supporting documentation.
  *
  * Prentice Hall and the author disclaim all warranties with regard to 
  * this software, including all implied warranties of merchantability and fitness.
  * In no event shall Prentice Hall or the author be liable for any special,
  * indirect or cosequential damages or any damages whatsoever resulting from 
  * loss of use, data or profits, whether in an action of contract, negligence 
  * or other tortious action, arising out of or in connection with the use 
  * or performance of this software.
  *
  * Open Software Foundation is a trademark of The Open Software Foundation, Inc.
  * OSF is a trademark of Open Software Foundation, Inc.
  * OSF/Motif is a trademark of Open Software Foundation, Inc.
  * Motif is a trademark of Open Software Foundation, Inc.
  * DEC is a registered trademark of Digital Equipment Corporation
  * HP is a registered trademark of the Hewlett Packard Company
  * DIGITAL is a registered trademark of Digital Equipment Corporation
  * X Window System is a trademark of the Massachusetts Institute of Technology
  **********************************************************************************/


#include <stdio.h>
#include <math.h>
#include <X11/IntrinsicP.h>
#include <X11/Intrinsic.h>
#include <X11/StringDefs.h>
#include <X11/CoreP.h>
#include "DialP.h"
#include "Dial.h"

#define  RADIANS(x)  (M_PI * 2.0 * (x) / 360.0)
#define  DEGREES(x)  ((x) / (M_PI * 2.0) * 360.0)
#define  MIN_ANGLE   225.0
#define  MAX_ANGLE   270.0
#define  MIN(a,b)    (((a) < (b)) ? (a) :  (b))

static void    select_dial ();
static void    Initialize();
static void    Redisplay();
static void    Resize();
static void    Destroy();
static Boolean SetValues();

static char defaultTranslations[] = "<Btn1Down>: select()";

static XtActionsRec actionsList[] = {
  { "select",   (XtActionProc) select_dial},
};

static XtResource resources[] = {
  {XtNmarkers, XtCMarkers, XtRInt, sizeof (int),
    XtOffset(XsDialWidget, dial.markers), XtRString, "10"  },
  {XtNminimum, XtCMin, XtRInt, sizeof (int),
    XtOffset(XsDialWidget, dial.minimum), XtRString, "0"   },
  {XtNmaximum, XtCMax, XtRInt, sizeof (int),
    XtOffset(XsDialWidget, dial.maximum), XtRString, "100" },
  {XtNindicatorColor, XtCColor, XtRPixel, sizeof (Pixel),
    XtOffset(XsDialWidget, dial.indicator_color), 
    XtRString, "Black"                                     },
  {XtNposition, XtCPosition, XtRPosition, sizeof (Position),
    XtOffset(XsDialWidget, dial.position), XtRString, "0"  },
  {XtNmarkerLength,XtCLength,XtRDimension,sizeof (Dimension),
    XtOffset(XsDialWidget, dial.marker_length),
    XtRString, "5"                                         },
  {XtNforeground, XtCForeground, XtRPixel, sizeof (Pixel),
    XtOffset(XsDialWidget, dial.foreground), 
    XtRString, "Black"                                     },
  {XtNselectCallback,XtCCallback,XtRCallback,sizeof(caddr_t),
    XtOffset (XsDialWidget, dial.select), 
    XtRCallback, NULL                                      },
 };

XsDialClassRec  XsdialClassRec = {
     /* CoreClassPart */
  {
   (WidgetClass) &widgetClassRec,  /* superclass            */
   "Dial",                         /* class_name            */
   sizeof(XsDialRec),              /* widget_size           */
   NULL,                           /* class_initialize      */
   NULL,                           /* class_part_initialize */
   FALSE,                          /* class_inited          */
   Initialize,                     /* initialize            */
   NULL,                           /* initialize_hook       */
   XtInheritRealize,               /* realize               */
   actionsList,                    /* actions               */
   XtNumber(actionsList),          /* num_actions           */
   resources,                      /* resources             */
   XtNumber(resources),            /* num_resources         */
   NULLQUARK,                      /* xrm_class             */
   TRUE,                           /* compress_motion       */
   TRUE,                           /* compress_exposure     */
   TRUE,                           /* compress_enterleave   */
   TRUE,                           /* visible_interest      */
   Destroy,                        /* destroy               */
   Resize,                         /* resize                */
   Redisplay,                      /* expose                */
   SetValues,                      /* set_values            */
   NULL,                           /* set_values_hook       */
   XtInheritSetValuesAlmost,       /* set_values_almost     */
   NULL,                           /* get_values_hook       */
   NULL,                           /* accept_focus          */
   XtVersion,                      /* version               */
   NULL,                           /* callback private      */
   defaultTranslations,            /* tm_table              */
   NULL,                           /* query_geometry        */
   NULL,                           /* display_accelerator   */
   NULL,                           /* extension             */
   },
      /* Dial class fields */
  {
   0,                              /* ignore                */
   }
};

WidgetClass XsdialWidgetClass = (WidgetClass) &XsdialClassRec;

static void Initialize (request, new)
    XsDialWidget request, new;
{
  XGCValues values;
  XtGCMask  valueMask;
  /*
   * Make sure the window size is not zero. The Core 
   * Initialize() method doesn't do this.
   */
  if (request->core.width == 0)
    new->core.width = 100;
  if (request->core.height == 0)
    new->core.height = 100;
  /*
   * Make sure the min and max dial settings are valid.
   */
  if (new->dial.minimum >= new->dial.maximum) {
    XtWarning ("Maximum must be greater than the Minimum");
    new->dial.minimum = new->dial.maximum - 1;
  }
  if (new->dial.position > new->dial.maximum) {
    XtWarning ("Position exceeds the Dial Maximum");
    new->dial.position =  new->dial.maximum;
  }
  if (new->dial.position < new->dial.minimum) {
    XtWarning ("Position is less than the Minimum");
    new->dial.position =  new->dial.minimum;
  }
  /*
   * Allow only MAXSEGMENTS / 2 markers
   */
  if(new->dial.markers > MAXSEGMENTS / 2){
    XtWarning ("Too many markers");
    new->dial.markers = MAXSEGMENTS / 2;
  }
  /*
   * Create the graphics contexts used for the dial face 
   * and the indicator.
   */
  valueMask = GCForeground | GCBackground;
  values.foreground = new->dial.foreground;
  values.background = new->core.background_pixel;
  new->dial.dial_GC = XtGetGC (new, valueMask, &values);  

  values.foreground = new->dial.indicator_color;
  new->dial.indicator_GC = XtGetGC (new, valueMask,&values);  

  valueMask = GCForeground | GCBackground;
  values.foreground = new->core.background_pixel;
  values.background = new->dial.indicator_color;
  new->dial.inverse_GC = XtGetGC (new, valueMask, &values);   

  Resize (new);
}

static void Destroy (w)
     XsDialWidget w;
{
  XtReleaseGC (w, w->dial.indicator_GC);
  XtReleaseGC (w, w->dial.inverse_GC);
  XtReleaseGC (w, w->dial.dial_GC);
  XtRemoveAllCallbacks (w, XtNselectCallback, w -> dial.select);
}

static void Resize (w)
    XsDialWidget w;
{
  double    angle, cosine, sine, increment;
  int       i; 
  XPoint   *ptr;
  /*
   * Get the address of the first line segment.
   */
  ptr = w->dial.segments;
  /*
   * calculate the center of the widget
   */
  w->dial.center_x = w->core.width/2; 
  w->dial.center_y = w->core.height/2;   
  /* 
   *  Generate the segment array containing the    
   *  face of the dial.    
   */ 
  increment = RADIANS(MAX_ANGLE) /(float)(w->dial.markers -1);
  w->dial.outer_diam = MIN(w->core.width, w->core.height) / 2;
  w->dial.inner_diam=w->dial.outer_diam-w->dial.marker_length;
  angle = RADIANS(MIN_ANGLE);  

  for (i = 0; i < w->dial.markers;i++){   
    cosine = cos(angle);   
    sine   = sin(angle); 
    ptr->x   = w->dial.center_x + w->dial.outer_diam * sine; 
    ptr++->y = w->dial.center_y - w->dial.outer_diam * cosine;
    ptr->x   = w->dial.center_x + w->dial.inner_diam * sine; 
    ptr++->y = w->dial.center_y - w->dial.inner_diam * cosine;
    angle += increment; 
  }  
 calculate_indicator_pos(w); 
} 

static calculate_indicator_pos(w)
     XsDialWidget w;
{
  double   normalized_pos, angle;
  Position indicator_length;
  /*
   * Make the indicator two pixels shorter than the  
   * inner edge of the markers.
   */
  indicator_length=w->dial.outer_diam-w->dial.marker_length-2;
  /*
   * Normalize the indicator position to lie between zero
   * and 1, and then convert it to an angle.
   */
  normalized_pos = (w->dial.position - w->dial.minimum)/
                 (float)(w->dial.maximum - w->dial.minimum);
  angle = RADIANS(MIN_ANGLE + MAX_ANGLE  * normalized_pos);  
   /*
    * Find the x,y coordinates of the tip of the indicator.   
    */ 
   w->dial.indicator_x = w->dial.center_x + 
                               indicator_length * sin(angle); 
   w->dial.indicator_y = w->dial.center_y - 
                               indicator_length  * cos(angle);
} 

static void Redisplay (w, event, region)
     XsDialWidget  w;
     XEvent       *event;
     Region        region;
{
  if(w->core.visible){
    /*
     * Draw the markers used for the dial face.
     */
    XDrawSegments(XtDisplay(w), XtWindow(w),
                 w->dial.dial_GC, 
                 w->dial.segments,
                 w->dial.markers);
    /*
     * Draw the indicator at its current position.
     */
    XDrawLine(XtDisplay(w), XtWindow(w),
              w->dial.indicator_GC, 
              w->dial.center_x, 
              w->dial.center_y,   
              w->dial.indicator_x,  
              w->dial.indicator_y);   
    }
 } 

static Boolean SetValues (current, request, new)
     XsDialWidget current, request, new;
{
  XGCValues  values;
  XtGCMask   valueMask;
  Boolean    redraw = FALSE;
  Boolean    redraw_indicator = FALSE;
  /*
   * Make sure the new dial values are reasonable.
   */
  if (new->dial.minimum >= new->dial.maximum) {
    XtWarning ("Minimum must be less than Maximum");
    new->dial.minimum = 0;
    new->dial.maximum = 100;
  }
  if (new->dial.position > new->dial.maximum) {
    XtWarning("Dial position is greater than the Maximum");
    new->dial.position = new->dial.maximum;
  }
  if (new->dial.position < new->dial.minimum) {
    XtWarning("Dial position is less than the Minimum");
    new->dial.position = new->dial.minimum;
  }
  /*
   * If the indicator color or background color 
   * has changed, generate the GC's.
   */
 if(new->dial.indicator_color!=current->dial.indicator_color||
  new->core.background_pixel !=current->core.background_pixel){
    valueMask = GCForeground | GCBackground;
    values.foreground = new->dial.indicator_color;
    values.background = new->core.background_pixel;
    XtReleaseGC(new, new->dial.indicator_GC);
    new->dial.indicator_GC = XtGetGC(new, valueMask,&values);
    values.foreground = new->core.background_pixel;
    values.background = new->dial.indicator_color;
    XtReleaseGC(new, new->dial.inverse_GC);
    new->dial.inverse_GC = XtGetGC(new, valueMask, &values);
    redraw_indicator = TRUE;     
  }
  /*
   * If the marker color has changed, generate the GC.
   */
  if (new->dial.foreground != current->dial.foreground){
    valueMask = GCForeground | GCBackground;
    values.foreground = new->dial.foreground;
    values.background = new->core.background_pixel;
    XtReleaseGC(new, new->dial.dial_GC);
    new->dial.dial_GC = XtGetGC (new, valueMask, &values);   
    redraw = TRUE;     
  }
  /*
   * If the indicator position has changed, or if the min/max
   * values have changed, recompute the indicator coordinates.
   */
  if (new->dial.position != current->dial.position ||
      new->dial.minimum != current->dial.minimum ||
      new->dial.maximum != current->dial.maximum){
    calculate_indicator_pos(new);
    redraw_indicator = TRUE;
  }
  /*
   * If only the indicator needs to be redrawn and
   * the widget is realized, erase the current indicator
   * and draw the new one.
   */
  if(redraw_indicator && ! redraw &&
     XtIsRealized(new) && new->core.visible){
    XDrawLine(XtDisplay(current), XtWindow(current),
              current->dial.inverse_GC, 
              current->dial.center_x, 
              current->dial.center_y,
             current->dial.indicator_x, 
              current->dial.indicator_y);    
    XDrawLine(XtDisplay(new), XtWindow(new),  
              new->dial.indicator_GC,  
              new->dial.center_x, 
              new->dial.center_y,
              new->dial.indicator_x,
              new->dial.indicator_y); 
      } 
  return (redraw); 
} 

static void select_dial (w, event, args, n_args)
     XsDialWidget   w;
     XEvent        *event;
     char          *args[];
     int            n_args;
{
  Position   pos;
  double     angle;
  xsdialCallbackStruct cb;
  
  pos = w->dial.position;
  if(event->type == ButtonPress || 
         event->type == MotionNotify){
    /* 
     * Get the angle in radians.
     */
   angle=atan2((double)(event->xbutton.y - w->dial.center_y),
               (double)(event->xbutton.x - w->dial.center_x));
   /*
    * Convert to degrees from the MIN_ANGLE.
    */ 
   angle = DEGREES(angle) - (MIN_ANGLE - 90.0); 
   if (angle < 0)
     angle = 360.0 + angle;
   /*  
    * Convert the angle to a position. 
    */ 
   pos = w->dial.minimum + (angle / 
             MAX_ANGLE * (w->dial.maximum - w->dial.minimum));
 }  
 /*
   * Invoke the callback, report the position in the call_data
   * structure
   */  
  cb.reason   = Xs_SELECTED;
  cb.event    = event;
  cb.position = pos;
  XtCallCallbacks (w, XtNselectCallback, &cb); 
} 

@EOF

chmod 644 ch12/Dial.c

echo x - ch12/Makefile
cat >ch12/Makefile <<'@EOF'
CC = cc 
XSLIBDIR = ../lib
DEBUG = -g
# HP Machines
CFLAGS = $(DEBUG) -DSYSV  -I$(XSLIBDIR) 
# DEC and Sun
#CFLAGS = $(DEBUG) -I$(XSLIBDIR)

LIBS = ../lib/libXs.a -lXm -lXt -lX11 -lm

.o:.c

all: lib dial sqdial

lib : Dial.o SquareDial.o
	ar ruv ../lib/libXs.a Dial.o SquareDial.o

dial: dial.o
	$(CC) $(CFLAGS) -o $@ $@.o $(LIBS)

sqdial: sqdial.o
	$(CC) $(CFLAGS) -o $@ $@.o $(LIBS)

@EOF

chmod 644 ch12/Makefile

echo x - ch12/SquareDialP.h
cat >ch12/SquareDialP.h <<'@EOF'
/**********************************************************************************
  * SquareDialP.h:The SquareDial widget private header file.
  *         From:
  *                   The X Window System, 
  *            Programming and Applications with Xt
  *                   OSF/Motif Edition
  *         by
  *                Douglas Young
  *              Prentice Hall, 1990
  *
  *                 Example described on pages:  364-369
  *
  *
  *  Copyright 1989 by Prentice Hall
  *  All Rights Reserved
  *
  * This code is based on the OSF/Motif widget set and the X Window System
  *
  * Permission to use, copy, modify, and distribute this software for 
  * any purpose and without fee is hereby granted, provided that the above
  * copyright notice appear in all copies and that both the copyright notice
  * and this permission notice appear in supporting documentation.
  *
  * Prentice Hall and the author disclaim all warranties with regard to 
  * this software, including all implied warranties of merchantability and fitness.
  * In no event shall Prentice Hall or the author be liable for any special,
  * indirect or cosequential damages or any damages whatsoever resulting from 
  * loss of use, data or profits, whether in an action of contract, negligence 
  * or other tortious action, arising out of or in connection with the use 
  * or performance of this software.
  *
  * Open Software Foundation is a trademark of The Open Software Foundation, Inc.
  * OSF is a trademark of Open Software Foundation, Inc.
  * OSF/Motif is a trademark of Open Software Foundation, Inc.
  * Motif is a trademark of Open Software Foundation, Inc.
  * DEC is a registered trademark of Digital Equipment Corporation
  * HP is a registered trademark of the Hewlett Packard Company
  * DIGITAL is a registered trademark of Digital Equipment Corporation
  * X Window System is a trademark of the Massachusetts Institute of Technology
  **********************************************************************************/


#ifndef SQUAREDIALP_H
#define SQUAREDIALP_H

typedef struct _XsSquareDialClassPart{
   int ignore;	
} XsSquareDialClassPart;

typedef struct _XsSquareDialClassRec {
   CoreClassPart            core_class;
   XsDialClassPart          dial_class;
   XsSquareDialClassPart    square_dial_class;
} XsSquareDialClassRec;

extern XsSquareDialClassRec XssquareDialClassRec;

typedef struct _XsSquareDialPart{
  int ignore;
} XsSquareDialPart;

typedef struct _XsSquareDialRec{
   CorePart	          core;
   XsDialPart        dial;
   XsSquareDialPart  squaredial;
} XsSquareDialRec;

#endif SQUAREDIALP_H
@EOF

chmod 644 ch12/SquareDialP.h

echo x - ch12/dial.c
cat >ch12/dial.c <<'@EOF'
/**********************************************************************************
 * dial.c : test the Dial widget class
  *         From:
  *                   The X Window System, 
  *            Programming and Applications with Xt
  *                   OSF/Motif Edition
  *         by
  *                Douglas Young
  *              Prentice Hall, 1990
  *
  *                 Example described on pages: 362-364
  *
  *
  *  Copyright 1989 by Prentice Hall
  *  All Rights Reserved
  *
  * This code is based on the OSF/Motif widget set and the X Window System
  *
  * Permission to use, copy, modify, and distribute this software for 
  * any purpose and without fee is hereby granted, provided that the above
  * copyright notice appear in all copies and that both the copyright notice
  * and this permission notice appear in supporting documentation.
  *
  * Prentice Hall and the author disclaim all warranties with regard to 
  * this software, including all implied warranties of merchantability and fitness.
  * In no event shall Prentice Hall or the author be liable for any special,
  * indirect or cosequential damages or any damages whatsoever resulting from 
  * loss of use, data or profits, whether in an action of contract, negligence 
  * or other tortious action, arising out of or in connection with the use 
  * or performance of this software.
  *
  * Open Software Foundation is a trademark of The Open Software Foundation, Inc.
  * OSF is a trademark of Open Software Foundation, Inc.
  * OSF/Motif is a trademark of Open Software Foundation, Inc.
  * Motif is a trademark of Open Software Foundation, Inc.
  * DEC is a registered trademark of Digital Equipment Corporation
  * HP is a registered trademark of the Hewlett Packard Company
  * DIGITAL is a registered trademark of Digital Equipment Corporation
  * X Window System is a trademark of the Massachusetts Institute of Technology
  **********************************************************************************/


#include <X11/Intrinsic.h> 
#include "Dial.h"

void select_callback();

main(argc, argv)
  int   argc;
  char *argv[];
{
  Widget toplevel, dial;
  /*
   * Initialize the Intrinsics.
   */   
  toplevel = XtInitialize(argv[0], "DialTest", NULL, 
                          0, &argc, argv);
  /*
   * Create a dial widget and add a select callback.
   */
  dial = XtCreateManagedWidget("dial", XsdialWidgetClass, 
                               toplevel, NULL, 0);
  XtAddCallback(dial, XtNselectCallback, 
                select_callback, NULL);
  XtRealizeWidget(toplevel);
  XtMainLoop();
}

void select_callback(w, client_data, call_data)
  Widget     w;
  caddr_t    client_data;
  xsdialCallbackStruct *call_data;
{
  Arg wargs[1];

  XtSetArg(wargs[0], XtNposition, call_data->position);
  XtSetValues(w, wargs, 1);
}

@EOF

chmod 644 ch12/dial.c

echo x - ch12/SquareDial.h
cat >ch12/SquareDial.h <<'@EOF'
/**********************************************************************************
  * SquareDial.h:The SquareDial widget public header file.
  *         From:
  *                   The X Window System, 
  *            Programming and Applications with Xt
  *                   OSF/Motif Edition
  *         by
  *                Douglas Young
  *              Prentice Hall, 1990
  *
  *                 Example described on pages:  364-369
  *
  *
  *  Copyright 1989 by Prentice Hall
  *  All Rights Reserved
  *
  * This code is based on the OSF/Motif widget set and the X Window System
  *
  * Permission to use, copy, modify, and distribute this software for 
  * any purpose and without fee is hereby granted, provided that the above
  * copyright notice appear in all copies and that both the copyright notice
  * and this permission notice appear in supporting documentation.
  *
  * Prentice Hall and the author disclaim all warranties with regard to 
  * this software, including all implied warranties of merchantability and fitness.
  * In no event shall Prentice Hall or the author be liable for any special,
  * indirect or cosequential damages or any damages whatsoever resulting from 
  * loss of use, data or profits, whether in an action of contract, negligence 
  * or other tortious action, arising out of or in connection with the use 
  * or performance of this software.
  *
  * Open Software Foundation is a trademark of The Open Software Foundation, Inc.
  * OSF is a trademark of Open Software Foundation, Inc.
  * OSF/Motif is a trademark of Open Software Foundation, Inc.
  * Motif is a trademark of Open Software Foundation, Inc.
  * DEC is a registered trademark of Digital Equipment Corporation
  * HP is a registered trademark of the Hewlett Packard Company
  * DIGITAL is a registered trademark of Digital Equipment Corporation
  * X Window System is a trademark of the Massachusetts Institute of Technology
  **********************************************************************************/


#ifndef  SQUAREDIAL_H
#define  SQUAREDIAL_H
#include "Dial.h"

extern WidgetClass XssquareDialWidgetClass;

typedef struct _XsSquareDialClassRec * XsSquareDialWidgetClass;
typedef struct _XsSquareDialRec      * XsSquareDialWidget;

#endif  SQUAREDIAL_H
@EOF

chmod 644 ch12/SquareDial.h

echo x - ch12/sqdial.c
cat >ch12/sqdial.c <<'@EOF'
/**********************************************************************************
  * sqdial.c : Test of the Square Dial widget class
  *         From:
  *                   The X Window System, 
  *            Programming and Applications with Xt
  *                   OSF/Motif Edition
  *         by
  *                Douglas Young
  *              Prentice Hall, 1990
  *
  *                 Example described on pages: 369-370
  *
  *
  *  Copyright 1989 by Prentice Hall
  *  All Rights Reserved
  *
  * This code is based on the OSF/Motif widget set and the X Window System
  *
  * Permission to use, copy, modify, and distribute this software for 
  * any purpose and without fee is hereby granted, provided that the above
  * copyright notice appear in all copies and that both the copyright notice
  * and this permission notice appear in supporting documentation.
  *
  * Prentice Hall and the author disclaim all warranties with regard to 
  * this software, including all implied warranties of merchantability and fitness.
  * In no event shall Prentice Hall or the author be liable for any special,
  * indirect or cosequential damages or any damages whatsoever resulting from 
  * loss of use, data or profits, whether in an action of contract, negligence 
  * or other tortious action, arising out of or in connection with the use 
  * or performance of this software.
  *
  * Open Software Foundation is a trademark of The Open Software Foundation, Inc.
  * OSF is a trademark of Open Software Foundation, Inc.
  * OSF/Motif is a trademark of Open Software Foundation, Inc.
  * Motif is a trademark of Open Software Foundation, Inc.
  * DEC is a registered trademark of Digital Equipment Corporation
  * HP is a registered trademark of the Hewlett Packard Company
  * DIGITAL is a registered trademark of Digital Equipment Corporation
  * X Window System is a trademark of the Massachusetts Institute of Technology
  **********************************************************************************/

#include <X11/Intrinsic.h> 
#include "SquareDial.h"

void select_callback();

main(argc, argv)
    int   argc;
    char *argv[];
  {
    Widget toplevel, dial;
    /*
     * Initialize the Intrinsics.
     */
    toplevel = XtInitialize(argv[0], "DialTest", NULL, 
                            0, &argc, argv);
    /*
     * Create a square dial widget and assign a callback.
     */
    dial = XtCreateManagedWidget("dial", 
                                 XssquareDialWidgetClass, 
                                 toplevel, NULL, 0);
    XtAddCallback(dial, XtNselectCallback,
                 select_callback, NULL);
    XtRealizeWidget(toplevel);
    XtMainLoop();
}

void select_callback(w, client_data, call_data)
  Widget     w;
  caddr_t    client_data;
  xsdialCallbackStruct *call_data;
{
  Arg wargs[1];

  XtSetArg(wargs[0], XtNposition, call_data->position);
  XtSetValues(w, wargs, 1);
}
@EOF

chmod 644 ch12/sqdial.c

echo x - ch12/SquareDial.c
cat >ch12/SquareDial.c <<'@EOF'
/**********************************************************************************
  * SquareDial.c: A subclass of the Dial widget class
  *         From:
  *                   The X Window System, 
  *            Programming and Applications with Xt
  *                   OSF/Motif Edition
  *         by
  *                Douglas Young
  *              Prentice Hall, 1990
  *
  *                 Example described on pages:  364-369
  *
  *
  *  Copyright 1989 by Prentice Hall
  *  All Rights Reserved
  *
  * This code is based on the OSF/Motif widget set and the X Window System
  *
  * Permission to use, copy, modify, and distribute this software for 
  * any purpose and without fee is hereby granted, provided that the above
  * copyright notice appear in all copies and that both the copyright notice
  * and this permission notice appear in supporting documentation.
  *
  * Prentice Hall and the author disclaim all warranties with regard to 
  * this software, including all implied warranties of merchantability and fitness.
  * In no event shall Prentice Hall or the author be liable for any special,
  * indirect or cosequential damages or any damages whatsoever resulting from 
  * loss of use, data or profits, whether in an action of contract, negligence 
  * or other tortious action, arising out of or in connection with the use 
  * or performance of this software.
  *
  * Open Software Foundation is a trademark of The Open Software Foundation, Inc.
  * OSF is a trademark of Open Software Foundation, Inc.
  * OSF/Motif is a trademark of Open Software Foundation, Inc.
  * Motif is a trademark of Open Software Foundation, Inc.
  * DEC is a registered trademark of Digital Equipment Corporation
  * HP is a registered trademark of the Hewlett Packard Company
  * DIGITAL is a registered trademark of Digital Equipment Corporation
  * X Window System is a trademark of the Massachusetts Institute of Technology
  **********************************************************************************/



#include <stdio.h>
#include <X11/IntrinsicP.h>
#include <X11/Intrinsic.h>
#include <X11/StringDefs.h>
#include <X11/CoreP.h>
#include "DialP.h"
#include "Dial.h"
#include "SquareDialP.h"
#include "SquareDial.h"
#define  MIN(a,b)    (((a) < (b)) ? (a) :  (b))
static void Resize();
static void Initialize();

XsSquareDialClassRec  XssquareDialClassRec = {
/* CoreClassPart */
  {
   (WidgetClass) &XsdialClassRec,  /* superclass            */
   "SquareDial",                   /* class_name            */
   sizeof(XsSquareDialRec),        /* widget_size           */
   NULL,                           /* class_initialize      */
   NULL,                           /* class_part_initialize */
   FALSE,                          /* class_inited          */
   (XtWidgetProc) Initialize,      /* initialize            */
   NULL,                           /* initialize_hook       */
   XtInheritRealize,               /* realize               */
   NULL,                           /* actions               */
   0,                              /* num_actions           */
   NULL,                           /* resources             */
   0,                              /* num_resources         */
   NULLQUARK,                      /* xrm_class             */
   TRUE,                           /* compress_motion       */
   TRUE,                           /* compress_exposure     */
   TRUE,                           /* compress_enterleave   */
   TRUE,                           /* visible_interest      */
   NULL,                           /* destroy               */
   (XtWidgetProc) Resize,          /* resize                */
   XtInheritExpose,                /* expose                */
   NULL,                           /* set_values            */
   NULL,                           /* set_values_hook       */
   XtInheritSetValuesAlmost,       /* set_values_almost     */
   NULL,                           /* get_values_hook       */
   XtInheritAcceptFocus,           /* accept_focus          */
   XtVersion,                      /* version               */
   NULL,                           /* callback private      */
   XtInheritTranslations,          /* tm_table              */
   NULL,                           /* query_geometry        */
   NULL,                           /* display_accelerator   */
   NULL                            /* extension             */
   },
      /* Dial class fields */
  {
   0,                              /* ignore                */
   },
      /* Square Dial class fields */
  {
   0,                              /* ignore                */
   }
};

WidgetClass XssquareDialWidgetClass = 
         (WidgetClass) &XssquareDialClassRec;

static void Initialize(request, new)
  XsSquareDialWidget    request, new;
{
  Resize(new);
}

static void Resize(w)
  XsSquareDialWidget    w;
{
  int      marks_per_side, h_increment, v_increment, i;
  XPoint  *ptr;
  /*
   * Get the address of the segment array.
   */
  ptr = w->dial.segments;
  /*
   * Calculate the center of the window.
   */
  w->dial.center_x = w->core.width / 2; 
  w->dial.center_y = w->core.height / 2; 

  w->dial.outer_diam = MIN(w->core.width, w->core.height) / 2;
  w->dial.inner_diam = w->dial.outer_diam - w->dial.marker_length; 
  /* 
   * Position the marks up the left side, across the top,   
   * and down the right side of the window.   
   */
   marks_per_side  = w->dial.markers / 3;
   w->dial.markers = marks_per_side * 3;
   h_increment = w->core.width / (marks_per_side + 1);
   v_increment = w->core.height / (marks_per_side + 1);
  /* 
   * Do the left side.  
  */
  for(i=0;i<marks_per_side;i++){
    ptr->x   = 0; 
    ptr++->y =  w->core.height - i * v_increment - v_increment;
    ptr->x   = w->dial.marker_length; 
    ptr++->y = w->core.height - i * v_increment - v_increment;
   }
   /* 
    * Do the top. 
    */
   for(i=0;i<marks_per_side;i++){
    ptr->x    = h_increment + i * h_increment;
    ptr++->y  = 0; 
    ptr->x    = h_increment + i * h_increment; 
    ptr++->y  = w->dial.marker_length;     
  }
   /*
    * Do the right side. 
    */
   for(i=0;i<marks_per_side;i++){
    ptr->x   = w->core.width - w->dial.marker_length; 
    ptr++->y = w->core.height - i * v_increment - v_increment; 
    ptr->x   = w->core.width; 
    ptr++->y = w->core.height - i * v_increment - v_increment; 
  }
} 
@EOF

chmod 644 ch12/SquareDial.c

chmod 775 ch12

echo mkdir - ch13
mkdir ch13

echo x - ch13/RowP.h
cat >ch13/RowP.h <<'@EOF'
/**********************************************************************************
 * RowP.h: private header file for the Row widget
  *         From:
  *                   The X Window System, 
  *            Programming and Applications with Xt
  *                   OSF/Motif Edition
  *         by
  *                Douglas Young
  *              Prentice Hall, 1990
  *
  *                 Example described on pages: 375-390
  *
  *
  *  Copyright 1989 by Prentice Hall
  *  All Rights Reserved
  *
  * This code is based on the OSF/Motif widget set and the X Window System
  *
  * Permission to use, copy, modify, and distribute this software for 
  * any purpose and without fee is hereby granted, provided that the above
  * copyright notice appear in all copies and that both the copyright notice
  * and this permission notice appear in supporting documentation.
  *
  * Prentice Hall and the author disclaim all warranties with regard to 
  * this software, including all implied warranties of merchantability and fitness.
  * In no event shall Prentice Hall or the author be liable for any special,
  * indirect or cosequential damages or any damages whatsoever resulting from 
  * loss of use, data or profits, whether in an action of contract, negligence 
  * or other tortious action, arising out of or in connection with the use 
  * or performance of this software.
  *
  * Open Software Foundation is a trademark of The Open Software Foundation, Inc.
  * OSF is a trademark of Open Software Foundation, Inc.
  * OSF/Motif is a trademark of Open Software Foundation, Inc.
  * Motif is a trademark of Open Software Foundation, Inc.
  * DEC is a registered trademark of Digital Equipment Corporation
  * HP is a registered trademark of the Hewlett Packard Company
  * DIGITAL is a registered trademark of Digital Equipment Corporation
  * X Window System is a trademark of the Massachusetts Institute of Technology
  **********************************************************************************/

#ifndef ROWP_H
#define ROWP_H

typedef struct _XsRowClassPart {
          int    empty;
} XsRowClassPart;

typedef struct _XsRowClassRec {
    CoreClassPart       core_class;
    CompositeClassPart  composite_class;
    XsRowClassPart      row_class;
} XsRowClassRec;

extern XsRowClassRec XsrowClassRec;

typedef struct {
     int empty;
} XsRowPart;

typedef struct _XsRowRec {
    CorePart        core;
    CompositePart   composite;
    XsRowPart       row;
}  XsRowRec;

#endif ROWP_H
@EOF

chmod 644 ch13/RowP.h

echo x - ch13/Row.h
cat >ch13/Row.h <<'@EOF'
/**********************************************************************************
 * Row.h: public header file for the Row widget
  *         From:
  *                   The X Window System, 
  *            Programming and Applications with Xt
  *                   OSF/Motif Edition
  *         by
  *                Douglas Young
  *              Prentice Hall, 1990
  *
  *                 Example described on pages: 375-390
  *
  *
  *  Copyright 1989 by Prentice Hall
  *  All Rights Reserved
  *
  * This code is based on the OSF/Motif widget set and the X Window System
  *
  * Permission to use, copy, modify, and distribute this software for 
  * any purpose and without fee is hereby granted, provided that the above
  * copyright notice appear in all copies and that both the copyright notice
  * and this permission notice appear in supporting documentation.
  *
  * Prentice Hall and the author disclaim all warranties with regard to 
  * this software, including all implied warranties of merchantability and fitness.
  * In no event shall Prentice Hall or the author be liable for any special,
  * indirect or cosequential damages or any damages whatsoever resulting from 
  * loss of use, data or profits, whether in an action of contract, negligence 
  * or other tortious action, arising out of or in connection with the use 
  * or performance of this software.
  *
  * Open Software Foundation is a trademark of The Open Software Foundation, Inc.
  * OSF is a trademark of Open Software Foundation, Inc.
  * OSF/Motif is a trademark of Open Software Foundation, Inc.
  * Motif is a trademark of Open Software Foundation, Inc.
  * DEC is a registered trademark of Digital Equipment Corporation
  * HP is a registered trademark of the Hewlett Packard Company
  * DIGITAL is a registered trademark of Digital Equipment Corporation
  * X Window System is a trademark of the Massachusetts Institute of Technology
  **********************************************************************************/


#ifndef ROW_H
#define ROW_H
extern WidgetClass XsrowWidgetClass;
typedef struct _XsRowClassRec *XsRowWidgetClass;
typedef struct _XsRowRec      *XsRowWidget;
#endif ROW_H
@EOF

chmod 644 ch13/Row.h

echo x - ch13/Row.c
cat >ch13/Row.c <<'@EOF'
/**********************************************************************************
 * Row.c: Methods for the Row widget
  *         From:
  *                   The X Window System, 
  *            Programming and Applications with Xt
  *                   OSF/Motif Edition
  *         by
  *                Douglas Young
  *              Prentice Hall, 1990
  *
  *                 Example described on pages: 375-390
  *
  *
  *  Copyright 1989 by Prentice Hall
  *  All Rights Reserved
  *
  * This code is based on the OSF/Motif widget set and the X Window System
  *
  * Permission to use, copy, modify, and distribute this software for 
  * any purpose and without fee is hereby granted, provided that the above
  * copyright notice appear in all copies and that both the copyright notice
  * and this permission notice appear in supporting documentation.
  *
  * Prentice Hall and the author disclaim all warranties with regard to 
  * this software, including all implied warranties of merchantability and fitness.
  * In no event shall Prentice Hall or the author be liable for any special,
  * indirect or cosequential damages or any damages whatsoever resulting from 
  * loss of use, data or profits, whether in an action of contract, negligence 
  * or other tortious action, arising out of or in connection with the use 
  * or performance of this software.
  *
  * Open Software Foundation is a trademark of The Open Software Foundation, Inc.
  * OSF is a trademark of Open Software Foundation, Inc.
  * OSF/Motif is a trademark of Open Software Foundation, Inc.
  * Motif is a trademark of Open Software Foundation, Inc.
  * DEC is a registered trademark of Digital Equipment Corporation
  * HP is a registered trademark of the Hewlett Packard Company
  * DIGITAL is a registered trademark of Digital Equipment Corporation
  * X Window System is a trademark of the Massachusetts Institute of Technology
  **********************************************************************************/


#include    <X11/IntrinsicP.h>
#include    <X11/Intrinsic.h>
#include    <X11/Composite.h>
#include    <X11/CompositeP.h>
#include    "RowP.h"
#include    "Row.h"
#define MAX(a,b) ((a) > (b) ? (a) : (b))
#define MIN(a,b) ((a) < (b) ? (a) : (b))

static void              Initialize();
static void              Resize();
static void              ChangeManaged();
static Boolean           SetValues();
static XtGeometryResult  GeometryManager();
static XtGeometryResult  PreferredSize();
static XtGeometryResult  try_layout();

XsRowClassRec XsrowClassRec = {
  {
    /* core_class members      */
    (WidgetClass) &compositeClassRec, /* superclass         */
    "Row",                            /* class_name         */
    sizeof(XsRowRec),                 /* widget_size        */
    NULL,                             /* class_initialize   */
    NULL,                             /* class_part_init    */	
    FALSE,                            /* class_inited       */	
    Initialize,                       /* initialize         */
    NULL,                             /* initialize_hook    */	
    XtInheritRealize,                 /* realize            */
    NULL,                             /* actions            */
    0,                                /* num_actions        */	
    NULL,                             /* resources          */
    0,                                /* num_resources      */
    NULLQUARK,                        /* xrm_class          */
    TRUE,                             /* compress_motion    */	
    TRUE,                             /* compress_exposure  */	
    TRUE,                             /* compress_enterleave*/	
    FALSE,                            /* visible_interest   */
    NULL,                             /* destroy            */
    Resize,                           /* resize             */
    NULL,                             /* expose             */
    NULL,                             /* set_values         */
    NULL,                             /* set_values_hook    */
    XtInheritSetValuesAlmost,         /* set_values_almost  */
    NULL,                             /* get_values_hook    */	
    NULL,                             /* accept_focus       */
    XtVersion,                        /* version            */	
    NULL,                             /* callback_private   */
    NULL,                             /* tm_table           */
    PreferredSize,                    /* query_geometry     */	
    NULL,                             /* display_accelerator*/
    NULL,                             /* extension          */
  },
  {
    /* composite_class members */
    GeometryManager,                  /* geometry_manager   */
    ChangeManaged,                    /* change_managed     */
    XtInheritInsertChild,             /* insert_child       */	
    XtInheritDeleteChild,             /* delete_child       */	
    NULL,                             /* extension          */
  },
  {
    /* Row class members */
    0,                                /* empty              */	
  }
};
WidgetClass XsrowWidgetClass = (WidgetClass) &XsrowClassRec;

static void Initialize(request, new)
    XsRowWidget request, new;
{
  if (request -> core.width <= 0)
    new -> core.width = 5;
  if (request -> core.height <= 0)
    new -> core.height = 5;
} 

static void Resize(w)
     XsRowWidget    w;
{
  do_layout(w);
} 

do_layout(parent)
     XsRowWidget parent;
{
  Widget     child;
  int        i;
  Dimension  childwidth = 0;
  Position   xpos = 0;
  Dimension  pad = 0;
  int    n_managed_children = 0;
 /*
  * Compute the total width of all managed children and
  * determine how many children are managed.
  */
  for (i = 0; i < parent -> composite.num_children; i++){
    child = parent -> composite.children[i];
    if(child->core.managed){
      n_managed_children++;
      childwidth += child->core.width + 
                         child->core.border_width * 2;
    }
 }
  /*
   *  Divide any remaining space by the number 
   *  of children.
   */
  if((n_managed_children > 1) && 
          (parent->core.width > childwidth))
    pad = (parent->core.width - childwidth) /
                                  (n_managed_children - 1);
  /*
   * Position all children.
  */
  for (i = 0; i < parent -> composite.num_children; i++){
    child = parent -> composite.children[i];
    if(child->core.managed){
       XtMoveWidget (child, xpos, 0);
       xpos += pad + child->core.width + 
                             child->core.border_width * 2;
     }
  }
}
static XtGeometryResult PreferredSize(w, request, preferred)
    XsRowWidget w;
    XtWidgetGeometry *request, *preferred;
{
  Widget child;
  int i;
  /*
   * If no changes are being made to width or 
   * height, just agree. 
   */
  if(!(request->request_mode & CWWidth) &&
     !(request->request_mode & CWHeight))
    return (XtGeometryYes);
  /*
   * Calculate our minimum size.
   */
  preferred->width = 0;
  preferred->height = 0;       
  for (i = 0; i < w -> composite.num_children; i++){
    child = w -> composite.children[i];
    if(child->core.managed){
       preferred->width += child->core.width + 
                                child->core.border_width * 2;
       if(preferred->height < child->core.height + 
               child->core.border_width * 2)
         preferred->height = child->core.height +
                                child->core.border_width * 2;
     }
  }
  preferred->request_mode = CWWidth | CWHeight;
  /* 
   * If both width and height are requested.
   */
  if((request->request_mode & CWWidth) && 
     (request->request_mode & CWHeight)){
    /* 
     * If we are to be the same or bigger, say ok.
     */
    if(preferred->width <= request->width &&            /* Error in first printing */
            preferred->height <= request->height){      /* Signs were reversed     */
      preferred->width  = request->width;
      preferred->height = request->height;
      return (XtGeometryYes);
    }
    /*
     * If both dimensions are unacceptable, say no.
     */
    else
      if(preferred->width < request->width && 
         preferred->height < request->height)
       	return (XtGeometryNo);
    /*
     * Otherwise one must be right, so say almost.
     */
      else
	         return (XtGeometryAlmost);
  }
  /*
   * If only the width is requested, either it's 
   * OK or it isn't. Same for height.
   */
  else
    if(request->request_mode & CWWidth){
      if(preferred->width <= request->width){
       	 preferred->width = request->width;
         return (XtGeometryYes);
      } 
      else
        	return (XtGeometryNo);
    }
    else
     if(request->request_mode & CWHeight){
      if(preferred->height <= request->height){
         	preferred->height = request->height;
         	return (XtGeometryYes);
      }
      else
        	return (XtGeometryNo);
    }
    return (XtGeometryYes);
}

static XtGeometryResult GeometryManager(w, request, reply)
    Widget		            w;
    XtWidgetGeometry	  *request;
    XtWidgetGeometry	  *reply;
{
  XsRowWidget      rw = (XsRowWidget) w -> core.parent;
  Mask             mask;
  XtGeometryResult result;
  Dimension        wdelta, hdelta;
  /*
   * Say no.  We control the vertical....
   */
  if ((request->request_mode & CWX && 
                    request->x != w->core.x)||
      (request->request_mode & CWY && 
                    request->y != w->core.y))
    return (XtGeometryNo);
  /*
   *  Otherwise, grant all requests if they fit.
   */
  if (request->request_mode & 
                    (CWWidth | CWHeight | CWBorderWidth)){
    /*
     * Save the original widget size, and set the 
     * corresponding widget fields to the requested sizes.
     */
    Dimension savewidth       = w->core.width;
    Dimension saveheight      = w->core.height;
    Dimension saveborderwidth = w->core.border_width;

    if (request->request_mode & CWWidth)
      w->core.width  = request->width;
    if (request->request_mode & CWHeight)
      w->core.height = request->height;
    if (request->request_mode & CWBorderWidth)
      w->core.border_width = request->border_width;
    /*
     * See if we can still handle all the children 
     * if the request is granted.
     */
    result = try_layout(rw, &mask, &wdelta, &hdelta);
    /*
     * If the children won't fit, restore the widget to its
     * original size, and return no.
     */
    if(result == XtGeometryNo){
      w->core.width  = savewidth;
      w->core.height = saveheight;
      w->core.border_width = saveborderwidth;
      return (XtGeometryNo);
    }
    /*
     * If only one dimension fits, restore the one that
     * doesn't fit and return "almost".
     */
    if(result == XtGeometryAlmost){    
      reply->request_mode = request->request_mode;
      if(!(mask & CWWidth)){
      reply->width = w->core.width = savewidth;
       reply->border_width  = saveborderwidth;
       w->core.border_width = saveborderwidth;
      }
      if(!(mask & CWHeight))
        reply->height = w->core.height = saveheight;
     
      return (XtGeometryAlmost);  
    }
    /*
     *  If we got here, everything must fit, so reposition
     *  all children based on the new size, and return "yes".
     */
    do_layout(rw);
    return (XtGeometryYes); 
  }
  return (XtGeometryYes);
}

static XtGeometryResult 
try_layout(parent, mask, w_delta, h_delta)
     XsRowWidget parent;
     Mask       *mask;
     Dimension  *w_delta, *h_delta;
{
  int  i;
  Dimension total_width = 0, max_height = 0;
  /*
   * Get the bounding width and height of all children.
   */
  for (i = 0; i < parent -> composite.num_children; i++){
   Widget    child;
   Dimension width, height;

  child  = parent -> composite.children[i];
  if(child->core.managed){
    height =child->core.height + child->core.border_width * 2;
    width  =child->core.width + child->core.border_width * 2;
    total_width += width;
    max_height = MAX(max_height, height);
  }
 }
 /*
  *  If everyone doesn't fit, ask if we can grow. Return the 
  *  result, after setting the mask to indicate which (if 
  *  any) dimension is ok.
  */
 if(total_width > parent->core.width || 
     max_height > parent->core.height){
   XtGeometryResult result;
   Dimension replyWidth, replyHeight;
   Dimension width  =  MAX(total_width, parent->core.width);
   Dimension height = MAX(max_height, parent->core.height);

   result = XtMakeResizeRequest (parent, width, height,
                                 &replyWidth, &replyHeight);
   *mask = NULL;
   if(total_width == replyWidth)
     *mask  = CWWidth;
   if(max_height == replyHeight) 	
    *mask |= CWHeight;

   if(result == XtGeometryAlmost)
     XtMakeResizeRequest (parent, replyWidth, replyHeight, 
                          NULL, NULL);
   *w_delta = total_width - parent->core.width;
   *h_delta = max_height - parent->core.height;
   return (result);
 }
 /*
  * If everybody fits, just return yes.
  */
 *mask = CWWidth | CWHeight;
 return (XtGeometryYes);
}

static void ChangeManaged(w)
     XsRowWidget w; 
{
  XtGeometryResult result;
  Dimension        width, height, delta;
  int              i;
  Mask             mask;
  Widget           child;
  /*
   * See if all children fit.
   */
  result = try_layout(w, &mask, &width, &height);
  /*
   * If they don't, resize all children to be smaller.
   */
  if(result != XtGeometryYes){
    if(w->composite.num_children > 0){
     delta = width / w->composite.num_children;
     for(i=0;i<w->composite.num_children;i++){
       	child = w->composite.children[i];
       height = MIN(child->core.height,
                    w->core.height -child->core.border_width);
       	if(child->core.managed)
	         XtResizeWidget(child,
                       			 child->core.width - delta,
                        height,
			                        child->core.border_width);
     }
   }
  }
  /*
   * Move all children to their new positions.
   */
  do_layout(w);
}

@EOF

chmod 644 ch13/Row.c

echo x - ch13/Makefile
cat >ch13/Makefile <<'@EOF'
CC = cc 
XSLIBDIR = ../lib
DEBUG = 
# HP Machines
CFLAGS = $(DEBUG) -DSYSV  -I$(XSLIBDIR) 
# DEC and Sun
#CFLAGS = $(DEBUG) -I$(XSLIBDIR)

LIBS = ../lib/libXs.a -lXm -lXt -lX11

.o:.c

all: lib rowtest

lib : Row.o
	ar clq ../lib/libXs.a Row.o

rowtest: rowtest.o
	$(CC) $(CFLAGS) -o $@ $@.o $(LIBS)
@EOF

chmod 644 ch13/Makefile

echo x - ch13/rowtest.c
cat >ch13/rowtest.c <<'@EOF'
/**********************************************************************************
 * rowtest.c: Program to test the Row widget
  *         From:
  *                   The X Window System, 
  *            Programming and Applications with Xt
  *                   OSF/Motif Edition
  *         by
  *                Douglas Young
  *              Prentice Hall, 1990
  *
  *                 Example described on pages:  391-397
  *
  *
  *  Copyright 1989 by Prentice Hall
  *  All Rights Reserved
  *
  * This code is based on the OSF/Motif widget set and the X Window System
  *
  * Permission to use, copy, modify, and distribute this software for 
  * any purpose and without fee is hereby granted, provided that the above
  * copyright notice appear in all copies and that both the copyright notice
  * and this permission notice appear in supporting documentation.
  *
  * Prentice Hall and the author disclaim all warranties with regard to 
  * this software, including all implied warranties of merchantability and fitness.
  * In no event shall Prentice Hall or the author be liable for any special,
  * indirect or cosequential damages or any damages whatsoever resulting from 
  * loss of use, data or profits, whether in an action of contract, negligence 
  * or other tortious action, arising out of or in connection with the use 
  * or performance of this software.
  *
  * Open Software Foundation is a trademark of The Open Software Foundation, Inc.
  * OSF is a trademark of Open Software Foundation, Inc.
  * OSF/Motif is a trademark of Open Software Foundation, Inc.
  * Motif is a trademark of Open Software Foundation, Inc.
  * DEC is a registered trademark of Digital Equipment Corporation
  * HP is a registered trademark of the Hewlett Packard Company
  * DIGITAL is a registered trademark of Digital Equipment Corporation
  * X Window System is a trademark of the Massachusetts Institute of Technology
  **********************************************************************************/


#include <X11/StringDefs.h> 
#include <X11/Intrinsic.h> 
#include <Xm/Xm.h>
#include <Xm/PushB.h> 
#include "Row.h"

void   grow (); 
void   unmanage(); 
void   manage(); 

char *names[] = {"Button1", "Button2", "Button3", "Button4"};

main(argc, argv)
  int    argc;
  char  *argv[];
{
  Widget toplevel, row, buttons[4];
  Arg    wargs[2];
  int    i;
  /*
   * Initialize the Intrinsics.
  */
  toplevel = XtInitialize(argv[0], "Rowtest", NULL,
                          0, &argc, argv);
  /*
   * Create a Row widget.
   */
  row = XtCreateManagedWidget("row", XsrowWidgetClass,
                               toplevel, NULL, 0);
  /*
   * Add children to the Row widget.
   */
  for(i=0;i<XtNumber(names);i++)
    buttons[i] = XtCreateWidget(names[i],
                                xmPushButtonWidgetClass,
                                row, NULL, 0);

  XtAddCallback(buttons[0], XmNactivateCallback,
                grow , NULL);
  XtAddCallback(buttons[1], XmNactivateCallback,
                unmanage, NULL);
  XtAddCallback(buttons[2], XmNactivateCallback,
                manage, buttons[1]);
  XtAddCallback(buttons[3], XmNactivateCallback,
                grow , NULL);

  XtManageChildren(buttons, XtNumber(buttons));
  XtRealizeWidget(toplevel);
  XtMainLoop(); 
}

void grow (w, button, call_data)
  Widget     w;
  Widget     button;
  caddr_t    call_data;
{
  Arg        wargs[2];
  Dimension  width, height;
  /*
   *  Get the current width and height of the widget.
   */
  XtSetArg(wargs[0], XtNwidth,  &width);
  XtSetArg(wargs[1], XtNheight, &height);
  XtGetValues(w, wargs, 2);
  /*
   * Increment the width and height by 10 pixels before
   * setting the size.
   */
  width  +=10;
  height +=10;
  XtSetArg(wargs[0], XtNwidth, width);
  XtSetArg(wargs[1], XtNheight, height);
  XtSetValues(w, wargs, 2);
  }
void unmanage(w, client_data, call_data)
   Widget     w;
   caddr_t    client_data;
   caddr_t    call_data;
{
  XtUnmanageChild(w);
}

void manage(w, button, call_data)
   Widget     w;
   Widget     button;
   caddr_t    call_data;
{
  XtManageChild(button);
}
@EOF

chmod 644 ch13/rowtest.c

chmod 775 ch13

echo mkdir - ch14
mkdir ch14

echo x - ch14/Makefile
cat >ch14/Makefile <<'@EOF'
CC = cc 
XSLIBDIR = ../lib
DEBUG = -g
# HP Machines
CFLAGS = $(DEBUG) -DSYSV  -I$(XSLIBDIR) 
# DEC and Sun
#CFLAGS = $(DEBUG) -I$(XSLIBDIR)

LIBS = ../lib/libXs.a -lXm -lXt -lX11

.o:.c

all: libXs.a sort

libXs.a : Tree.o
	ar ruv ../lib/libXs.a Tree.o

sort : sort.o libXs.a
	$(CC) $(CFLAGS) -o $@ $@.o  $(LIBS)





@EOF

chmod 644 ch14/Makefile

echo x - ch14/Tree.c
cat >ch14/Tree.c <<'@EOF'
/**********************************************************************************
  * Tree.c: The Tree Widget Source File
  *         From:
  *                   The X Window System, 
  *            Programming and Applications with Xt
  *                   OSF/Motif Edition
  *         by
  *                Douglas Young
  *              Prentice Hall, 1990
  *
  *                 Example described on pages: 397-419
  *
  *
  *  Copyright 1989 by Prentice Hall
  *  All Rights Reserved
  *
  * This code is based on the OSF/Motif widget set and the X Window System
  *
  * Permission to use, copy, modify, and distribute this software for 
  * any purpose and without fee is hereby granted, provided that the above
  * copyright notice appear in all copies and that both the copyright notice
  * and this permission notice appear in supporting documentation.
  *
  * Prentice Hall and the author disclaim all warranties with regard to 
  * this software, including all implied warranties of merchantability and fitness.
  * In no event shall Prentice Hall or the author be liable for any special,
  * indirect or cosequential damages or any damages whatsoever resulting from 
  * loss of use, data or profits, whether in an action of contract, negligence 
  * or other tortious action, arising out of or in connection with the use 
  * or performance of this software.
  *
  * Open Software Foundation is a trademark of The Open Software Foundation, Inc.
  * OSF is a trademark of Open Software Foundation, Inc.
  * OSF/Motif is a trademark of Open Software Foundation, Inc.
  * Motif is a trademark of Open Software Foundation, Inc.
  * DEC is a registered trademark of Digital Equipment Corporation
  * HP is a registered trademark of the Hewlett Packard Company
  * DIGITAL is a registered trademark of Digital Equipment Corporation
  * X Window System is a trademark of the Massachusetts Institute of Technology
  **********************************************************************************/


#include	  <X11/Intrinsic.h>
#include	  <X11/IntrinsicP.h>
#include	  <X11/StringDefs.h>
#include	  <X11/CoreP.h>
#include  	<X11/CompositeP.h>
#include	  <X11/ConstrainP.h>
#include	  "Tree.h"
#include	  "TreeP.h"
#define   MAX(a,b) ((a) > (b) ? (a) : (b))

static void             Initialize();
static void             ConstraintInitialize();
static void             ConstraintDestroy();
static Boolean          ConstraintSetValues();
static Boolean          SetValues();
static XtGeometryResult GeometryManager();
static void             ChangeManaged();
static void             insert_new_node();
static void             delete_node();
static void             new_layout();
static void             Redisplay();
static TreeOffsetPtr    create_offset();
static int              compute_positions();
static void             shift_subtree();
static void             set_positions();
static void             reset();
static Position         current_position();
static void             set_current_position();
static Position         sum_of_positions();

static XtResource resources[] = {
 {XtNhorizontalSpace,XtCSpace,XtRDimension,sizeof(Dimension),
   XtOffset(XsTreeWidget, tree.h_min_space), XtRString,"15" },
 {XtNverticalSpace,XtCSpace, XtRDimension,sizeof (Dimension),
   XtOffset(XsTreeWidget, tree.v_min_space), XtRString,"5"  },
 {XtNforeground, XtCForeground, XtRPixel, sizeof (Pixel),
  XtOffset(XsTreeWidget, tree.foreground), XtRString,"Black"},
};

static XtResource treeConstraintResources[] = {
 {XtNsuperNode, XtCSuperNode, XtRPointer, sizeof(Widget),
   XtOffset(TreeConstraints, tree.super_node),
   XtRPointer, NULL},
};

XsTreeClassRec XstreeClassRec = {
  {
    /* core_class fields  */
    (WidgetClass) &constraintClassRec,/* superclass         */
    "Tree",                           /* class_name         */
    sizeof(XsTreeRec),                /* widget_size        */
    NULL,                             /* class_init         */
    NULL,                             /* class_part_init    */
    FALSE,                            /* class_inited       */	
    Initialize,                       /* initialize         */
    NULL,                             /* initialize_hook    */	
    XtInheritRealize,                 /* realize            */
    NULL,                             /* actions            */
    0,                                /* num_actions        */	
    resources,                        /* resources          */
    XtNumber(resources),              /* num_resources      */
    NULLQUARK,                        /* xrm_class          */
    TRUE,                             /* compress_motion    */	
    TRUE,                             /* compress_exposure  */	
    TRUE,                             /* compress_enterleave*/	
    TRUE,                             /* visible_interest   */
    NULL,                             /* destroy            */
    NULL,                             /* resize             */
    Redisplay,                        /* expose             */
    SetValues,                        /* set_values         */
    NULL,                             /* set_values_hook    */	
    XtInheritSetValuesAlmost,         /* set_values_almost  */
    NULL,                             /* get_values_hook    */	
    NULL,                             /* accept_focus       */
    XtVersion,                        /* version            */	
    NULL,                             /* callback_private   */
    NULL,                             /* tm_table           */
    NULL,                             /* query_geometry     */	
    NULL,                             /* display_accelerator*/
    NULL,                             /* extension          */
  },
  {
    /* composite_class fields */
    GeometryManager,                 /* geometry_manager    */
    ChangeManaged,                   /* change_managed      */
    XtInheritInsertChild,            /* insert_child        */	
    XtInheritDeleteChild,            /* delete_child        */	
    NULL,                            /* extension           */
  },
  { 
    /* constraint_class fields */
   treeConstraintResources,          /* subresources        */
   XtNumber(treeConstraintResources),/* subresource_count   */
   sizeof(TreeConstraintsRec),       /* constraint_size     */
   ConstraintInitialize,             /* initialize          */
   ConstraintDestroy,                /* destroy             */
   ConstraintSetValues,              /* set_values          */
   NULL,                             /* extension           */
   },
  {
    /* Tree class fields */
    0,                               /* ignore              */	
  }
};

WidgetClass XstreeWidgetClass = (WidgetClass) &XstreeClassRec;

static void Initialize(request, new)
    XsTreeWidget request, new;
{
  Arg       wargs[2];
  XGCValues values;
  XtGCMask  valueMask;
  /*
   * Make sure the widget's width and height are 
   * greater than zero.
   */
  if (request->core.width <= 0)
    new->core.width = 5;
  if (request->core.height <= 0)
    new->core.height = 5;
  /*
   * Create a graphics context for the connecting lines.
   */
  valueMask = GCForeground | GCBackground;
  values.foreground = new->tree.foreground;
  values.background = new->core.background_pixel;
  new->tree.gc = XtGetGC (new, valueMask, &values);  
  /*
   * Create the hidden root widget.
   */
  new->tree.tree_root = (Widget) NULL;
  XtSetArg(wargs[0], XtNwidth, 1);
  XtSetArg(wargs[1], XtNheight, 1);
  new->tree.tree_root = 
          XtCreateWidget("root", widgetClass, new, wargs, 2);
  /*
   * Allocate the tables used by the layout
   * algorithm.
   */
  new->tree.horizontal = create_offset(10);
  new->tree.vertical   = create_offset(10);
} 

static void ConstraintInitialize(request, new)
     Widget request, new;
{
  TreeConstraints tree_const = TREE_CONSTRAINT(new);
  XsTreeWidget tw = (XsTreeWidget) new->core.parent;
  /*
   * Initialize the widget to have no sub-nodes.
   */
  tree_const->tree.n_sub_nodes = 0;
  tree_const->tree.max_sub_nodes = 0;
  tree_const->tree.sub_nodes = (WidgetList) NULL;
  tree_const->tree.x = tree_const->tree.y = 0; 
  /*
   * If this widget has a super-node, add it to that 
   * widget' sub-nodes list. Otherwise make it a sub-node of 
   * the tree_root widget.
   */
  if(tree_const->tree.super_node)
    insert_new_node(tree_const->tree.super_node, new);
  else
    if(tw->tree.tree_root)
      insert_new_node(tw->tree.tree_root, new);
} 

static Boolean SetValues(current, request, new)
    XsTreeWidget current, request, new;
{
 int       redraw = FALSE;
 XGCValues values;
 XtGCMask  valueMask;
 /*
  * If the foreground color has changed, redo the GC's
  * and indicate a redraw.
  */
 if (new->tree.foreground != current->tree.foreground ||
     new->core.background_pixel !=
                           current->core.background_pixel){
   valueMask         = GCForeground | GCBackground;
   values.foreground = new->tree.foreground;
   values.background = new->core.background_pixel;
   XtReleaseGC(new, new->tree.gc);
   new->tree.gc    = XtGetGC (new, valueMask, &values);   
   redraw = TRUE;     
 }
 /*
  * If the minimum spacing has changed, recalculate the
  * tree layout. new_layout() does a redraw, so we don't
  * need SetValues to do another one.
  */
 if (new->tree.v_min_space != current->tree.v_min_space ||
     new->tree.h_min_space != current->tree.h_min_space){ 
   new_layout(new);
   redraw = FALSE;
 }
 return (redraw);
}

static Boolean ConstraintSetValues(current, request, new)
    Widget current, request, new;
{
 TreeConstraints newconst = TREE_CONSTRAINT(new);
 TreeConstraints current_const = TREE_CONSTRAINT(current);
 XsTreeWidget tw = (XsTreeWidget) new->core.parent;
 /*
  * If the super_node field has changed, remove the widget
  * from the old widget's sub_nodes list and add it to the
  * new one.
  */
 if(current_const->tree.super_node !=
                                  newconst->tree.super_node){
   if(current_const->tree.super_node)
     delete_node(current_const->tree.super_node, new);
   if(newconst->tree.super_node)
     insert_new_node(newconst->tree.super_node, new);
   /*
    * If the Tree widget has been realized, 
    * compute new layout.
    */
   if(XtIsRealized(tw))
     new_layout(tw);
  }               
  return (False);
}

static void insert_new_node(super_node, node)
     Widget super_node, node;
{
  TreeConstraints super_const = TREE_CONSTRAINT(super_node);
  TreeConstraints node_const = TREE_CONSTRAINT(node);
  int index = super_const->tree.n_sub_nodes;
  
  node_const->tree.super_node = super_node;
  /*
   * If there is no more room in the sub_nodes array, 
   * allocate additional space.
   */  
  if(super_const->tree.n_sub_nodes ==
                             super_const->tree.max_sub_nodes){
    super_const->tree.max_sub_nodes += 
                    (super_const->tree.max_sub_nodes / 2) + 2;
    super_const->tree.sub_nodes = 
     (WidgetList) XtRealloc(super_const->tree.sub_nodes, 
                           (super_const->tree.max_sub_nodes) *
                            sizeof(Widget));
  } 
  /*
   * Add the sub_node in the next available slot and 
   * increment the counter.
   */
  super_const->tree.sub_nodes[index] = node;
  super_const->tree.n_sub_nodes++;
}

static void delete_node(super_node, node)
    Widget  super_node, node;
{
  TreeConstraints node_const = TREE_CONSTRAINT(node);
  TreeConstraints super_const;
  int             pos, i;
  /*
   * Make sure the super_node exists.
   */
  if(!super_node) return;  
  
  super_const = TREE_CONSTRAINT(super_node);
  /*
   * Find the sub_node on its super_node's list.
   */
  for (pos = 0; pos < super_const->tree.n_sub_nodes; pos++)
    if (super_const->tree.sub_nodes[pos] == node)
      break;
  if (pos == super_const->tree.n_sub_nodes) return;
  /*
   * Decrement the number of sub_nodes
   */  
  super_const->tree.n_sub_nodes--;
  /*
   * Fill in the gap left by the sub_node.
   * Zero the last slot for good luck.
   */
  for (i = pos; i < super_const->tree.n_sub_nodes; i++) 
    super_const->tree.sub_nodes[i] = 
                            super_const->tree.sub_nodes[i+1];
 super_const->tree.sub_nodes[super_const->tree.n_sub_nodes]=0;
}

static void ConstraintDestroy(w) 
#ifdef JUST_LIKE_BOOK  /* Unimportant but perhaps confusing */
     XsTreeWidget w;
#else
     Widget w;
#endif
{ 
  TreeConstraints tree_const = TREE_CONSTRAINT(w);
  int i;
 /* 
  * Remove the widget from its parent's sub-nodes list and
  * make all this widget's sub-nodes sub-nodes of the parent.
  */
  if(tree_const->tree.super_node) { 
    delete_node(tree_const->tree.super_node, w);
    for(i=0;i< tree_const->tree.n_sub_nodes; i++)
      insert_new_node(tree_const->tree.super_node, 
                      tree_const->tree.sub_nodes[i]);
  }
  new_layout(w->core.parent);
}

static XtGeometryResult GeometryManager(w, request, reply)
    Widget               w;
    XtWidgetGeometry    *request;
    XtWidgetGeometry    *reply;
{

 XsTreeWidget tw = (XsTreeWidget) w->core.parent;
 /*
  * No position changes allowed!.
  */
 if ((request->request_mode & CWX && request->x!=w->core.x)
     ||(request->request_mode & CWY && request->y!=w->core.y))
  return (XtGeometryNo);
 /*
  * Allow all resize requests.
  */
 if (request->request_mode & CWWidth)
   w->core.width = request->width;
 if (request->request_mode & CWHeight)
   w->core.height = request->height;
 if (request->request_mode & CWBorderWidth)
   w->core.border_width = request->border_width;
 /*
  *  Compute the new layout based on the new widget sizes;
  */
 new_layout(tw);
 return (XtGeometryYes);
}

static void ChangeManaged(tw)
    XsTreeWidget tw;
{
  new_layout(tw);
}


static void Redisplay (w, event, region)
     XsTreeWidget   w;
     XEvent        *event;
     Region         region;
{
  int              i, j;
  TreeConstraints tree_const;
  Widget          child;
  /*
   * If the Tree widget is visible, visit each managed child.
   */
  if(w->core.visible)
   for (i = 0; i < w -> composite.num_children; i++){
     child = w -> composite.children[i];
     tree_const = TREE_CONSTRAINT(child);
     /*
      * Draw a line between the right edge of each widget
      * and the left edge of each of its sub_nodes. Don't
      * draw lines from the fake tree_root.
      */
     if(child != w->tree.tree_root && 
        tree_const->tree.n_sub_nodes)
       for (j = 0; j < tree_const->tree.n_sub_nodes; j++)
         XDrawLine(XtDisplay(w), XtWindow(w), 
                   w->tree.gc,
                   child->core.x + child->core.width, 
                   child->core.y + child->core.height / 2,
                   tree_const->tree.sub_nodes[j]->core.x,
                   tree_const->tree.sub_nodes[j]->core.y + 
                tree_const->tree.sub_nodes[j]->core.height/2);
    }
}

static void new_layout(tw)
     XsTreeWidget   tw;
{
  /*
   *  Reset the auxiliary tables.
   */
  reset(tw->tree.vertical);
  reset(tw->tree.horizontal);
  /*
   * Compute each widget's x,y position
   */
  compute_positions(tw, tw->tree.tree_root, 0);
  /*
   * Move each widget into place.
   */
  set_positions(tw, tw->tree.tree_root, 0, 0);
  /*
   * Trigger a redisplay of the lines connecting nodes.
   */
  if(XtIsRealized(tw))
    XClearArea(XtDisplay(tw), XtWindow(tw), 0, 0, 0, 0, TRUE);
}

 static int compute_positions(tw, w, level)
     XsTreeWidget tw;
     Widget       w;
     long         level;
{
 Position       current_hpos, current_vpos;
 int             i, depth = 0;
 TreeConstraints tree_const = TREE_CONSTRAINT(w);
 /*
  * Get the current positions for this level.
  */
 current_hpos = current_position(tw->tree.horizontal, level);
 current_vpos = current_position(tw->tree.vertical, level);
 /*
  * Set the current horizontal width to the max widths of all
  * widgets at this level.
  */
 set_current_position(tw->tree.horizontal, level, 
                      MAX(current_hpos, w->core.width));
 /*
  * If the node has no sub_nodes, just set the vertical 
  * position to the next available space.
  */
 if(tree_const->tree.n_sub_nodes == 0){
   tree_const->tree.y = current_vpos;
 }
 else {
   Widget          first_kid, last_kid;
   TreeConstraints const1, const2;
   Position        top, bottom;
  /*
   * If the node has sub_nodes, recursively figure the 
   * positions of each sub_node.
   */
   for(i = 0; i < tree_const->tree.n_sub_nodes; i++)
    depth = compute_positions(tw, 
                              tree_const->tree.sub_nodes[i],
                              level + 1);
  /*
   * Now that the vertical positions of all children are 
   * known, find the vertical extent of all sub_nodes.
   */
  first_kid= tree_const->tree.sub_nodes[0];
  last_kid = 
   tree_const->tree.sub_nodes[tree_const->tree.n_sub_nodes-1];
  const1   = TREE_CONSTRAINT(first_kid);
  const2   = TREE_CONSTRAINT(last_kid);
  top      = const1->tree.y + first_kid->core.height / 2; 
  bottom   = const2->tree.y + last_kid->core.height / 2;
  /*
   * Set the node's position to the center of its sub_nodes.
   */
  tree_const->tree.y = (top + bottom)/2 - (w->core.height/ 2);
  /*
   * If this position is less than the next available 
   * position, correct it to be the next available
   * position, calculate the amount by which all sub_nodes
   * must be shifted, and shift the entire sub-tree.
   */
   if(tree_const->tree.y < current_vpos){
     Dimension offset = current_vpos - tree_const->tree.y;
     for(i = 0; i < tree_const->tree.n_sub_nodes; i++)
       shift_subtree(tree_const->tree.sub_nodes[i], offset);
    /*
     * Adjust the next available space at all levels below
     * the current level.
     */
     for(i = level + 1; i <= depth; i++){
       Position pos = current_position(tw->tree.vertical, i);
       set_current_position(tw->tree.vertical, i, pos+offset);
     }
     tree_const->tree.y = current_vpos;
     }
   }
 /*
  * Record the current vertical position at this level.
  */
  set_current_position(tw->tree.vertical, level,
                       tw->tree.v_min_space + 
                       tree_const->tree.y + w->core.height);
  return (MAX(depth, level));
}

static void shift_subtree(w, offset)
     Widget     w;
     Dimension  offset;
{
  int             i;
  TreeConstraints tree_const = TREE_CONSTRAINT(w);
  /*
   * Shift the node by the offset.
   */
  tree_const->tree.y += offset; 
  /*
   * Shift each sub-node into place.
   */
  for(i=0; i< tree_const->tree.n_sub_nodes; i++)
    shift_subtree(tree_const->tree.sub_nodes[i], offset);
}

static void set_positions(tw, w, level)
     XsTreeWidget tw;
     Widget       w;
     int          level;
{
 int               i;
 Dimension         replyWidth = 0, replyHeight = 0;
 XtGeometryResult  result;
  
 if(w){
  TreeConstraints tree_const = TREE_CONSTRAINT(w);
 /*
  * Add up the sum of the width's of all nodes to this 
  * depth, and use it as the x position.
  */
  tree_const->tree.x = (level * tw->tree.h_min_space) + 
                sum_of_positions(tw->tree.horizontal, level);
 /*
  * Move the widget into position.
  */
  XtMoveWidget (w, tree_const->tree.x, tree_const->tree.y);
 /*
  * If the widget position plus its width or height doesn't
  * fit in the tree, ask if the tree can be resized.
  */
  if(tw->core.width < tree_const->tree.x + w->core.width ||
     tw->core.height < tree_const->tree.y + w->core.height){
    result = 
      XtMakeResizeRequest(tw, MAX(tw->core.width, 
                                  tree_const->tree.x + 
                                  w->core.width),
                              MAX(tw->core.height, 
                                  tree_const->tree.y + 
                                  w->core.height),
                          &replyWidth, &replyHeight);
    /*
     * Accept any compromise.
     */
     if (result == XtGeometryAlmost)
       XtMakeResizeRequest (tw, replyWidth, replyHeight, 
                             NULL, NULL);
  }
 /*
  * Set the positions of all sub_nodes.
  */
  for(i=0; i< tree_const->tree.n_sub_nodes;i++)
    set_positions(tw, tree_const->tree.sub_nodes[i], level+1);
  }
}

static TreeOffsetPtr create_offset(size)
   long size;
{
 TreeOffsetPtr  offset = 
                 (TreeOffsetPtr) XtMalloc(sizeof(TreeOffset));
 offset->size = size;
 offset->array = 
             (Dimension *) XtMalloc(size * sizeof(Dimension));
 return (offset);
}

static void reset(offset)
   TreeOffsetPtr offset;
{
  long i;
  for(i=0; i< offset->size; i++)
    offset->array[i] = 0;
}

static Position current_position(offset, position)
   TreeOffsetPtr  offset;
   long          position;
{
  if(position >= offset->size)
    return (0);
  return (offset->array[position]);
 }

static void set_current_position(offset, index, value)
   TreeOffsetPtr offset;
   int           index;
   Dimension     value;
{
 if(index >= offset->size){
   offset->size = index + index / 2;
   offset->array =
    (Dimension *) XtRealloc(offset->array, 
                            offset->size * sizeof(Dimension));
 }
 offset->array[index] = value;
}

static Position sum_of_positions(offset, index)
   TreeOffsetPtr  offset;
   long           index;
{
  int    i;
  Position  sum  = 0;
  long      stop = index;
  if(index > offset->size) 
    stop = offset->size;
  for (i=0;i < stop; i++)
    sum += offset->array[i];
  return (sum);
}

@EOF

chmod 644 ch14/Tree.c

echo x - ch14/Tree.h
cat >ch14/Tree.h <<'@EOF'
/**********************************************************************************
 * Tree.h: Public header file for the Tree widget
  *         From:
  *                   The X Window System, 
  *            Programming and Applications with Xt
  *                   OSF/Motif Edition
  *         by
  *                Douglas Young
  *              Prentice Hall, 1990
  *
  *                 Example described on pages: 397-419
  *
  *
  *  Copyright 1989 by Prentice Hall
  *  All Rights Reserved
  *
  * This code is based on the OSF/Motif widget set and the X Window System
  *
  * Permission to use, copy, modify, and distribute this software for 
  * any purpose and without fee is hereby granted, provided that the above
  * copyright notice appear in all copies and that both the copyright notice
  * and this permission notice appear in supporting documentation.
  *
  * Prentice Hall and the author disclaim all warranties with regard to 
  * this software, including all implied warranties of merchantability and fitness.
  * In no event shall Prentice Hall or the author be liable for any special,
  * indirect or cosequential damages or any damages whatsoever resulting from 
  * loss of use, data or profits, whether in an action of contract, negligence 
  * or other tortious action, arising out of or in connection with the use 
  * or performance of this software.
  *
  * Open Software Foundation is a trademark of The Open Software Foundation, Inc.
  * OSF is a trademark of Open Software Foundation, Inc.
  * OSF/Motif is a trademark of Open Software Foundation, Inc.
  * Motif is a trademark of Open Software Foundation, Inc.
  * DEC is a registered trademark of Digital Equipment Corporation
  * HP is a registered trademark of the Hewlett Packard Company
  * DIGITAL is a registered trademark of Digital Equipment Corporation
  * X Window System is a trademark of the Massachusetts Institute of Technology
  **********************************************************************************/



#ifndef TREE_H
#define TREE_H

extern WidgetClass  XstreeWidgetClass;

typedef struct _XsTreeClassRec *XsTreeWidgetClass;
typedef struct _XsTreeRec      *XsTreeWidget;

#define XtNhorizontalSpace    "horizontalSpace"
#define XtNverticalSpace      "verticalSpace"
#define XtCPad                "Pad"
#define XtNsuperNode          "superNode"
#define XtCSuperNode          "SuperNode"

#endif TREE_H
@EOF

chmod 644 ch14/Tree.h

echo x - ch14/TreeP.h
cat >ch14/TreeP.h <<'@EOF'
/**********************************************************************************
 * TreeP.h: Private header file for the Tree widget
  *         From:
  *                   The X Window System, 
  *            Programming and Applications with Xt
  *                   OSF/Motif Edition
  *         by
  *                Douglas Young
  *              Prentice Hall, 1990
  *
  *                 Example described on pages: 397-419
  *
  *
  *  Copyright 1989 by Prentice Hall
  *  All Rights Reserved
  *
  * This code is based on the OSF/Motif widget set and the X Window System
  *
  * Permission to use, copy, modify, and distribute this software for 
  * any purpose and without fee is hereby granted, provided that the above
  * copyright notice appear in all copies and that both the copyright notice
  * and this permission notice appear in supporting documentation.
  *
  * Prentice Hall and the author disclaim all warranties with regard to 
  * this software, including all implied warranties of merchantability and fitness.
  * In no event shall Prentice Hall or the author be liable for any special,
  * indirect or cosequential damages or any damages whatsoever resulting from 
  * loss of use, data or profits, whether in an action of contract, negligence 
  * or other tortious action, arising out of or in connection with the use 
  * or performance of this software.
  *
  * Open Software Foundation is a trademark of The Open Software Foundation, Inc.
  * OSF is a trademark of Open Software Foundation, Inc.
  * OSF/Motif is a trademark of Open Software Foundation, Inc.
  * Motif is a trademark of Open Software Foundation, Inc.
  * DEC is a registered trademark of Digital Equipment Corporation
  * HP is a registered trademark of the Hewlett Packard Company
  * DIGITAL is a registered trademark of Digital Equipment Corporation
  * X Window System is a trademark of the Massachusetts Institute of Technology
  **********************************************************************************/


#ifndef TREEP_H
#define TREEP_H
typedef struct _XsTreeClassPart {
    int         ignore;
} XsTreeClassPart;

typedef struct _XsTreeClassRec {
    CoreClassPart       core_class;
    CompositeClassPart  composite_class;
    ConstraintClassPart constraint_class;
    XsTreeClassPart     tree_class;
} XsTreeClassRec;

extern XsTreeClassRec XstreeClassRec;

typedef struct {
    Dimension  *array;
    int         size;
  }  TreeOffset, *TreeOffsetPtr;

typedef struct {
    Dimension      h_min_space;
    Dimension      v_min_space;
    Pixel          foreground;
    GC             gc;
    TreeOffsetPtr  horizontal;
    TreeOffsetPtr  vertical;
    Widget         tree_root;
} XsTreePart;


typedef struct _XsTreeRec {
    CorePart        core;
    CompositePart   composite;
    ConstraintPart  constraint;
    XsTreePart      tree;
}  XsTreeRec;



typedef struct _TreeConstraintsPart {
  Widget        super_node;
  WidgetList    sub_nodes;
  long          n_sub_nodes;
  long          max_sub_nodes;
  Position      x, y;
} TreeConstraintsPart;

typedef struct _TreeConstraintsRec {
   TreeConstraintsPart tree;
} TreeConstraintsRec, *TreeConstraints;


#define TREE_CONSTRAINT(w) \
                   ((TreeConstraints)((w)->core.constraints))

#endif TREEP_H



@EOF

chmod 644 ch14/TreeP.h

echo x - ch14/sort.c
cat >ch14/sort.c <<'@EOF'
/**********************************************************************************
  * sort.c: Display a binary sort tree using the Tree widget.
  *         From:
  *                   The X Window System, 
  *            Programming and Applications with Xt
  *                   OSF/Motif Edition
  *         by
  *                Douglas Young
  *              Prentice Hall, 1990
  *
  *                 Example described on pages: 319-423
  *
  *
  *  Copyright 1989 by Prentice Hall
  *  All Rights Reserved
  *
  * This code is based on the OSF/Motif widget set and the X Window System
  *
  * Permission to use, copy, modify, and distribute this software for 
  * any purpose and without fee is hereby granted, provided that the above
  * copyright notice appear in all copies and that both the copyright notice
  * and this permission notice appear in supporting documentation.
  *
  * Prentice Hall and the author disclaim all warranties with regard to 
  * this software, including all implied warranties of merchantability and fitness.
  * In no event shall Prentice Hall or the author be liable for any special,
  * indirect or cosequential damages or any damages whatsoever resulting from 
  * loss of use, data or profits, whether in an action of contract, negligence 
  * or other tortious action, arising out of or in connection with the use 
  * or performance of this software.
  *
  * Open Software Foundation is a trademark of The Open Software Foundation, Inc.
  * OSF is a trademark of Open Software Foundation, Inc.
  * OSF/Motif is a trademark of Open Software Foundation, Inc.
  * Motif is a trademark of Open Software Foundation, Inc.
  * DEC is a registered trademark of Digital Equipment Corporation
  * HP is a registered trademark of the Hewlett Packard Company
  * DIGITAL is a registered trademark of Digital Equipment Corporation
  * X Window System is a trademark of the Massachusetts Institute of Technology
  **********************************************************************************/


#include <stdio.h>
#include <X11/StringDefs.h>
#include <X11/Intrinsic.h> 
#include <Xm/Xm.h>
#include <Xm/Label.h>
#include <Xm/ScrolledW.h>
#include "Tree.h"

/*
 * Define the structure for a node in the binary sort tree.
 */
typedef struct _node {
  int            key;
  struct _node  *left;
  struct _node  *right;
} node;

extern node *insert_node();
extern node *make_node();
main(argc, argv)
    int argc;
    char **argv;
{
  Widget     toplevel, sw, tree;
  int        i;
  node      *head = NULL;
  int        digit;   
  Arg        wargs[10];
  toplevel = XtInitialize(argv[0], "Sort", NULL, 0, 
                          &argc, argv);
  /*
   * Put the tree in a scrolled window, to handle 
   * large trees.
   */
   XtSetArg(wargs[0], XmNscrollingPolicy, XmAUTOMATIC);
   sw = XtCreateManagedWidget("swindow",
                              xmScrolledWindowWidgetClass,
                              toplevel, wargs, 1);
   /*
    * Create the tree widget.
    */
   tree = XtCreateManagedWidget("tree", XstreeWidgetClass, 
                                sw, NULL, 0);
   /*
    * Create a binary sort tree from data read from stdin.
    */
   while(scanf("%d", &digit) != EOF)
      head = insert_node(digit, head);
   /*
    * Create the widgets representing the tree.
    */
   show_tree(tree, head, NULL);

   XtRealizeWidget(toplevel);
   XtMainLoop();
}

node *insert_node(key, head)
     int   key;
     node *head;
{
  node *prev, *ptr  = head;
  /*
   * If the tree doesn't exist, just create and 
   * return a new node.
   */
  if(!head)
    return (make_node(key));
  /*
   * Otherwise, find a leaf node, always following the 
   * left branches if the key is less than the value in each 
   * node, and the right branch otherwise.
   */
  while(ptr != NULL){ 
    prev = ptr; 
    ptr = (key < ptr->key) ? ptr->left : ptr->right;
  } 
  /*
   * Make a new node and attach it to the appropriate branch.
   */
  if (key < prev->key)
    prev->left = make_node(key);
  else 
    prev->right = make_node(key);
   return (head);
}

node *make_node(key)
     int   key;
{
  node  *ptr = (node *) malloc(sizeof(node));

  ptr->key  = key;
  ptr->left = ptr->right = NULL;

  return (ptr);
}

show_tree(parent, branch, super_node)
     Widget   parent;     
     node    *branch;     
     Widget   super_node; 
{
  Widget   w;
  Arg      wargs[3];
  int      n = 0;
  /*
   * If we've hit a leaf, return.
   */
  if(!branch) return;
  /*
   * Create a widget for the node, specifying the
   * given super_node constraint.
   */
  n = 0;
  XtSetArg(wargs[n], XtNsuperNode, super_node); n++;
  w  =  XtCreateManagedWidget("node", xmLabelWidgetClass, 
                              parent, wargs, n);
  xs_wprintf(w, "%d", branch->key);
  /*
   * Recursively create the subnodes, giving this node's 
   * widget as the super_node.
   */
  show_tree(parent, branch->left,  w);
  show_tree(parent, branch->right, w);
}
@EOF

chmod 644 ch14/sort.c

echo x - ch14/data
cat >ch14/data <<'@EOF'
50 21 72 10 15 17 19 11 14 80 60 90 83 91 65 52 79 25 67 63 68 66
@EOF

chmod 644 ch14/data

chmod 775 ch14

echo mkdir - ch2
mkdir ch2

echo x - ch2/memo.c
cat >ch2/memo.c <<'@EOF'
 /*******************************************************************************
  * memo.c: Display a message in a window
  *
  *         From:
  *                   The X Window System, 
  *            Programming and Applications with Xt
  *                   OSF/Motif Edition
  *         by
  *                Douglas Young
  *              Prentice Hall, 1990
  *
  *                 Example described on pages: 25-30
  *
  *
  *  Copyright 1989 by Prentice Hall
  *  All Rights Reserved
  *
  * This code is based on the OSF/Motif widget set and the X Window System
  *
  * Permission to use, copy, modify, and distribute this software for 
  * any purpose and without fee is hereby granted, provided that the above
  * copyright notice appear in all copies and that both the copyright notice
  * and this permission notice appear in supporting documentation.
  *
  * Prentice Hall and the author disclaim all warranties with regard to 
  * this software, including all implied warranties of merchantability and fitness.
  * In no event shall Prentice Hall or the author be liable for any special,
  * indirect or cosequential damages or any damages whatsoever resulting from 
  * loss of use, data or profits, whether in an action of contract, negligence 
  * or other tortious action, arising out of or in connection with the use 
  * or performance of this software.
  *
  * Open Software Foundation is a trademark of The Open Software Foundation, Inc.
  * OSF is a trademark of Open Software Foundation, Inc.
  * OSF/Motif is a trademark of Open Software Foundation, Inc.
  * Motif is a trademark of Open Software Foundation, Inc.
  * DEC is a registered trademark of Digital Equipment Corporation
  * HP is a registered trademark of the Hewlett Packard Company
  * DIGITAL is a registered trademark of Digital Equipment Corporation
  * X Window System is a trademark of the Massachusetts Institute of Technology
  **********************************************************************************/

#include <X11/Intrinsic.h>
#include <X11/StringDefs.h>
#include <Xm/Xm.h>
#include <Xm/Label.h>

extern XmString xs_concat_words();

main(argc, argv)
   int        argc;
   char      *argv[];
{
   Widget     toplevel, msg_widget;
   Arg        wargs[1];
   int        n;
   XmString   message;
   /*
    * Initialize the Intrinsics
    */
   toplevel = XtInitialize(argv[0],"Memo",NULL,0,&argc,argv);
   /*
    * If a message is given on the command line,
    * use it as the XmNlabelString argument for the widget
    */
   n = 0;
   if ((message = xs_concat_words(argc-1, &argv[1])) != NULL){
      XtSetArg(wargs[n], XmNlabelString, message); n++;
   } 
   /*
    * Create the XmLabel widget.
    */
   msg_widget = XtCreateManagedWidget("msg", 
                                      xmLabelWidgetClass,
                                      toplevel, wargs, n);
   /*
    * Realize the widgets and enter the event loop.
    */
   XtRealizeWidget(toplevel);
   XtMainLoop();
}
@EOF

chmod 644 ch2/memo.c

echo x - ch2/Makefile
cat >ch2/Makefile <<'@EOF'
CC = cc 
XSLIBDIR = ../lib
DEBUG = -g
# HP Machines
CFLAGS = $(DEBUG) -DSYSV  -I$(XSLIBDIR) 
# DEC and Sun
#CFLAGS = $(DEBUG) -I$(XSLIBDIR)

LIBS = ../lib/libXs.a -lXm -lXt -lX11

all: memo memo1 memo2 memo3 memo4 memo5

memo :  memo.o
	$(CC) $(CFLAGS) -o memo memo.c $(LIBS)

memo1 :  memo1.o
	$(CC) $(CFLAGS) -o memo1 memo1.c $(LIBS)

memo2 :  memo2.o
	$(CC) $(CFLAGS) -o memo2 memo2.c $(LIBS)

memo3 :  memo3.o
	$(CC) $(CFLAGS) -o memo3 memo3.c $(LIBS)

memo4 :  memo4.o
	$(CC) $(CFLAGS) -o memo4 memo4.c $(LIBS)

memo5 :  memo5.o
	$(CC) $(CFLAGS) -o memo5 memo5.c $(LIBS)



@EOF

chmod 644 ch2/Makefile

echo x - ch2/memo1.c
cat >ch2/memo1.c <<'@EOF'
 /*******************************************************************************
  * memo.c: Adding an event handler
  *
  *         From:
  *                   The X Window System, 
  *            Programming and Applications with Xt
  *                   OSF/Motif Edition
  *         by
  *                Douglas Young
  *              Prentice Hall, 1990
  *
  *                 Example described on pages: 33-34
  *
  *
  *  Copyright 1989 by Prentice Hall
  *  All Rights Reserved
  *
  * This code is based on the OSF/Motif widget set and the X Window System
  *
  * Permission to use, copy, modify, and distribute this software for 
  * any purpose and without fee is hereby granted, provided that the above
  * copyright notice appear in all copies and that both the copyright notice
  * and this permission notice appear in supporting documentation.
  *
  * Prentice Hall and the author disclaim all warranties with regard to 
  * this software, including all implied warranties of merchantability and fitness.
  * In no event shall Prentice Hall or the author be liable for any special,
  * indirect or cosequential damages or any damages whatsoever resulting from 
  * loss of use, data or profits, whether in an action of contract, negligence 
  * or other tortious action, arising out of or in connection with the use 
  * or performance of this software.
  *
  * Open Software Foundation is a trademark of The Open Software Foundation, Inc.
  * OSF is a trademark of Open Software Foundation, Inc.
  * OSF/Motif is a trademark of Open Software Foundation, Inc.
  * Motif is a trademark of Open Software Foundation, Inc.
  * DEC is a registered trademark of Digital Equipment Corporation
  * HP is a registered trademark of the Hewlett Packard Company
  * DIGITAL is a registered trademark of Digital Equipment Corporation
  * X Window System is a trademark of the Massachusetts Institute of Technology
  **********************************************************************************/

#include <X11/Intrinsic.h>
#include <X11/StringDefs.h>
#include <Xm/Xm.h>
#include <Xm/Label.h>
#include "libXs.h"

extern void quit();

main(argc, argv)
   int    argc;
   char  *argv[];
{
  Widget      toplevel, msg_widget;
  Arg         wargs[1];
  int         n;
  XmString    message;

  /*
   * Initialize the Intrinsics
   */
  toplevel = XtInitialize(argv[0],"Memo",NULL,0,&argc, argv);
  /*
   * If a message is given on the command-line,
   * use it as the XmNlabelString argument for the widget
   */  
  n = 0;
  if ((message = xs_concat_words(argc-1, &argv[1])) != NULL){
     XtSetArg(wargs[n], XmNlabelString, message); n++;
  }
  /*
   * Create the XmLabel widget.
   */
  msg_widget = XtCreateManagedWidget("msg",
                                     xmLabelWidgetClass,
                               				      toplevel, wargs, n);
  /*
   * Register the event handler to be called when 
   * a button is pressed
   */
  XtAddEventHandler(msg_widget, ButtonPressMask, FALSE,
                    quit, NULL);
  /*
   * Realize the widgets and enter the event loop.
   */
  XtRealizeWidget(toplevel);
  XtMainLoop();
}

void quit(w, client_data, event)
  Widget   w;
  caddr_t  client_data;
  XEvent  *event;
{
   XtCloseDisplay(XtDisplay(w));
   exit(0);
}
@EOF

chmod 644 ch2/memo1.c

echo x - ch2/memo2.c
cat >ch2/memo2.c <<'@EOF'
/**********************************************************************************
  * memo.c: Adding an event handler
  *         From:
  *                   The X Window System, 
  *            Programming and Applications with Xt
  *                   OSF/Motif Edition
  *         by
  *                Douglas Young
  *              Prentice Hall, 1990
  *
  *                 Example described on pages:  35-36
  *
  *
  *  Copyright 1989 by Prentice Hall
  *  All Rights Reserved
  *
  * This code is based on the OSF/Motif widget set and the X Window System
  *
  * Permission to use, copy, modify, and distribute this software for 
  * any purpose and without fee is hereby granted, provided that the above
  * copyright notice appear in all copies and that both the copyright notice
  * and this permission notice appear in supporting documentation.
  *
  * Prentice Hall and the author disclaim all warranties with regard to 
  * this software, including all implied warranties of merchantability and fitness.
  * In no event shall Prentice Hall or the author be liable for any special,
  * indirect or cosequential damages or any damages whatsoever resulting from 
  * loss of use, data or profits, whether in an action of contract, negligence 
  * or other tortious action, arising out of or in connection with the use 
  * or performance of this software.
  *
  * Open Software Foundation is a trademark of The Open Software Foundation, Inc.
  * OSF is a trademark of Open Software Foundation, Inc.
  * OSF/Motif is a trademark of Open Software Foundation, Inc.
  * Motif is a trademark of Open Software Foundation, Inc.
  * DEC is a registered trademark of Digital Equipment Corporation
  * HP is a registered trademark of the Hewlett Packard Company
  * DIGITAL is a registered trademark of Digital Equipment Corporation
  * X Window System is a trademark of the Massachusetts Institute of Technology
  **********************************************************************************/


#include <X11/Intrinsic.h>
#include <X11/StringDefs.h>
#include <Xm/Xm.h>
#include <Xm/PushB.h>
#include "libXs.h"

extern void quit();

main(argc, argv)
   int    argc;
   char  *argv[];
{
  Widget      toplevel, msg_widget;
  Arg         wargs[1];
  int         n;
  XmString    message;

  /*
   * Initialize the Intrinsics
   */
  toplevel = XtInitialize(argv[0],"Memo",NULL,0,&argc, argv);
  /*
   * If a message is given on the command-line,
   * use it as the XmNlabelString argument for the widget
   */  
  n = 0;
  if ((message = xs_concat_words(argc-1, &argv[1])) != NULL){
     XtSetArg(wargs[n], XmNlabelString, message); n++;
  }
  /*
   * Create the XmLabel widget.
   */
  msg_widget = XtCreateManagedWidget("msg",
                                     xmPushButtonWidgetClass,
				     toplevel, wargs, n);
  /*
   * Register the event handler to be called when 
   * a button is pressed
   */
  XtAddCallback(msg_widget, XmNactivateCallback, quit, NULL);
  /*
   * Realize the widgets and enter the event loop.
   */
  XtRealizeWidget(toplevel);
  XtMainLoop();
}


void quit(w, client_data, call_data) 
   Widget     w; 
   caddr_t    client_data;
   XmAnyCallbackStruct *call_data; 
{
   XtCloseDisplay(XtDisplay(w));
   exit(0);  
} 
@EOF

chmod 644 ch2/memo2.c

echo x - ch2/memo3.c
cat >ch2/memo3.c <<'@EOF'
/**********************************************************************************
  * memo.c: Defining application actions and translations
  *         From:
  *                   The X Window System, 
  *            Programming and Applications with Xt
  *                   OSF/Motif Edition
  *         by
  *                Douglas Young
  *              Prentice Hall, 1990
  *
  *                 Example described on pages:   38-40
  *
  *
  *  Copyright 1989 by Prentice Hall
  *  All Rights Reserved
  *
  * This code is based on the OSF/Motif widget set and the X Window System
  *
  * Permission to use, copy, modify, and distribute this software for 
  * any purpose and without fee is hereby granted, provided that the above
  * copyright notice appear in all copies and that both the copyright notice
  * and this permission notice appear in supporting documentation.
  *
  * Prentice Hall and the author disclaim all warranties with regard to 
  * this software, including all implied warranties of merchantability and fitness.
  * In no event shall Prentice Hall or the author be liable for any special,
  * indirect or cosequential damages or any damages whatsoever resulting from 
  * loss of use, data or profits, whether in an action of contract, negligence 
  * or other tortious action, arising out of or in connection with the use 
  * or performance of this software.
  *
  * Open Software Foundation is a trademark of The Open Software Foundation, Inc.
  * OSF is a trademark of Open Software Foundation, Inc.
  * OSF/Motif is a trademark of Open Software Foundation, Inc.
  * Motif is a trademark of Open Software Foundation, Inc.
  * DEC is a registered trademark of Digital Equipment Corporation
  * HP is a registered trademark of the Hewlett Packard Company
  * DIGITAL is a registered trademark of Digital Equipment Corporation
  * X Window System is a trademark of the Massachusetts Institute of Technology
  **********************************************************************************/


#include <X11/Intrinsic.h>
#include <X11/StringDefs.h>
#include <Xm/Xm.h>
#include <Xm/Label.h>
#include "libXs.h"

static void quit();
static XtActionsRec actionsTable [] = {
  {"bye",   quit},
};
static char defaultTranslations[] =  "<Key>Q:  bye()";

main(argc, argv)
   int             argc;
   char           *argv[];
{
   Widget          toplevel, msg_widget;
   Arg             wargs[1];
   int             n;
   XmString        message;
   XtTranslations  trans_table;
   /*
    * Initialize Intrinsics
    */
   toplevel = XtInitialize(argv[0],"Memo",NULL,0,&argc,argv);
   /*
    * Register the new actions, and compile 
    * translations table
    */
   XtAddActions(actionsTable, XtNumber(actionsTable));
   trans_table =
      XtParseTranslationTable(defaultTranslations); 
   /*
    * If a message is given on the command-line,
    * use it as the XtNstring argument for the widget
    */
   n = 0;
   if ((message = xs_concat_words(argc-1, &argv[1])) != NULL){
     XtSetArg(wargs[n], XmNlabelString, message); n++;
   }
   /*
    * Create the XmLabel widget.
    */
   msg_widget = XtCreateManagedWidget("msg",  
                                      xmLabelWidgetClass,
                                      toplevel, wargs, n);
   /*
    * Merge the program-defined translations with 
    * existing translations.
    */
   XtAugmentTranslations(msg_widget, trans_table);
   /*
    * Realize all widgets and enter the event loop.
    */
   XtRealizeWidget(toplevel);
   XtMainLoop();
}

static void quit(w, event, params, num_params)
     Widget     w;
     XEvent    *event;
     String    *params;
     Cardinal  *num_params;
{
  XtCloseDisplay(XtDisplay(w));
  exit(0);
}
@EOF

chmod 644 ch2/memo3.c

echo x - ch2/memo4.c
cat >ch2/memo4.c <<'@EOF'
/**********************************************************************************
  * memo.c: Defining application actions and translations 
  *         From:
  *                   The X Window System, 
  *            Programming and Applications with Xt
  *                   OSF/Motif Edition
  *         by
  *                Douglas Young
  *              Prentice Hall, 1990
  *
  *                 Example described on pages:    Not in book
  *
  *
  *  Copyright 1989 by Prentice Hall
  *  All Rights Reserved
  *
  * This code is based on the OSF/Motif widget set and the X Window System
  *
  * Permission to use, copy, modify, and distribute this software for 
  * any purpose and without fee is hereby granted, provided that the above
  * copyright notice appear in all copies and that both the copyright notice
  * and this permission notice appear in supporting documentation.
  *
  * Prentice Hall and the author disclaim all warranties with regard to 
  * this software, including all implied warranties of merchantability and fitness.
  * In no event shall Prentice Hall or the author be liable for any special,
  * indirect or cosequential damages or any damages whatsoever resulting from 
  * loss of use, data or profits, whether in an action of contract, negligence 
  * or other tortious action, arising out of or in connection with the use 
  * or performance of this software.
  *
  * Open Software Foundation is a trademark of The Open Software Foundation, Inc.
  * OSF is a trademark of Open Software Foundation, Inc.
  * OSF/Motif is a trademark of Open Software Foundation, Inc.
  * Motif is a trademark of Open Software Foundation, Inc.
  * DEC is a registered trademark of Digital Equipment Corporation
  * HP is a registered trademark of the Hewlett Packard Company
  * DIGITAL is a registered trademark of Digital Equipment Corporation
  * X Window System is a trademark of the Massachusetts Institute of Technology
  **********************************************************************************/


#include <X11/Intrinsic.h>
#include <X11/StringDefs.h>
#include <Xm/Xm.h>
#include <Xm/Label.h>
#include "libXs.h"

static void quit();
static XtActionsRec actionsTable [] = {
  {"bye",   quit},
};

static char defaultTranslations[] =  "<Key>q:  bye(10)";

static void quit(w, event, params, num_params)
     Widget  w;
     XEvent *event;
     String *params;
     int     *num_params;
{
  if(*num_params == 1)
    sleep(atoi(params[0]));
  XtCloseDisplay(XtDisplay(w));
  exit(0);
}

main(argc, argv)
     int             argc;
     char           *argv[];
{
  Widget          toplevel, msg_widget;
  Arg             wargs[1];
  int             n;
  XmString        message;

  XtTranslations  trans_table;
  /*
   * Initialize Intrinsics
   */
  toplevel = XtInitialize(argv[0], "Memo", NULL, 0, 
			  &argc, argv);
  /*
   * Register the new actions, and compile 
   * translations table
   */
  XtAddActions(actionsTable, XtNumber(actionsTable));
  trans_table =
    XtParseTranslationTable(defaultTranslations); 
  /*
   * If a message is given on the command-line,
   * use it as the XtNstring argument for the widget
   */
  n = 0;
  if ((message = xs_concat_words(argc - 1, &argv[1])) != NULL){
    XtSetArg(wargs[n], XmNlabelString, message); n++;
  }
  /*
   * Create the message widget.
   */
  msg_widget = XtCreateManagedWidget("msg",  
				     xmLabelWidgetClass,
				     toplevel, wargs, n);
  /*
   * Merge the program-defined translations with 
   * existing translations.
   */
  XtAugmentTranslations(msg_widget, trans_table);
  /*
   * Realize all widgets and enter the event loop.
   */
  XtRealizeWidget(toplevel);
  XtMainLoop();
}





@EOF

chmod 664 ch2/memo4.c

echo x - ch2/memo5.c
cat >ch2/memo5.c <<'@EOF'
/**********************************************************************************
  * memo.c: Skeleton Using Application Contexts
  *         From:
  *                   The X Window System, 
  *            Programming and Applications with Xt
  *                   OSF/Motif Edition
  *         by
  *                Douglas Young
  *              Prentice Hall, 1990
  *
  *                 Example described on pages:    ??
  *
  *
  *  Copyright 1989 by Prentice Hall
  *  All Rights Reserved
  *
  * This code is based on the OSF/Motif widget set and the X Window System
  *
  * Permission to use, copy, modify, and distribute this software for 
  * any purpose and without fee is hereby granted, provided that the above
  * copyright notice appear in all copies and that both the copyright notice
  * and this permission notice appear in supporting documentation.
  *
  * Prentice Hall and the author disclaim all warranties with regard to 
  * this software, including all implied warranties of merchantability and fitness.
  * In no event shall Prentice Hall or the author be liable for any special,
  * indirect or cosequential damages or any damages whatsoever resulting from 
  * loss of use, data or profits, whether in an action of contract, negligence 
  * or other tortious action, arising out of or in connection with the use 
  * or performance of this software.
  *
  * Open Software Foundation is a trademark of The Open Software Foundation, Inc.
  * OSF is a trademark of Open Software Foundation, Inc.
  * OSF/Motif is a trademark of Open Software Foundation, Inc.
  * Motif is a trademark of Open Software Foundation, Inc.
  * DEC is a registered trademark of Digital Equipment Corporation
  * HP is a registered trademark of the Hewlett Packard Company
  * DIGITAL is a registered trademark of Digital Equipment Corporation
  * X Window System is a trademark of the Massachusetts Institute of Technology
  **********************************************************************************/


/*
 * Includes and global declarations......
 */

#include <X11/Intrinsic.h>
#include <X11/StringDefs.h>
#include <X11/Shell.h>
#include <Xm/Xm.h>
#include <Xm/Label.h>
#include "libXs.h"

main(argc, argv)
   int     argc;
   char   *argv[];
{
  XtAppContext    app;
  Display        *dpy;
  /*
   * Other declarations .....
   */
  Widget          toplevel, msg_widget;
  Arg             wargs[1];
  int             n;
  XmString        message;

  /*
   * Initialize the Intrinsics
   */
  XtToolkitInitialize();
  /*
   * Create a context.
   */
  app = XtCreateApplicationContext();
  /*
   * Open the display.
   */
  dpy = XtOpenDisplay(app, "", argv[0], "Memo", NULL, 0,
                      &argc, argv);
  /*
   * Create a toplevel shell.
   */
  toplevel = XtAppCreateShell(app, "Memo",
                              applicationShellWidgetClass,
                              dpy, NULL, 0);
  /*
   * Extract message and Create message widget here .....
   */
  n = 0;
  if ((message = xs_concat_words(argc - 1, &argv[1])) != NULL){
    XtSetArg(wargs[n], XmNlabelString, message); n++;
  }
  /*
   * Create the message widget.
   */
  msg_widget = XtCreateManagedWidget("msg",  
				     xmLabelWidgetClass,
				     toplevel, wargs, n);
  XtRealizeWidget(toplevel);
  XtAppMainLoop(app);
}

@EOF

chmod 664 ch2/memo5.c

chmod 775 ch2

echo mkdir - ch3
mkdir ch3

echo x - ch3/Makefile
cat >ch3/Makefile <<'@EOF'
CC = cc 
XSLIBDIR = ../lib
DEBUG = 
# HP Machines
CFLAGS = $(DEBUG) -DSYSV  -I$(XSLIBDIR) 
# DEC and Sun
#CFLAGS = $(DEBUG) -I$(XSLIBDIR)

LIBS = ../lib/libXs.a -lXm -lXt -lX11

.o:.c

all: rmtest rmtest2 rmtest3  draw

rmtest : rmtest.o
	$(CC) $(CFLAGS) -o $@ $@.o $(LIBS)

draw : draw.o
	$(CC) $(CFLAGS) -o $@ $@.o -lXm -lXt -lX11

rmtest2 : rmtest2.o
	$(CC) $(CFLAGS) -o $@ $@.o $(LIBS)

rmtest3 : rmtest3.o 
	$(CC) $(CFLAGS) -o $@ $@.o $(LIBS)

@EOF

chmod 644 ch3/Makefile

echo x - ch3/rmtest.c
cat >ch3/rmtest.c <<'@EOF'
/**********************************************************************************
  * rmtest.c: simple test of the resource manager
  *         From:
  *                   The X Window System, 
  *            Programming and Applications with Xt
  *                   OSF/Motif Edition
  *         by
  *                Douglas Young
  *              Prentice Hall, 1990
  *
  *                 Example described on pages:    55-56
  *
  *
  *  Copyright 1989 by Prentice Hall
  *  All Rights Reserved
  *
  * This code is based on the OSF/Motif widget set and the X Window System
  *
  * Permission to use, copy, modify, and distribute this software for 
  * any purpose and without fee is hereby granted, provided that the above
  * copyright notice appear in all copies and that both the copyright notice
  * and this permission notice appear in supporting documentation.
  *
  * Prentice Hall and the author disclaim all warranties with regard to 
  * this software, including all implied warranties of merchantability and fitness.
  * In no event shall Prentice Hall or the author be liable for any special,
  * indirect or cosequential damages or any damages whatsoever resulting from 
  * loss of use, data or profits, whether in an action of contract, negligence 
  * or other tortious action, arising out of or in connection with the use 
  * or performance of this software.
  *
  * Open Software Foundation is a trademark of The Open Software Foundation, Inc.
  * OSF is a trademark of Open Software Foundation, Inc.
  * OSF/Motif is a trademark of Open Software Foundation, Inc.
  * Motif is a trademark of Open Software Foundation, Inc.
  * DEC is a registered trademark of Digital Equipment Corporation
  * HP is a registered trademark of the Hewlett Packard Company
  * DIGITAL is a registered trademark of Digital Equipment Corporation
  * X Window System is a trademark of the Massachusetts Institute of Technology
  **********************************************************************************/




#include <X11/Intrinsic.h>
#include <X11/StringDefs.h>

typedef struct {
   Pixel    fg, bg;
   int      delay;
   Boolean  verbose;
} ApplicationData, *ApplicationDataPtr;

static XtResource resources[] = {
{ XtNforeground, XtCForeground, XtRPixel, sizeof (Pixel),
  XtOffset(ApplicationDataPtr, fg), XtRString, "Black"     },
{ XtNbackground, XtCBackground, XtRPixel, sizeof (Pixel),
  XtOffset(ApplicationDataPtr, bg), XtRString, "White"     },
{ "delay", "Delay", XtRInt, sizeof (int),
  XtOffset(ApplicationDataPtr, delay),
  XtRImmediate, (caddr_t) 2},
{ "verbose", "Verbose", XtRBoolean, sizeof (Boolean),
  XtOffset(ApplicationDataPtr, verbose), XtRString, "FALSE"},
};

main(argc, argv)
  int    argc;
  char  *argv[];
{
  Widget          toplevel;
  ApplicationData data;

  toplevel = XtInitialize(argv[0], "Rmtest", NULL, 0, 
                          &argc, argv);
  /*
   * Retrieve the application resources.
   */
  XtGetApplicationResources(toplevel, &data, resources, 
                            XtNumber(resources), NULL, 0);
  /*
   * Print the results.
   */
  printf("fg = %d, bg = %d, delay = %d, verbose = %d\n", 
          data.fg, data.bg, data.delay, data.verbose);
}
@EOF

chmod 644 ch3/rmtest.c

echo x - ch3/rmtest2.c
cat >ch3/rmtest2.c <<'@EOF'
/**********************************************************************************
  * rmtest.c: simple test of the resource manager
  *         From:
  *                   The X Window System, 
  *            Programming and Applications with Xt
  *                   OSF/Motif Edition
  *         by
  *                Douglas Young
  *              Prentice Hall, 1990
  *
  *                 Example described on pages:     58-59
  *
  *
  *  Copyright 1989 by Prentice Hall
  *  All Rights Reserved
  *
  * This code is based on the OSF/Motif widget set and the X Window System
  *
  * Permission to use, copy, modify, and distribute this software for 
  * any purpose and without fee is hereby granted, provided that the above
  * copyright notice appear in all copies and that both the copyright notice
  * and this permission notice appear in supporting documentation.
  *
  * Prentice Hall and the author disclaim all warranties with regard to 
  * this software, including all implied warranties of merchantability and fitness.
  * In no event shall Prentice Hall or the author be liable for any special,
  * indirect or cosequential damages or any damages whatsoever resulting from 
  * loss of use, data or profits, whether in an action of contract, negligence 
  * or other tortious action, arising out of or in connection with the use 
  * or performance of this software.
  *
  * Open Software Foundation is a trademark of The Open Software Foundation, Inc.
  * OSF is a trademark of Open Software Foundation, Inc.
  * OSF/Motif is a trademark of Open Software Foundation, Inc.
  * Motif is a trademark of Open Software Foundation, Inc.
  * DEC is a registered trademark of Digital Equipment Corporation
  * HP is a registered trademark of the Hewlett Packard Company
  * DIGITAL is a registered trademark of Digital Equipment Corporation
  * X Window System is a trademark of the Massachusetts Institute of Technology
  **********************************************************************************/

#include <X11/Intrinsic.h>
#include <X11/StringDefs.h>

typedef struct {
   Pixel    fg, bg;
   int      delay;
   Boolean  verbose;
} ApplicationData, *ApplicationDataPtr;

static XtResource resources[] = {
{ XtNforeground, XtCForeground, XtRPixel, sizeof (Pixel),
  XtOffset(ApplicationDataPtr, fg), XtRString, "Black"     },
{ XtNbackground, XtCBackground, XtRPixel, sizeof (Pixel),
  XtOffset(ApplicationDataPtr, bg), XtRString, "White"     },
{ "delay", "Delay", XtRInt, sizeof (int),
  XtOffset(ApplicationDataPtr, delay),
  XtRImmediate, (caddr_t) 2},
{ "verbose", "Verbose", XtRBoolean, sizeof (Boolean),
  XtOffset(ApplicationDataPtr, verbose), XtRString, "FALSE"},
};

XrmOptionDescRec options[] = {
  {"-verbose", "*verbose", XrmoptionNoArg, "TRUE"},
  {"-delay",   "*delay",   XrmoptionSepArg, NULL }
};

main(argc, argv)
  int    argc;
  char  *argv[];
{
  Widget          toplevel;
  ApplicationData data;

  toplevel = XtInitialize(argv[0], "Rmtest", options, 
			  XtNumber(options), &argc, argv);
  /*
   * Retrieve the application resources.
   */
  XtGetApplicationResources(toplevel, &data, resources, 
                            XtNumber(resources), NULL, 0);
  /*
   * Print the results.
   */
  printf("fg = %d, bg = %d, delay = %d, verbose = %d\n", 
          data.fg, data.bg, data.delay, data.verbose);
}
@EOF

chmod 644 ch3/rmtest2.c

echo x - ch3/draw.c
cat >ch3/draw.c <<'@EOF'
/**********************************************************************************
  * draw.c: just makes a widget tree used for resource manager discussion 
  * in chapter three.
  *         From:
  *                   The X Window System, 
  *            Programming and Applications with Xt
  *                   OSF/Motif Edition
  *         by
  *                Douglas Young
  *              Prentice Hall, 1990
  *
  *                 Example described on pages:    ??
  *
  *
  *  Copyright 1989 by Prentice Hall
  *  All Rights Reserved
  *
  * This code is based on the OSF/Motif widget set and the X Window System
  *
  * Permission to use, copy, modify, and distribute this software for 
  * any purpose and without fee is hereby granted, provided that the above
  * copyright notice appear in all copies and that both the copyright notice
  * and this permission notice appear in supporting documentation.
  *
  * Prentice Hall and the author disclaim all warranties with regard to 
  * this software, including all implied warranties of merchantability and fitness.
  * In no event shall Prentice Hall or the author be liable for any special,
  * indirect or cosequential damages or any damages whatsoever resulting from 
  * loss of use, data or profits, whether in an action of contract, negligence 
  * or other tortious action, arising out of or in connection with the use 
  * or performance of this software.
  *
  * Open Software Foundation is a trademark of The Open Software Foundation, Inc.
  * OSF is a trademark of Open Software Foundation, Inc.
  * OSF/Motif is a trademark of Open Software Foundation, Inc.
  * Motif is a trademark of Open Software Foundation, Inc.
  * DEC is a registered trademark of Digital Equipment Corporation
  * HP is a registered trademark of the Hewlett Packard Company
  * DIGITAL is a registered trademark of Digital Equipment Corporation
  * X Window System is a trademark of the Massachusetts Institute of Technology
  **********************************************************************************/

#include <X11/StringDefs.h>
#include <X11/Intrinsic.h> 
#include <Xm/Xm.h>
#include <Xm/DrawingA.h>
#include <Xm/RowColumn.h>
#include <Xm/PushB.h>
#include <Xm/BulletinB.h>

main(argc, argv)
     int argc;
     char **argv;
{
  Widget toplevel, canvas, panel, commands,  options;
  
  toplevel = XtInitialize(argv[0], "Draw", NULL, 0, &argc, argv);
  
  panel = XtCreateManagedWidget("panel", xmBulletinBoardWidgetClass, 
				toplevel, NULL, 0);

  commands = XtCreateManagedWidget("commands", xmRowColumnWidgetClass, 
				   panel, NULL, 0);

  canvas = XtCreateManagedWidget("canvas", xmDrawingAreaWidgetClass, 
				 panel, NULL, 0);

  options = XtCreateManagedWidget("options",xmRowColumnWidgetClass , 
				  panel, NULL, 0);

  XtCreateManagedWidget("button1", xmPushButtonWidgetClass, 
			commands, NULL, 0);
  XtCreateManagedWidget("button2", xmPushButtonWidgetClass, 
			commands, NULL, 0);
  XtCreateManagedWidget("button3", xmPushButtonWidgetClass, 
			commands, NULL, 0);
  XtCreateManagedWidget("button1", xmPushButtonWidgetClass, 
			options, NULL, 0);
  XtCreateManagedWidget("button2", xmPushButtonWidgetClass, 
			options, NULL, 0);
  XtCreateManagedWidget("button3", xmPushButtonWidgetClass, 
			options, NULL, 0);
  
  XtRealizeWidget(toplevel);
  
  XtMainLoop();
}

@EOF

chmod 644 ch3/draw.c

echo x - ch3/rmtest3.c
cat >ch3/rmtest3.c <<'@EOF'
/**********************************************************************************
  * rmtest3.c: floating point version.
  *         From:
  *                   The X Window System, 
  *            Programming and Applications with Xt
  *                   OSF/Motif Edition
  *         by
  *                Douglas Young
  *              Prentice Hall, 1990
  *
  *                 Example described on pages:     62-64
  *
  *
  *  Copyright 1989 by Prentice Hall
  *  All Rights Reserved
  *
  * This code is based on the OSF/Motif widget set and the X Window System
  *
  * Permission to use, copy, modify, and distribute this software for 
  * any purpose and without fee is hereby granted, provided that the above
  * copyright notice appear in all copies and that both the copyright notice
  * and this permission notice appear in supporting documentation.
  *
  * Prentice Hall and the author disclaim all warranties with regard to 
  * this software, including all implied warranties of merchantability and fitness.
  * In no event shall Prentice Hall or the author be liable for any special,
  * indirect or cosequential damages or any damages whatsoever resulting from 
  * loss of use, data or profits, whether in an action of contract, negligence 
  * or other tortious action, arising out of or in connection with the use 
  * or performance of this software.
  *
  * Open Software Foundation is a trademark of The Open Software Foundation, Inc.
  * OSF is a trademark of Open Software Foundation, Inc.
  * OSF/Motif is a trademark of Open Software Foundation, Inc.
  * Motif is a trademark of Open Software Foundation, Inc.
  * DEC is a registered trademark of Digital Equipment Corporation
  * HP is a registered trademark of the Hewlett Packard Company
  * DIGITAL is a registered trademark of Digital Equipment Corporation
  * X Window System is a trademark of the Massachusetts Institute of Technology
  **********************************************************************************/





#include <X11/Intrinsic.h>
#include <X11/StringDefs.h>
#include "libXs.h"

typedef struct {
   Pixel    fg, bg;
   float    delay;
   Boolean  verbose;
} ApplicationData, *ApplicationDataPtr;

static XtResource resources[] = {
  { XtNforeground, XtCForeground, XtRPixel, sizeof (Pixel),
    XtOffset(ApplicationDataPtr, fg), XtRString, "Black"    },
  { XtNbackground, XtCBackground, XtRPixel, sizeof (Pixel),
    XtOffset(ApplicationDataPtr, bg), XtRString, "White"    },
  { "delay", "Delay", XtRFloat, sizeof (float),
    XtOffset(ApplicationDataPtr, delay), XtRString,"2.5"    },
  { "verbose", "Verbose", XtRBoolean, sizeof (Boolean),
    XtOffset(ApplicationDataPtr,verbose), XtRString, "FALSE"},
  };

static XrmOptionDescRec options[] = { 
 {"-verbose", "*verbose", XrmoptionNoArg, "TRUE"},
 {"-delay",   "*delay",   XrmoptionSepArg, NULL}
};

main(argc, argv)
    int   argc;
    char *argv[];
 {
  Widget          toplevel;
  ApplicationData data;
  toplevel = XtInitialize(argv[0], "Rmtest", options, 
                          XtNumber(options), &argc, argv);
  /*
   *   Add the string to float type-converter.
   */
  XtAddConverter(XtRString, XtRFloat, xs_cvt_str_to_float,
                 NULL, 0);
  /*
   *  Retrieve the resources.
   */
  XtGetApplicationResources(toplevel, &data, resources, 
                            XtNumber(resources), NULL, 0);
  /*
   * Print the result.
   */
  printf("fg = %d, bg = %d, delay = %f, verbose = %d\n", 
         data.fg, data.bg, data.delay, data.verbose);
 }
@EOF

chmod 644 ch3/rmtest3.c

chmod 775 ch3

echo mkdir - ch4
mkdir ch4

echo x - ch4/Makefile
cat >ch4/Makefile <<'@EOF'
CC = cc 
XSLIBDIR = ../lib
DEBUG = 
# HP Machines
CFLAGS = $(DEBUG) -DSYSV  -I$(XSLIBDIR) 
# DEC and Sun
#CFLAGS = $(DEBUG) -I$(XSLIBDIR)

LIBS = ../lib/libXs.a -lXm -lXt -lX11

.o:.c

all: generic twoshells pushbutton formedit chooseone \
     rctest traverse formtest formtest1 menu menu2 \
     menu3 dialog helptest

generic : generic.o
	$(CC) $(CFLAGS) -o $@ $@.o $(LIBS)
dialog : dialog.o
	$(CC) $(CFLAGS) -o $@ $@.o $(LIBS)
twoshells : twoshells.o
	$(CC) $(CFLAGS) -o $@ $@.o $(LIBS)
pushbutton : pushbutton.o
	$(CC) $(CFLAGS) -o $@ $@.o $(LIBS)
formedit : formedit.o
	$(CC) $(CFLAGS) -o $@ $@.o $(LIBS)
rctest : rctest.o
	$(CC) $(CFLAGS) -o $@ $@.o $(LIBS)
traverse : traverse.o
	$(CC) $(CFLAGS) -o $@ $@.o $(LIBS)
formtest : formtest.o
	$(CC) $(CFLAGS) -o $@ $@.o $(LIBS)
formtest1 : formtest1.o
	$(CC) $(CFLAGS) -o $@ $@.o $(LIBS)
helptest : helptest.o
	$(CC) $(CFLAGS) -o $@ $@.o $(LIBS)
menu : menu.o
	$(CC) $(CFLAGS) -o $@ $@.o $(LIBS)
menu2 : menu2.o
	$(CC) $(CFLAGS) -o $@ $@.o $(LIBS)
menu3 :: menu3.o
	$(CC) $(CFLAGS) -o $@ $@.o $(LIBS)
chooseone :: chooseone.o
	$(CC) $(CFLAGS) -o $@ $@.o $(LIBS)
@EOF

chmod 644 ch4/Makefile

echo x - ch4/generic.c
cat >ch4/generic.c <<'@EOF'
/**********************************************************************************
  * generic.c: Test the Core widget class
  *         From:
  *                   The X Window System, 
  *            Programming and Applications with Xt
  *                   OSF/Motif Edition
  *         by
  *                Douglas Young
  *              Prentice Hall, 1990
  *
  *                 Example described on pages:      69
  *
  *
  *  Copyright 1989 by Prentice Hall
  *  All Rights Reserved
  *
  * This code is based on the OSF/Motif widget set and the X Window System
  *
  * Permission to use, copy, modify, and distribute this software for 
  * any purpose and without fee is hereby granted, provided that the above
  * copyright notice appear in all copies and that both the copyright notice
  * and this permission notice appear in supporting documentation.
  *
  * Prentice Hall and the author disclaim all warranties with regard to 
  * this software, including all implied warranties of merchantability and fitness.
  * In no event shall Prentice Hall or the author be liable for any special,
  * indirect or cosequential damages or any damages whatsoever resulting from 
  * loss of use, data or profits, whether in an action of contract, negligence 
  * or other tortious action, arising out of or in connection with the use 
  * or performance of this software.
  *
  * Open Software Foundation is a trademark of The Open Software Foundation, Inc.
  * OSF is a trademark of Open Software Foundation, Inc.
  * OSF/Motif is a trademark of Open Software Foundation, Inc.
  * Motif is a trademark of Open Software Foundation, Inc.
  * DEC is a registered trademark of Digital Equipment Corporation
  * HP is a registered trademark of the Hewlett Packard Company
  * DIGITAL is a registered trademark of Digital Equipment Corporation
  * X Window System is a trademark of the Massachusetts Institute of Technology
  **********************************************************************************/



#include <X11/Intrinsic.h> 

main(argc, argv)
  int   argc;
  char *argv[];
{
  Widget toplevel;
  /*
   * Initialize the Intrinsics.
   */
  toplevel = XtInitialize(argv[0], "Generic", NULL, 0, 
                          &argc, argv);
  /*
   * Create a Core widget.
   */
  XtCreateManagedWidget("widget", widgetClass, 
                        toplevel, NULL, 0);
  XtRealizeWidget(toplevel);
  XtMainLoop();
}
@EOF

chmod 644 ch4/generic.c

echo x - ch4/twoshells.c
cat >ch4/twoshells.c <<'@EOF'
/**********************************************************************************
  * twoshells.c: Example of two independent top-level shells
  *         From:
  *                   The X Window System, 
  *            Programming and Applications with Xt
  *                   OSF/Motif Edition
  *         by
  *                Douglas Young
  *              Prentice Hall, 1990
  *
  *                 Example described on pages:     71
  *
  *
  *  Copyright 1989 by Prentice Hall
  *  All Rights Reserved
  *
  * This code is based on the OSF/Motif widget set and the X Window System
  *
  * Permission to use, copy, modify, and distribute this software for 
  * any purpose and without fee is hereby granted, provided that the above
  * copyright notice appear in all copies and that both the copyright notice
  * and this permission notice appear in supporting documentation.
  *
  * Prentice Hall and the author disclaim all warranties with regard to 
  * this software, including all implied warranties of merchantability and fitness.
  * In no event shall Prentice Hall or the author be liable for any special,
  * indirect or cosequential damages or any damages whatsoever resulting from 
  * loss of use, data or profits, whether in an action of contract, negligence 
  * or other tortious action, arising out of or in connection with the use 
  * or performance of this software.
  *
  * Open Software Foundation is a trademark of The Open Software Foundation, Inc.
  * OSF is a trademark of Open Software Foundation, Inc.
  * OSF/Motif is a trademark of Open Software Foundation, Inc.
  * Motif is a trademark of Open Software Foundation, Inc.
  * DEC is a registered trademark of Digital Equipment Corporation
  * HP is a registered trademark of the Hewlett Packard Company
  * DIGITAL is a registered trademark of Digital Equipment Corporation
  * X Window System is a trademark of the Massachusetts Institute of Technology
  **********************************************************************************/


#include <X11/Intrinsic.h>
#include <X11/Shell.h> 

main(argc, argv)
    int   argc;
    char *argv[];
{
  Widget toplevel, shell2;
  /*
   * Initialize the Intrinsics, create one TopLevelShell.
   */
  toplevel = XtInitialize(argv[0], "Generic", NULL, 0, 
                          &argc, argv);
  /*
   * Create a second TopLevelShell widget. 
   */
  shell2= XtCreateApplicationShell("Window2",
                                   topLevelShellWidgetClass,
                                   NULL, 0);
  /*
   * Create a Core widget as a child of each shell.
   */
  XtCreateManagedWidget("Widget", widgetClass, 
                        toplevel, NULL, 0);
  XtCreateManagedWidget("Widget2", widgetClass, 
                        shell2, NULL, 0);
  /*
   * Realize both shell widgets.
   */
   XtRealizeWidget(toplevel);
  XtRealizeWidget(shell2);
  XtMainLoop();
}
@EOF

chmod 644 ch4/twoshells.c

echo x - ch4/chooseone.c
cat >ch4/chooseone.c <<'@EOF'
/**********************************************************************************
  * chooseone.c: Test a list widget
  *         From:
  *                   The X Window System, 
  *            Programming and Applications with Xt
  *                   OSF/Motif Edition
  *         by
  *                Douglas Young
  *              Prentice Hall, 1990
  *
  *                 Example described on pages:      93-96
  *
  *
  *  Copyright 1989 by Prentice Hall
  *  All Rights Reserved
  *
  * This code is based on the OSF/Motif widget set and the X Window System
  *
  * Permission to use, copy, modify, and distribute this software for 
  * any purpose and without fee is hereby granted, provided that the above
  * copyright notice appear in all copies and that both the copyright notice
  * and this permission notice appear in supporting documentation.
  *
  * Prentice Hall and the author disclaim all warranties with regard to 
  * this software, including all implied warranties of merchantability and fitness.
  * In no event shall Prentice Hall or the author be liable for any special,
  * indirect or cosequential damages or any damages whatsoever resulting from 
  * loss of use, data or profits, whether in an action of contract, negligence 
  * or other tortious action, arising out of or in connection with the use 
  * or performance of this software.
  *
  * Open Software Foundation is a trademark of The Open Software Foundation, Inc.
  * OSF is a trademark of Open Software Foundation, Inc.
  * OSF/Motif is a trademark of Open Software Foundation, Inc.
  * Motif is a trademark of Open Software Foundation, Inc.
  * DEC is a registered trademark of Digital Equipment Corporation
  * HP is a registered trademark of the Hewlett Packard Company
  * DIGITAL is a registered trademark of Digital Equipment Corporation
  * X Window System is a trademark of the Massachusetts Institute of Technology
  **********************************************************************************/



#include <X11/StringDefs.h>
#include <X11/Intrinsic.h>
#include <X11/Shell.h>
#include <Xm/Xm.h>
#include <Xm/List.h>

static void browse_callback();

main(argc, argv)
     int   argc;
     char *argv[];

{
  Widget    toplevel, list;
  Arg       wargs[10];
  int       n, i;
  XmString *xmstr;
  /*
   * Initialize the Intrinsics
   */  
  toplevel = XtInitialize (argv[0], "Chooseone", NULL, 0, 
                           &argc, argv);
  if(argc <= 1){
    XtCloseDisplay(XtDisplay(toplevel));
     exit(-1);
  }
 /*
  * Convert all command line arguments to an array of
  * type XmString, ignoring argv[0].
  */
  xmstr = (XmString *) XtMalloc(sizeof(XmString) * argc - 1);
  for(i = 1; i < argc; i++)
    xmstr[i - 1] = XmStringCreate(argv[i],
                                  XmSTRING_DEFAULT_CHARSET);
  /*
   * Create the list widget and register a browse callback.
   */
  n = 0;
  XtSetArg(wargs[n], XmNitems, xmstr); n++;  
  XtSetArg(wargs[n], XmNitemCount, argc - 1); n++;
  list = XtCreateManagedWidget("list", 
                               xmListWidgetClass, 
                               toplevel, wargs, n);
  XtAddCallback(list, XmNbrowseSelectionCallback,
                browse_callback, NULL);

  XtRealizeWidget (toplevel);
  XtMainLoop();
}

static void browse_callback(w, client_data, call_data)
   Widget     w;
   caddr_t    *client_data;
   XmListCallbackStruct *call_data;
{
  char *text;
  XmStringGetLtoR (call_data->item, XmSTRING_DEFAULT_CHARSET,
                   &text);
  printf("%s\n", text);
  XtCloseDisplay(XtDisplay(w));
  exit(0);
}
@EOF

chmod 664 ch4/chooseone.c

echo x - ch4/pushbutton.c
cat >ch4/pushbutton.c <<'@EOF'
/**********************************************************************************
  * pushbutton.c: Test the XmPushButton widget.
  *         From:
  *                   The X Window System, 
  *            Programming and Applications with Xt
  *                   OSF/Motif Edition
  *         by
  *                Douglas Young
  *              Prentice Hall, 1990
  *
  *                 Example described on pages:     75-76
  *
  *
  *  Copyright 1989 by Prentice Hall
  *  All Rights Reserved
  *
  * This code is based on the OSF/Motif widget set and the X Window System
  *
  * Permission to use, copy, modify, and distribute this software for 
  * any purpose and without fee is hereby granted, provided that the above
  * copyright notice appear in all copies and that both the copyright notice
  * and this permission notice appear in supporting documentation.
  *
  * Prentice Hall and the author disclaim all warranties with regard to 
  * this software, including all implied warranties of merchantability and fitness.
  * In no event shall Prentice Hall or the author be liable for any special,
  * indirect or cosequential damages or any damages whatsoever resulting from 
  * loss of use, data or profits, whether in an action of contract, negligence 
  * or other tortious action, arising out of or in connection with the use 
  * or performance of this software.
  *
  * Open Software Foundation is a trademark of The Open Software Foundation, Inc.
  * OSF is a trademark of Open Software Foundation, Inc.
  * OSF/Motif is a trademark of Open Software Foundation, Inc.
  * Motif is a trademark of Open Software Foundation, Inc.
  * DEC is a registered trademark of Digital Equipment Corporation
  * HP is a registered trademark of the Hewlett Packard Company
  * DIGITAL is a registered trademark of Digital Equipment Corporation
  * X Window System is a trademark of the Massachusetts Institute of Technology
  **********************************************************************************/



#include <X11/Intrinsic.h>
#include <X11/StringDefs.h>
#include <Xm/Xm.h> 
#include <Xm/PushB.h>

extern void button_callback();

main(argc, argv) 
    int   argc;
    char *argv[];
{
  Widget toplevel, button;
  toplevel = XtInitialize(argv[0], "Pushbutton", 
                          NULL, 0, &argc, argv); 
  /* 
   * Create the pushbutton widget. 
   */ 
  button =  XtCreateManagedWidget("button",
                                   xmPushButtonWidgetClass,
                                   toplevel, NULL, 0);
  /*  
   * Add callbacks. 
   */ 
  XtAddCallback(button, XmNactivateCallback,
                button_callback, NULL);
  XtAddCallback(button, XmNarmCallback, 
                button_callback, NULL);
  XtAddCallback(button, XmNdisarmCallback, 
                button_callback, NULL); 
  XtRealizeWidget(toplevel);
  XtMainLoop();
}

void button_callback(w, client_data, call_data) 
   Widget               w;  
   caddr_t              client_data; 
   XmAnyCallbackStruct *call_data;
  { 
    switch(call_data->reason){
      case XmCR_ACTIVATE:
        printf("Button activated\n"); 
        break;
      case XmCR_ARM:
        printf("Button armed\n"); 
        break;
     case XmCR_DISARM:
       printf("Button disarmed\n");
       break;
    } 
}
@EOF

chmod 644 ch4/pushbutton.c

echo x - ch4/formedit.c
cat >ch4/formedit.c <<'@EOF'
/**********************************************************************************
  * formedit.c: Simple example of multiple edit fields managed
  *             by an XmBulletinBoard widget. 
  *         From:
  *                   The X Window System, 
  *            Programming and Applications with Xt
  *                   OSF/Motif Edition
  *         by
  *                Douglas Young
  *              Prentice Hall, 1990
  *
  *                 Example described on pages:      81-83
  *
  *
  *  Copyright 1989 by Prentice Hall
  *  All Rights Reserved
  *
  * This code is based on the OSF/Motif widget set and the X Window System
  *
  * Permission to use, copy, modify, and distribute this software for 
  * any purpose and without fee is hereby granted, provided that the above
  * copyright notice appear in all copies and that both the copyright notice
  * and this permission notice appear in supporting documentation.
  *
  * Prentice Hall and the author disclaim all warranties with regard to 
  * this software, including all implied warranties of merchantability and fitness.
  * In no event shall Prentice Hall or the author be liable for any special,
  * indirect or cosequential damages or any damages whatsoever resulting from 
  * loss of use, data or profits, whether in an action of contract, negligence 
  * or other tortious action, arising out of or in connection with the use 
  * or performance of this software.
  *
  * Open Software Foundation is a trademark of The Open Software Foundation, Inc.
  * OSF is a trademark of Open Software Foundation, Inc.
  * OSF/Motif is a trademark of Open Software Foundation, Inc.
  * Motif is a trademark of Open Software Foundation, Inc.
  * DEC is a registered trademark of Digital Equipment Corporation
  * HP is a registered trademark of the Hewlett Packard Company
  * DIGITAL is a registered trademark of Digital Equipment Corporation
  * X Window System is a trademark of the Massachusetts Institute of Technology
  **********************************************************************************/


#include <X11/Intrinsic.h>
#include <Xm/Xm.h>
#include <Xm/Text.h>
#include <Xm/PushB.h>
#include <Xm/BulletinB.h>
#include "libXs.h"

void get_text();
char *buttons[] = {"button1", "button2", "button3"};
char *editors[] = {"field1", "field2", "field3"};

main(argc, argv)
   int   argc;
   char *argv[];
{
  Widget toplevel, bb, edit[3], button[3];
  int    i;
  toplevel = XtInitialize(argv[0], "Formedit",
                          NULL, 0 , &argc, argv);
  /*
   * Create the XmBulletinBoard widget that manages
   * the edit fields.
   */
  bb = XtCreateManagedWidget("board", 
                             xmBulletinBoardWidgetClass,
                             toplevel, NULL,0);
  /*
   * Create three single line XmEdit widgets
   * and associate a button with each text widget.
   * Assign an XmNactivateCallback callback to each button.
   */
  for(i=0; i < XtNumber(editors); i++)
     edit[i] = XtCreateWidget(editors[i], 
                              xmTextWidgetClass,
                              bb, NULL, 0);
  for(i=0; i < XtNumber(buttons); i++){
     button[i] = XtCreateWidget(buttons[i],
                                xmPushButtonWidgetClass,
                                bb, NULL, 0);
     XtAddCallback(button[i], XmNactivateCallback, 
                   get_text, edit[i]);
  }
  XtManageChildren(edit, XtNumber(editors));
  XtManageChildren(button, XtNumber(buttons));

  XtRealizeWidget(toplevel);
  XtMainLoop();
}

void get_text(w, textwidget, call_value)
   Widget   w;
   Widget   textwidget;
   XmAnyCallbackStruct *call_value;
{
 printf("retrieving text: %s\n", XmTextGetString(textwidget));
}
@EOF

chmod 644 ch4/formedit.c

echo x - ch4/formtest.c
cat >ch4/formtest.c <<'@EOF'
/**********************************************************************************
  * formtest.c: Test the constraints of the XmForm Widget
  *         From:
  *                   The X Window System, 
  *            Programming and Applications with Xt
  *                   OSF/Motif Edition
  *         by
  *                Douglas Young
  *              Prentice Hall, 1990
  *
  *                 Example described on pages:      88-92
  *
  *
  *  Copyright 1989 by Prentice Hall
  *  All Rights Reserved
  *
  * This code is based on the OSF/Motif widget set and the X Window System
  *
  * Permission to use, copy, modify, and distribute this software for 
  * any purpose and without fee is hereby granted, provided that the above
  * copyright notice appear in all copies and that both the copyright notice
  * and this permission notice appear in supporting documentation.
  *
  * Prentice Hall and the author disclaim all warranties with regard to 
  * this software, including all implied warranties of merchantability and fitness.
  * In no event shall Prentice Hall or the author be liable for any special,
  * indirect or cosequential damages or any damages whatsoever resulting from 
  * loss of use, data or profits, whether in an action of contract, negligence 
  * or other tortious action, arising out of or in connection with the use 
  * or performance of this software.
  *
  * Open Software Foundation is a trademark of The Open Software Foundation, Inc.
  * OSF is a trademark of Open Software Foundation, Inc.
  * OSF/Motif is a trademark of Open Software Foundation, Inc.
  * Motif is a trademark of Open Software Foundation, Inc.
  * DEC is a registered trademark of Digital Equipment Corporation
  * HP is a registered trademark of the Hewlett Packard Company
  * DIGITAL is a registered trademark of Digital Equipment Corporation
  * X Window System is a trademark of the Massachusetts Institute of Technology
  **********************************************************************************/

#include <X11/Intrinsic.h> 
#include <Xm/Xm.h>
#include <Xm/Form.h>
#include <Xm/PushB.h>

char * buttons[] = {"button1", "button2", "button3"};

main(argc, argv)
     int   argc;
     char *argv[];
{
  Widget toplevel, form, wbutton[5];
  int    i, n;
  Arg wargs[10];
  toplevel = XtInitialize(argv[0], "Formtest", NULL, 0, 
                          &argc, argv);

  /*
   * Create an XmForm manager widget
   */
  form = XtCreateManagedWidget("form", xmFormWidgetClass, 
                               toplevel, NULL,0);
  /*
   * Add three XmPushButton widgets to the Form Widget.
   */
  for(i=0;i< XtNumber(buttons); i++)
    wbutton[i] = XtCreateWidget(buttons[i],
                                xmPushButtonWidgetClass, 
                                form, NULL,0);
  XtManageChildren(wbutton, XtNumber(buttons));
  /*
   * Set constraint resources for each button, setting up
   * a shape like this:
   *          button one
   *          button two
   *          button three
   */
  n = 0;
  XtSetArg(wargs[n], XmNtopAttachment,   XmATTACH_FORM); n++;
  XtSetArg(wargs[n], XmNleftAttachment,  XmATTACH_FORM); n++;
  XtSetArg(wargs[n], XmNrightAttachment, XmATTACH_FORM); n++;
  XtSetValues(wbutton[0], wargs, n);
  n = 0;
  XtSetArg(wargs[n], XmNtopAttachment,   XmATTACH_WIDGET);n++;
  XtSetArg(wargs[n], XmNtopWidget,       wbutton[0]);     n++;
  XtSetArg(wargs[n], XmNleftAttachment,  XmATTACH_FORM);  n++;
  XtSetArg(wargs[n], XmNrightAttachment, XmATTACH_FORM);  n++;
  XtSetValues(wbutton[1], wargs, n);
  n = 0;
  XtSetArg(wargs[n], XmNtopAttachment,   XmATTACH_WIDGET);n++;
  XtSetArg(wargs[n], XmNtopWidget,       wbutton[1]);     n++;
  XtSetArg(wargs[n], XmNleftAttachment,  XmATTACH_FORM);  n++;
  XtSetArg(wargs[n], XmNrightAttachment, XmATTACH_FORM);  n++;
  XtSetArg(wargs[n], XmNbottomAttachment,XmATTACH_FORM);  n++;
  XtSetValues(wbutton[2], wargs, n);

  XtRealizeWidget(toplevel);
  XtMainLoop();
}
@EOF

chmod 644 ch4/formtest.c

echo x - ch4/menu.c
cat >ch4/menu.c <<'@EOF'
/**********************************************************************************
  * menu.c: First pop up menu example
  *         From:
  *                   The X Window System, 
  *            Programming and Applications with Xt
  *                   OSF/Motif Edition
  *         by
  *                Douglas Young
  *              Prentice Hall, 1990
  *
  *                 Example described on pages:     99-101
  *
  *
  *  Copyright 1989 by Prentice Hall
  *  All Rights Reserved
  *
  * This code is based on the OSF/Motif widget set and the X Window System
  *
  * Permission to use, copy, modify, and distribute this software for 
  * any purpose and without fee is hereby granted, provided that the above
  * copyright notice appear in all copies and that both the copyright notice
  * and this permission notice appear in supporting documentation.
  *
  * Prentice Hall and the author disclaim all warranties with regard to 
  * this software, including all implied warranties of merchantability and fitness.
  * In no event shall Prentice Hall or the author be liable for any special,
  * indirect or cosequential damages or any damages whatsoever resulting from 
  * loss of use, data or profits, whether in an action of contract, negligence 
  * or other tortious action, arising out of or in connection with the use 
  * or performance of this software.
  *
  * Open Software Foundation is a trademark of The Open Software Foundation, Inc.
  * OSF is a trademark of Open Software Foundation, Inc.
  * OSF/Motif is a trademark of Open Software Foundation, Inc.
  * Motif is a trademark of Open Software Foundation, Inc.
  * DEC is a registered trademark of Digital Equipment Corporation
  * HP is a registered trademark of the Hewlett Packard Company
  * DIGITAL is a registered trademark of Digital Equipment Corporation
  * X Window System is a trademark of the Massachusetts Institute of Technology
  **********************************************************************************/


#include <X11/Intrinsic.h>
#include <X11/Shell.h>
#include <Xm/Xm.h>
#include <Xm/Label.h>
#include <Xm/RowColumn.h>
#include <Xm/PushB.h>
#include <Xm/Separator.h>
#include <Xm/BulletinB.h>
#include <Xm/CascadeB.h>

extern void post_menu_handler ();

void do_it(w, client_data, call_data)
     Widget   w;
     char    *client_data;
     caddr_t  call_data;
{
  printf("%s selected\n", client_data);
}

main(argc, argv)
     int   argc;
     char *argv[];
{
  Widget toplevel, button, bboard, menu, button1,
         button2, button3, submenu, button2a, button2b;
  Arg wargs[10];
  /*
   * Initialize the Intrinsics and create a BulletinBoard 
   * widget to be the primary widget in the program.
   */  
  toplevel = XtInitialize (argv[0], "MenuTest", NULL, 0, 
                           &argc, argv);
  bboard = XtCreateManagedWidget("bboard", 
                                 xmBulletinBoardWidgetClass, 
                                 toplevel, NULL, 0);
  /*
   * Step 1. Create a popup menu. Add an event handler
   * To the BulletinBoard widget to pop up the menu when
   * a mouse button is pressed.
   */
  menu = XmCreatePopupMenu(bboard, "menu", NULL, 0);
  XtAddEventHandler(bboard, ButtonPressMask, FALSE,
                    post_menu_handler, menu);
  /*
   * Step 2. Add buttons, labels, and separators to the pane.
   * Step 3. Register callbacks to define the action
   *         associated with each menu entry.
   */
  XtCreateManagedWidget("Title", xmLabelWidgetClass, menu,
                         NULL, 0);
  XtCreateManagedWidget("separator", xmSeparatorWidgetClass,
                        menu, NULL, 0);
  button1 = XtCreateManagedWidget("Item1",
                                  xmPushButtonWidgetClass,
                                  menu, NULL, 0);
  XtAddCallback (button1, XmNactivateCallback, 
                 do_it, "Item1");
  /*
   * Add an XmCascadeButton widget to support a submenu.
   */
  button2 = XtCreateManagedWidget("Item2",
                                  xmCascadeButtonWidgetClass, 
                                  menu, NULL, 0);
  button3 = XtCreateManagedWidget("Item3",
                                  xmPushButtonWidgetClass,
                                  menu, NULL, 0);
  XtAddCallback (button3, XmNactivateCallback, 
                 do_it, "Item3");
  /*
   * To Create a cascading menu pane:
   *         Create a pulldown menu pane and attach it to the
   *         XmCascadeButton widget.
   */
  submenu = XmCreatePulldownMenu(menu, "submenu", NULL, 0);
  XtSetArg(wargs[0], XmNsubMenuId, submenu);
  XtSetValues(button2, wargs, 1);
  /*
   * Add buttons the submenu.
   */
  button2a = XtCreateManagedWidget("Item2a",
                                   xmPushButtonWidgetClass,
                                   submenu, NULL, 0);
  XtAddCallback (button2a, XmNactivateCallback, 
                 do_it, "Item2a");  
  button2b = XtCreateManagedWidget("Item2b",
                                   xmPushButtonWidgetClass,
                                   submenu, NULL, 0);
  XtAddCallback (button2b, XmNactivateCallback, 
                 do_it, "Item2b");
  
  XtRealizeWidget (toplevel);
  XtMainLoop();
}

void post_menu_handler (w, menu, event)
   Widget  w;
   Widget  menu;
   XEvent *event;
{
  Arg wargs[10];
  int button;
  /*
   * Make sure the button that caused this event was the one
   * the menupane uses for menu item selection.
   */  
  XtSetArg(wargs[0], XmNwhichButton, &button);
  XtGetValues(menu, wargs, 1);
  if (event->xbutton.button == button){
   /*
    * Position the menu over the sprite and post the menu.
    */
    XmMenuPosition(menu, event);
    XtManageChild(menu);
  }
}

@EOF

chmod 644 ch4/menu.c

echo x - ch4/menu2.c
cat >ch4/menu2.c <<'@EOF'
/**********************************************************************************
  * menu.c: pop up menu example using libXs menu functions
  *         From:
  *                   The X Window System, 
  *            Programming and Applications with Xt
  *                   OSF/Motif Edition
  *         by
  *                Douglas Young
  *              Prentice Hall, 1990
  *
  *                 Example described on pages:     102-103
  *
  *
  *  Copyright 1989 by Prentice Hall
  *  All Rights Reserved
  *
  * This code is based on the OSF/Motif widget set and the X Window System
  *
  * Permission to use, copy, modify, and distribute this software for 
  * any purpose and without fee is hereby granted, provided that the above
  * copyright notice appear in all copies and that both the copyright notice
  * and this permission notice appear in supporting documentation.
  *
  * Prentice Hall and the author disclaim all warranties with regard to 
  * this software, including all implied warranties of merchantability and fitness.
  * In no event shall Prentice Hall or the author be liable for any special,
  * indirect or cosequential damages or any damages whatsoever resulting from 
  * loss of use, data or profits, whether in an action of contract, negligence 
  * or other tortious action, arising out of or in connection with the use 
  * or performance of this software.
  *
  * Open Software Foundation is a trademark of The Open Software Foundation, Inc.
  * OSF is a trademark of Open Software Foundation, Inc.
  * OSF/Motif is a trademark of Open Software Foundation, Inc.
  * Motif is a trademark of Open Software Foundation, Inc.
  * DEC is a registered trademark of Digital Equipment Corporation
  * HP is a registered trademark of the Hewlett Packard Company
  * DIGITAL is a registered trademark of Digital Equipment Corporation
  * X Window System is a trademark of the Massachusetts Institute of Technology
  **********************************************************************************/

#include <X11/StringDefs.h>
#include <X11/Intrinsic.h>
#include <Xm/Xm.h>
#include <Xm/RowColumn.h>
#include <Xm/BulletinB.h>
#include "libXs.h"

extern void post_menu_handler ();
extern void do_it();
/* 
 * Describe the list of menu items for a submenu pane.
 */
static xs_menu_struct sub_menu_a[] = {
  {"Item 2 A" , do_it, "Item 2 A"},
  {"Item 2 B" , do_it, "Item 2 B"}
};
/*
 * Describe the main menu pane.
 */
static xs_menu_struct MenuData[] = {
  { "Item 1" , do_it, "Item One",   
     NULL, 0, NULL },
  { "Item 2" , NULL, "Item Two", 
     sub_menu_a, XtNumber(sub_menu_a), "SubMenuA" },
  { "Item 3" , do_it, "Item Three", 
     NULL, 0 , NULL }
};

main(argc, argv)
     int   argc;
     char *argv[];
{
  Widget toplevel, bboard, popup_menu;
 /*
  * Initialize the Intrinsics and create a top level widget.
  */
  toplevel = XtInitialize (argv[0], "MenuTest", NULL, 0, 
                           &argc, argv);
  bboard = XtCreateManagedWidget("bboard", 
                                 xmBulletinBoardWidgetClass, 
                                 toplevel, NULL, 0);
  /*
   * Step 1. Create a popup menu pane and define an event    
   *         handler to pop it up.
   */
  popup_menu = XmCreatePopupMenu(bboard, "menu", NULL, 0);
  XtAddEventHandler(bboard, ButtonPressMask, FALSE,
                    post_menu_handler, popup_menu);
  /*
   * Step 2. Create the menu entries from the description.
   */
  xs_create_menu_buttons("Menu", popup_menu, 
                         MenuData, XtNumber(MenuData));
  XtRealizeWidget (toplevel);
  XtMainLoop();
}

void do_it(w, client_data, call_data)
     Widget   w;
     char    *client_data;
     caddr_t  call_data;
{
  printf("%s selected\n", client_data);
}


void post_menu_handler (w, menu, event)
   Widget  w;
   Widget  menu;
   XEvent *event;
{
  Arg wargs[10];
  int button;
  /*
   * Make sure the button that caused this event was the one
   * the menupane uses for menu item selection.
   */  
  XtSetArg(wargs[0], XmNwhichButton, &button);
  XtGetValues(menu, wargs, 1);
  if (event->xbutton.button == button){
   /*
    * Position the menu over the sprite and post the menu.
    */
    XmMenuPosition(menu, event);
    XtManageChild(menu);
  }
}

@EOF

chmod 644 ch4/menu2.c

echo x - ch4/menu3.c
cat >ch4/menu3.c <<'@EOF'
/**********************************************************************************
 * menu3.c: pulldown menu example
  *         From:
  *                   The X Window System, 
  *            Programming and Applications with Xt
  *                   OSF/Motif Edition
  *         by
  *                Douglas Young
  *              Prentice Hall, 1990
  *
  *                 Example described on pages:     107-109
  *
  *
  *  Copyright 1989 by Prentice Hall
  *  All Rights Reserved
  *
  * This code is based on the OSF/Motif widget set and the X Window System
  *
  * Permission to use, copy, modify, and distribute this software for 
  * any purpose and without fee is hereby granted, provided that the above
  * copyright notice appear in all copies and that both the copyright notice
  * and this permission notice appear in supporting documentation.
  *
  * Prentice Hall and the author disclaim all warranties with regard to 
  * this software, including all implied warranties of merchantability and fitness.
  * In no event shall Prentice Hall or the author be liable for any special,
  * indirect or cosequential damages or any damages whatsoever resulting from 
  * loss of use, data or profits, whether in an action of contract, negligence 
  * or other tortious action, arising out of or in connection with the use 
  * or performance of this software.
  *
  * Open Software Foundation is a trademark of The Open Software Foundation, Inc.
  * OSF is a trademark of Open Software Foundation, Inc.
  * OSF/Motif is a trademark of Open Software Foundation, Inc.
  * Motif is a trademark of Open Software Foundation, Inc.
  * DEC is a registered trademark of Digital Equipment Corporation
  * HP is a registered trademark of the Hewlett Packard Company
  * DIGITAL is a registered trademark of Digital Equipment Corporation
  * X Window System is a trademark of the Massachusetts Institute of Technology
  **********************************************************************************/

#include <X11/StringDefs.h>
#include <X11/Intrinsic.h>
#include <Xm/Xm.h>
#include <Xm/RowColumn.h>
#include <Xm/BulletinB.h>
#include "libXs.h"

extern void do_it();

/*
 * Create the list of menu items for a sub menu pane.
 */
static xs_menu_struct sub_menu_a[] = {
  {"Item 2 A", do_it, "Item 2 A"},
  {"Item 2 B", do_it, "Item 2 B"}
};
/*
 * Describe pulldown pane one.
 */
static xs_menu_struct MenuData[] = {
  {"Item 1", do_it, "Item One",  NULL, 0, NULL},
  {"Item 2", NULL,     "Item Two",  sub_menu_a,
      XtNumber(sub_menu_a), "SubMenuA"},
  {"Item 3", do_it, "Item Three", NULL, 0 , NULL}
};
/*
 * Describe pulldown pane two.
 */
static xs_menu_struct Menu2Data[] = {
  {"Item 2-1", do_it, "Iten 2-One",   NULL, 0, NULL},
  {"Item 2-2", do_it, "Item 2-Two",   NULL, 0, NULL},
  {"Item 2-3", do_it, "Item 2-Three", NULL, 0 ,NULL}
};
/*
 * Describe the menu bar, giving only the names to appear in
 * the menu bar and pointers to each pulldown pane.
 */
static xs_menu_struct PulldownData[] = {
  {"Menu One" , NULL,  NULL, 
    MenuData, XtNumber(MenuData), NULL},
  {"Menu Two" , NULL,  NULL,  
    Menu2Data, XtNumber(Menu2Data), NULL},
};

main(argc, argv)
     int   argc;
     char *argv[];
{
  Widget toplevel, bb, menubar;
  /*
   * Initialize the Intrinsics and create a top level widget.
   */
  toplevel = XtInitialize (argv[0], "MenuTest", NULL, 0, 
                           &argc, argv);
  bb = XtCreateManagedWidget("bulletin", 
			     xmBulletinBoardWidgetClass, 
                             toplevel, NULL, 0);
  /*
   * Steps 1 and 2. Create and manage a menubar.
   */
  menubar = XmCreateMenuBar(bb, "menubar", NULL, 0);
  XtManageChild(menubar); 
  /*
   * Step 3. Create the menu from the description.
   */
  xs_create_menu_buttons(NULL, menubar, PulldownData,
                         XtNumber(PulldownData));
  XtRealizeWidget (toplevel);
  XtMainLoop();
}


void do_it(w, client_data, call_data)
     Widget   w;
     char    *client_data;
     caddr_t  call_data;
{
  printf("%s selected\n", client_data);
}
@EOF

chmod 644 ch4/menu3.c

echo x - ch4/formtest1.c
cat >ch4/formtest1.c <<'@EOF'
/**********************************************************************************
  * formtest1.c: Test the constraints of the XmForm Widget
  *         From:
  *                   The X Window System, 
  *            Programming and Applications with Xt
  *                   OSF/Motif Edition
  *         by
  *                Douglas Young
  *              Prentice Hall, 1990
  *
  *                 Example described on pages:      91-92
  *
  *
  *  Copyright 1989 by Prentice Hall
  *  All Rights Reserved
  *
  * This code is based on the OSF/Motif widget set and the X Window System
  *
  * Permission to use, copy, modify, and distribute this software for 
  * any purpose and without fee is hereby granted, provided that the above
  * copyright notice appear in all copies and that both the copyright notice
  * and this permission notice appear in supporting documentation.
  *
  * Prentice Hall and the author disclaim all warranties with regard to 
  * this software, including all implied warranties of merchantability and fitness.
  * In no event shall Prentice Hall or the author be liable for any special,
  * indirect or cosequential damages or any damages whatsoever resulting from 
  * loss of use, data or profits, whether in an action of contract, negligence 
  * or other tortious action, arising out of or in connection with the use 
  * or performance of this software.
  *
  * Open Software Foundation is a trademark of The Open Software Foundation, Inc.
  * OSF is a trademark of Open Software Foundation, Inc.
  * OSF/Motif is a trademark of Open Software Foundation, Inc.
  * Motif is a trademark of Open Software Foundation, Inc.
  * DEC is a registered trademark of Digital Equipment Corporation
  * HP is a registered trademark of the Hewlett Packard Company
  * DIGITAL is a registered trademark of Digital Equipment Corporation
  * X Window System is a trademark of the Massachusetts Institute of Technology
  **********************************************************************************/

#include <X11/Intrinsic.h> 
#include <Xm/Xm.h>
#include <Xm/Form.h>
#include <Xm/PushB.h>

char * buttons[] = {"button1", "button2", "button3"};

main(argc, argv)
     int   argc;
     char *argv[];
{
  Widget toplevel, form, wbutton[5];
  int    i;
  toplevel = XtInitialize(argv[0], "Formtest", NULL, 0, 
                          &argc, argv);
  /*
   * Create an XmForm manager widget
   */
  form = XtCreateManagedWidget("form", xmFormWidgetClass, 
                               toplevel, NULL,0);
  /*
   * Add three XmPushButton widgets to the Form Widget.
   */
  for(i=0;i< XtNumber(buttons); i++)
    wbutton[i] = XtCreateWidget(buttons[i],
                                xmPushButtonWidgetClass, 
                                form, NULL,0);
  XtManageChildren(wbutton, XtNumber(buttons));

  XtRealizeWidget(toplevel);
  XtMainLoop();
}

@EOF

chmod 664 ch4/formtest1.c

echo x - ch4/helptest.c
cat >ch4/helptest.c <<'@EOF'
/**********************************************************************************
  * helptest.c: Test a popup Dialog widget with a help button
  *         From:
  *                   The X Window System, 
  *            Programming and Applications with Xt
  *                   OSF/Motif Edition
  *         by
  *                Douglas Young
  *              Prentice Hall, 1990
  *
  *                 Example described on pages:     117-128
  *
  *
  *  Copyright 1989 by Prentice Hall
  *  All Rights Reserved
  *
  * This code is based on the OSF/Motif widget set and the X Window System
  *
  * Permission to use, copy, modify, and distribute this software for 
  * any purpose and without fee is hereby granted, provided that the above
  * copyright notice appear in all copies and that both the copyright notice
  * and this permission notice appear in supporting documentation.
  *
  * Prentice Hall and the author disclaim all warranties with regard to 
  * this software, including all implied warranties of merchantability and fitness.
  * In no event shall Prentice Hall or the author be liable for any special,
  * indirect or cosequential damages or any damages whatsoever resulting from 
  * loss of use, data or profits, whether in an action of contract, negligence 
  * or other tortious action, arising out of or in connection with the use 
  * or performance of this software.
  *
  * Open Software Foundation is a trademark of The Open Software Foundation, Inc.
  * OSF is a trademark of Open Software Foundation, Inc.
  * OSF/Motif is a trademark of Open Software Foundation, Inc.
  * Motif is a trademark of Open Software Foundation, Inc.
  * DEC is a registered trademark of Digital Equipment Corporation
  * HP is a registered trademark of the Hewlett Packard Company
  * DIGITAL is a registered trademark of Digital Equipment Corporation
  * X Window System is a trademark of the Massachusetts Institute of Technology
  **********************************************************************************/


#include <X11/StringDefs.h>
#include <X11/Intrinsic.h>
#include <X11/Shell.h>
#include <Xm/Xm.h>
#include <Xm/PushB.h>
#include <Xm/BulletinB.h>
#include <Xm/Text.h>

#include "libXs.h"

void   show_dialog();
void   done_callback();
Widget create_dialog();
void   get_text();

main(argc, argv)
     int   argc;
     char *argv[];
{
  Widget toplevel, button, dialog;
  /*
   * Initialize the Intrinsics and create a PushButton widget.
   */  
  toplevel = XtInitialize (argv[0], "Helptest", NULL, 0, 
                           &argc, argv);
  button = XtCreateManagedWidget("button", 
                                 xmPushButtonWidgetClass, 
                                 toplevel, NULL, 0);
  /*
   * Create a popup dialog and a register a callback
   * function to popup it up when the button is activated.
   */
  dialog = create_dialog(button);
  XtAddCallback(button, XmNactivateCallback, 
                show_dialog, dialog);

  XtRealizeWidget (toplevel);
  XtMainLoop();
}

static void show_dialog(w, dialog, call_data)
   Widget     w;
   Widget     dialog;
   XmAnyCallbackStruct *call_data;
{
  XtManageChild(dialog);
}

char *buttons[] = {"button1", "button2", "button3"};
char *editors[] = {"field1", "field2", "field3"};

char *help_str[] = {
  "Fill in the text fields and press the buttons to ",
  " the right when done",
  "",
  "The first text field should contain a persons name",
  "The second field should contain an address",
  "The third should contain a phone number",
  "Edit any field and then press the button to the right",
  "to indicate that the information is completed",
  "",
  "Sorry, more detailed help is unavailable.",
  "",""};

Widget create_dialog(parent, name)
     Widget parent;
{
  Widget bb, edit[3], button[3], done_button, help_button;
  Arg    wargs[10];
  int    i,  n = 0;
  XtSetArg(wargs[n], XmNautoUnmanage, FALSE); n++;
  bb = XmCreateBulletinBoardDialog(parent, "board", wargs, n);
  /*
   * Create three single line XmEdit widgets
   * and associate a button with each text widget.
   * Assign an XmNactivateCallback callback to each button.
   */
  for(i=0; i < XtNumber(editors); i++)
     edit[i] = XtCreateWidget(editors[i], 
                              xmTextWidgetClass,
                              bb, NULL, 0);
  for(i=0; i < XtNumber(buttons); i++){
     button[i] = XtCreateWidget(buttons[i],
                                xmPushButtonWidgetClass,
                                bb, NULL, 0);
     XtAddCallback(button[i], XmNactivateCallback, 
                   get_text, edit[i]);
  }
  /*
   * Add a button to let the user pop down the widget.
   */
  done_button = XtCreateManagedWidget("done",
                                      xmPushButtonWidgetClass,
                                      bb, NULL, 0);
  XtAddCallback(done_button, XmNactivateCallback,
                done_callback, bb);
  /*
   * Add a button to let the user ask for help.
   */
  help_button = XtCreateManagedWidget("help",
                                      xmPushButtonWidgetClass,
                                      bb, NULL, 0);
  XtAddCallback(help_button, XmNactivateCallback,
                xs_help_callback, help_str);
  XtManageChildren(edit, XtNumber(editors));
  XtManageChildren(button, XtNumber(buttons));
  return bb;
}

static void done_callback(w, dialog, call_data)
   Widget     w;
   Widget     dialog;
   XmAnyCallbackStruct *call_data;
{
  XtUnmanageChild(dialog);
#ifdef JUST_LIKE_BOOK
  /*
   * Oops, version-itis got me here. If the widget is re-created everytime
   * it is popped up, in show_dialog() this would be ok. As it is, popping
   * up the widget a second time after it has been destroyed will be trouble.
   */
  XtDestroyWidget(dialog);
#endif
}
void get_text(w, textwidget, call_value)
   Widget   w;
   Widget   textwidget;
   XmAnyCallbackStruct *call_value;
{
 printf("retrieving text: %s\n", XmTextGetString(textwidget));
}
@EOF

chmod 664 ch4/helptest.c

echo x - ch4/rctest.c
cat >ch4/rctest.c <<'@EOF'
/**********************************************************************************
  * rctest.c: An example using the XmRowColumn widget
  *         From:
  *                   The X Window System, 
  *            Programming and Applications with Xt
  *                   OSF/Motif Edition
  *         by
  *                Douglas Young
  *              Prentice Hall, 1990
  *
  *                 Example described on pages:     85-86
  *
  *
  *  Copyright 1989 by Prentice Hall
  *  All Rights Reserved
  *
  * This code is based on the OSF/Motif widget set and the X Window System
  *
  * Permission to use, copy, modify, and distribute this software for 
  * any purpose and without fee is hereby granted, provided that the above
  * copyright notice appear in all copies and that both the copyright notice
  * and this permission notice appear in supporting documentation.
  *
  * Prentice Hall and the author disclaim all warranties with regard to 
  * this software, including all implied warranties of merchantability and fitness.
  * In no event shall Prentice Hall or the author be liable for any special,
  * indirect or cosequential damages or any damages whatsoever resulting from 
  * loss of use, data or profits, whether in an action of contract, negligence 
  * or other tortious action, arising out of or in connection with the use 
  * or performance of this software.
  *
  * Open Software Foundation is a trademark of The Open Software Foundation, Inc.
  * OSF is a trademark of Open Software Foundation, Inc.
  * OSF/Motif is a trademark of Open Software Foundation, Inc.
  * Motif is a trademark of Open Software Foundation, Inc.
  * DEC is a registered trademark of Digital Equipment Corporation
  * HP is a registered trademark of the Hewlett Packard Company
  * DIGITAL is a registered trademark of Digital Equipment Corporation
  * X Window System is a trademark of the Massachusetts Institute of Technology
  **********************************************************************************/



#include <X11/StringDefs.h>
#include <X11/Intrinsic.h> 
#include <X11/Intrinsic.h>
#include <Xm/Xm.h>
#include <Xm/RowColumn.h>
#include <Xm/PushB.h>

char * buttons[] = {"button1", "button2", "button3", 
                    "button4", "button5", "button6"};
main(argc, argv)
  int    argc;
  char  *argv[];
{
  Widget toplevel, rowcol;
  int    i;
  toplevel = XtInitialize(argv[0], "Rctest", NULL, 0, 
                          &argc, argv);
  /*
   * Create an XmRowColumn widget.
   */
  rowcol = XtCreateManagedWidget("rowcol",
                                 xmRowColumnWidgetClass,
                                 toplevel, NULL, 0);
  /*
   * Create six children of the XmRowColumn widget.
   */ 
  for(i=0;i< XtNumber(buttons); i++)  
   XtCreateManagedWidget(buttons[i], xmPushButtonWidgetClass,
                         rowcol, NULL, 0);
  XtRealizeWidget(toplevel);
  XtMainLoop();
}
@EOF

chmod 644 ch4/rctest.c

echo x - ch4/dialog.c
cat >ch4/dialog.c <<'@EOF'
/**********************************************************************************
  * dialog.c: Test a popup Dialog widget
  *         From:
  *                   The X Window System, 
  *            Programming and Applications with Xt
  *                   OSF/Motif Edition
  *         by
  *                Douglas Young
  *              Prentice Hall, 1990
  *
  *                 Example described on pages:      114-116
  *
  *
  *  Copyright 1989 by Prentice Hall
  *  All Rights Reserved
  *
  * This code is based on the OSF/Motif widget set and the X Window System
  *
  * Permission to use, copy, modify, and distribute this software for 
  * any purpose and without fee is hereby granted, provided that the above
  * copyright notice appear in all copies and that both the copyright notice
  * and this permission notice appear in supporting documentation.
  *
  * Prentice Hall and the author disclaim all warranties with regard to 
  * this software, including all implied warranties of merchantability and fitness.
  * In no event shall Prentice Hall or the author be liable for any special,
  * indirect or cosequential damages or any damages whatsoever resulting from 
  * loss of use, data or profits, whether in an action of contract, negligence 
  * or other tortious action, arising out of or in connection with the use 
  * or performance of this software.
  *
  * Open Software Foundation is a trademark of The Open Software Foundation, Inc.
  * OSF is a trademark of Open Software Foundation, Inc.
  * OSF/Motif is a trademark of Open Software Foundation, Inc.
  * Motif is a trademark of Open Software Foundation, Inc.
  * DEC is a registered trademark of Digital Equipment Corporation
  * HP is a registered trademark of the Hewlett Packard Company
  * DIGITAL is a registered trademark of Digital Equipment Corporation
  * X Window System is a trademark of the Massachusetts Institute of Technology
  **********************************************************************************/

#include <X11/StringDefs.h>
#include <X11/Intrinsic.h>
#include <X11/Shell.h>
#include <Xm/Xm.h>
#include <Xm/PushB.h>
#include <Xm/BulletinB.h>
#include <Xm/Text.h>

#include "libXs.h"

void   show_dialog();
void   done_callback();
Widget create_dialog();
void   get_text();

main(argc, argv)
     int   argc;
     char *argv[];
{
  Widget toplevel, button, dialog;
  /*
   * Initialize the Intrinsics and create a PushButton widget.
   */  
  toplevel = XtInitialize (argv[0], "Dialog", NULL, 0, 
                           &argc, argv);
  button = XtCreateManagedWidget("button", 
                                 xmPushButtonWidgetClass, 
                                 toplevel, NULL, 0);
  /*
   * Create a popup dialog and a register a callback
   * function to popup it up when the button is activated.
   */
  dialog = create_dialog(button);
  XtAddCallback(button, XmNactivateCallback, 
                show_dialog, dialog);

  XtRealizeWidget (toplevel);
  XtMainLoop();
}

static void show_dialog(w, dialog, call_data)
   Widget     w;
   Widget     dialog;
   XmAnyCallbackStruct *call_data;
{
  XtManageChild(dialog);
}

char *buttons[] = {"button1", "button2", "button3"};
char *editors[] = {"field1", "field2", "field3"};

Widget create_dialog(parent, name)
     Widget parent;
{
  Widget bb, edit[3], button[3], done_button;
  Arg    wargs[10];
  int    i,  n = 0;
  XtSetArg(wargs[n], XmNautoUnmanage, FALSE); n++;
  bb = XmCreateBulletinBoardDialog(parent, "board", wargs, n);
  /*
   * Create three single line XmEdit widgets
   * and associate a button with each text widget.
   * Assign an XmNactivateCallback callback to each button.
   */
  for(i=0; i < XtNumber(editors); i++)
     edit[i] = XtCreateWidget(editors[i], 
                              xmTextWidgetClass,
                              bb, NULL, 0);
  for(i=0; i < XtNumber(buttons); i++){
     button[i] = XtCreateWidget(buttons[i],
                                xmPushButtonWidgetClass,
                                bb, NULL, 0);
     XtAddCallback(button[i], XmNactivateCallback, 
                   get_text, edit[i]);
  }
  /*
   * Add a button to let the user pop down the widget.
   */
  done_button= XtCreateManagedWidget("done",
                                     xmPushButtonWidgetClass, 
                                     bb, NULL, 0);
  XtAddCallback(done_button, XmNactivateCallback,
                done_callback, bb);
  XtManageChildren(edit, XtNumber(editors));
  XtManageChildren(button, XtNumber(buttons));
  return bb;
}

static void done_callback(w, dialog, call_data)
   Widget     w;
   Widget     dialog;
   XmAnyCallbackStruct *call_data;
{
  XtUnmanageChild(dialog);
#ifdef JUST_LIKE_BOOK
  /*
   * Oops, version-itis got me here. If the widget is re-created everytime
   * it is popped up, in show_dialog() this would be ok. As it is, popping
   * up the widget a second time after it has been destroyed will be trouble.
   */
  XtDestroyWidget(dialog);
#endif
}

void get_text(w, textwidget, call_value)
   Widget   w;
   Widget   textwidget;
   XmAnyCallbackStruct *call_value;
{
 printf("retrieving text: %s\n", XmTextGetString(textwidget));
}
@EOF

chmod 664 ch4/dialog.c

echo x - ch4/traverse.c
cat >ch4/traverse.c <<'@EOF'
/**********************************************************************************
  * traverse.c: An example of Motif's traversal mechanisms
  *         From:
  *                   The X Window System, 
  *            Programming and Applications with Xt
  *                   OSF/Motif Edition
  *         by
  *                Douglas Young
  *              Prentice Hall, 1990
  *
  *                 Example described on pages:     110-111
  *
  *
  *  Copyright 1989 by Prentice Hall
  *  All Rights Reserved
  *
  * This code is based on the OSF/Motif widget set and the X Window System
  *
  * Permission to use, copy, modify, and distribute this software for 
  * any purpose and without fee is hereby granted, provided that the above
  * copyright notice appear in all copies and that both the copyright notice
  * and this permission notice appear in supporting documentation.
  *
  * Prentice Hall and the author disclaim all warranties with regard to 
  * this software, including all implied warranties of merchantability and fitness.
  * In no event shall Prentice Hall or the author be liable for any special,
  * indirect or cosequential damages or any damages whatsoever resulting from 
  * loss of use, data or profits, whether in an action of contract, negligence 
  * or other tortious action, arising out of or in connection with the use 
  * or performance of this software.
  *
  * Open Software Foundation is a trademark of The Open Software Foundation, Inc.
  * OSF is a trademark of Open Software Foundation, Inc.
  * OSF/Motif is a trademark of Open Software Foundation, Inc.
  * Motif is a trademark of Open Software Foundation, Inc.
  * DEC is a registered trademark of Digital Equipment Corporation
  * HP is a registered trademark of the Hewlett Packard Company
  * DIGITAL is a registered trademark of Digital Equipment Corporation
  * X Window System is a trademark of the Massachusetts Institute of Technology
  **********************************************************************************/


#include <X11/StringDefs.h>
#include <X11/Intrinsic.h> 
#include <X11/Intrinsic.h>
#include <Xm/Xm.h>
#include <Xm/RowColumn.h>
#include <Xm/PushB.h>

char * buttons_one[] = {"button1", "button2", "button3"};
char * buttons_two[] = { "button4", "button5", "button6"};

main(argc, argv)
  int    argc;
  char  *argv[];
{
  Widget toplevel, rowcol, box1, box2;
  int    i;
  toplevel = XtInitialize(argv[0], "Traverse", NULL, 0, 
                          &argc, argv);
  /*
   * Create an XmRowColumn widget.
   */
  rowcol = XtCreateManagedWidget("rowcol",
                                 xmRowColumnWidgetClass,
                                 toplevel, NULL, 0);
  box1 = XtCreateManagedWidget("box1",
                                 xmRowColumnWidgetClass,
                                 rowcol, NULL, 0);
  /*
   * Make the XmRowColumn widget a tab group
   */
  XmAddTabGroup(box1);

  box2 = XtCreateManagedWidget("box2",
                                 xmRowColumnWidgetClass,
                                 rowcol, NULL, 0);
  /*
   * Make the XmRowColumn widget a tab group
   */
  XmAddTabGroup(box2);

  /*
   * Create three children of each XmRowColumn widget.
   */ 
  for(i=0;i< XtNumber(buttons_one); i++)  
   XtCreateManagedWidget(buttons_one[i], xmPushButtonWidgetClass,
                         box1, NULL, 0);

  for(i=0;i< XtNumber(buttons_two); i++)  
   XtCreateManagedWidget(buttons_one[i], xmPushButtonWidgetClass,
                         box2, NULL, 0);
  XtRealizeWidget(toplevel);
  XtMainLoop();
}

@EOF

chmod 644 ch4/traverse.c

chmod 775 ch4

echo mkdir - ch5
mkdir ch5

echo x - ch5/mousetracks.c
cat >ch5/mousetracks.c <<'@EOF'
/**********************************************************************************
 * mousetracks.c: Driver to test the mouse tracker module
  *         From:
  *                   The X Window System, 
  *            Programming and Applications with Xt
  *                   OSF/Motif Edition
  *         by
  *                Douglas Young
  *              Prentice Hall, 1990
  *
  *                 Example described on pages:     136-139
  *
  *
  *  Copyright 1989 by Prentice Hall
  *  All Rights Reserved
  *
  * This code is based on the OSF/Motif widget set and the X Window System
  *
  * Permission to use, copy, modify, and distribute this software for 
  * any purpose and without fee is hereby granted, provided that the above
  * copyright notice appear in all copies and that both the copyright notice
  * and this permission notice appear in supporting documentation.
  *
  * Prentice Hall and the author disclaim all warranties with regard to 
  * this software, including all implied warranties of merchantability and fitness.
  * In no event shall Prentice Hall or the author be liable for any special,
  * indirect or cosequential damages or any damages whatsoever resulting from 
  * loss of use, data or profits, whether in an action of contract, negligence 
  * or other tortious action, arising out of or in connection with the use 
  * or performance of this software.
  *
  * Open Software Foundation is a trademark of The Open Software Foundation, Inc.
  * OSF is a trademark of Open Software Foundation, Inc.
  * OSF/Motif is a trademark of Open Software Foundation, Inc.
  * Motif is a trademark of Open Software Foundation, Inc.
  * DEC is a registered trademark of Digital Equipment Corporation
  * HP is a registered trademark of the Hewlett Packard Company
  * DIGITAL is a registered trademark of Digital Equipment Corporation
  * X Window System is a trademark of the Massachusetts Institute of Technology
  **********************************************************************************/

#include <X11/StringDefs.h>
#include <X11/Intrinsic.h>
#include <Xm/Xm.h>
#include <Xm/PanedW.h>
#include <Xm/RowColumn.h>
#include <Xm/DrawingA.h>
#include <Xm/Label.h>
#include "libXs.h"

main(argc, argv)
   int             argc;
   char           *argv[];
{
   Widget          toplevel, panel, command, target;
  /*
   * Initialize the Intrinsics.
   */
   toplevel = XtInitialize(argv[0], "Mousetracks", NULL, 0,
                           &argc, argv);
   /*
    * Create a vertical paned widget, to hold
    * all the other widgets.
    */
   panel = XtCreateManagedWidget("panel", 
                                 xmPanedWindowWidgetClass,
                                 toplevel, NULL, 0);
   /*
    * Create a command widget to hold both a quit button 
    * and the mouse tracker display.
    */
    command = XtCreateManagedWidget("command", 
                                    xmRowColumnWidgetClass, 
                                    panel, NULL, 0);
    /*
     *  Add a quit button.
     */
    xs_create_quit_button(command);
    /* 
     *  Create the widget in which we track the 
     *  motion of the sprite.
     */
    target = XtCreateManagedWidget("target", 
                                   xmDrawingAreaWidgetClass,
                                   panel, NULL, 0);
    /*
     * Create the mouse tracker.
     */
    create_mouse_tracker(command, target);
    XtRealizeWidget(toplevel);
    XtMainLoop();
}
@EOF

chmod 644 ch5/mousetracks.c

echo x - ch5/Makefile
cat >ch5/Makefile <<'@EOF'
CC = cc 
XSLIBDIR = ../lib
DEBUG = 
# HP Machines
CFLAGS = $(DEBUG) -DSYSV  -I$(XSLIBDIR) 
# DEC and Sun
#CFLAGS = $(DEBUG) -I$(XSLIBDIR)

LIBS = ../lib/libXs.a -lXm -lXt -lX11

.o:.c

all: xbc trackmouse1 trackmouse2  select trackmouse3 xclock stopwatch


trackmouse1: mousetracks.o tracker1.o
	$(CC) $(CFLAGS) -o $@ mousetracks.o tracker1.o  $(LIBS)

trackmouse2 : mousetracks.o tracker2.o
	$(CC) $(CFLAGS) -o $@ mousetracks.o tracker2.o $(LIBS)

trackmouse3 : mousetracks.o tracker3.o
	$(CC) $(CFLAGS) -o $@ mousetracks.o tracker3.o $(LIBS)

select : select.o
	$(CC) $(CFLAGS) -o $@ $@.o $(LIBS)

xclock : xclock.o
	$(CC) $(CFLAGS) -o $@ $@.o $(LIBS)

xbc : xbc.o
	$(CC) $(CFLAGS) -o $@ $@.o $(LIBS)

stopwatch : stopwatch.o
	$(CC) $(CFLAGS) -o $@ $@.o $(LIBS)


@EOF

chmod 644 ch5/Makefile

echo x - ch5/tracker1.c
cat >ch5/tracker1.c <<'@EOF'
/**********************************************************************************
  * stopwatch.c: A digital stopwatch using workprocs.
  *         From:
  *                   The X Window System, 
  *            Programming and Applications with Xt
  *                   OSF/Motif Edition
  *         by
  *                Douglas Young
  *              Prentice Hall, 1990
  *
  *                 Example described on pages:     ??
  *
  *
  *  Copyright 1989 by Prentice Hall
  *  All Rights Reserved
  *
  * This code is based on the OSF/Motif widget set and the X Window System
  *
  * Permission to use, copy, modify, and distribute this software for 
  * any purpose and without fee is hereby granted, provided that the above
  * copyright notice appear in all copies and that both the copyright notice
  * and this permission notice appear in supporting documentation.
  *
  * Prentice Hall and the author disclaim all warranties with regard to 
  * this software, including all implied warranties of merchantability and fitness.
  * In no event shall Prentice Hall or the author be liable for any special,
  * indirect or cosequential damages or any damages whatsoever resulting from 
  * loss of use, data or profits, whether in an action of contract, negligence 
  * or other tortious action, arising out of or in connection with the use 
  * or performance of this software.
  *
  * Open Software Foundation is a trademark of The Open Software Foundation, Inc.
  * OSF is a trademark of Open Software Foundation, Inc.
  * OSF/Motif is a trademark of Open Software Foundation, Inc.
  * Motif is a trademark of Open Software Foundation, Inc.
  * DEC is a registered trademark of Digital Equipment Corporation
  * HP is a registered trademark of the Hewlett Packard Company
  * DIGITAL is a registered trademark of Digital Equipment Corporation
  * X Window System is a trademark of the Massachusetts Institute of Technology
  **********************************************************************************/


#include <X11/StringDefs.h>
#include <X11/Intrinsic.h>
#include <Xm/Xm.h>
#include <Xm/Label.h>
#include "libXs.h"

create_mouse_tracker(parent, target)
    Widget   parent, target;
{
    extern void  clear_tracker();
    extern void  track_mouse_position();
    Widget       tracker;
    /*
     * Create the tracker widget and register event 
     * handlers for the target widget. 
     */
    tracker = XtCreateManagedWidget("mousetracker", 
                                    xmLabelWidgetClass,
                                    parent, NULL, 0);
    XtAddEventHandler(target, LeaveWindowMask, FALSE,
                      clear_tracker, tracker);
    XtAddEventHandler(target, PointerMotionMask, FALSE,
                      track_mouse_position, tracker);
}

void track_mouse_position(w, tracker, event)
    Widget          w;
    Widget          tracker;
    XEvent         *event;
{
   /*
    * Extract the position of the sprite from the event
    * and display it in the tracker widget. 
    */
    xs_wprintf(tracker, "X: %04d, Y: %04d", 
               event->xmotion.x, event->xmotion.y);
}

void clear_tracker(w, tracker, event)
    Widget      w;
    Widget      tracker;
    XEvent     *event;
{
  /*  
   * Display an empty string in the tracker widget. 
   */
  xs_wprintf(tracker, "");
}
@EOF

chmod 644 ch5/tracker1.c

echo x - ch5/tracker2.c
cat >ch5/tracker2.c <<'@EOF'
/**********************************************************************************
  * tracker2.c: 
  *         From:
  *                   The X Window System, 
  *            Programming and Applications with Xt
  *                   OSF/Motif Edition
  *         by
  *                Douglas Young
  *              Prentice Hall, 1990
  *
  *                 Example described on pages:     140-141
  *
  *
  *  Copyright 1989 by Prentice Hall
  *  All Rights Reserved
  *
  * This code is based on the OSF/Motif widget set and the X Window System
  *
  * Permission to use, copy, modify, and distribute this software for 
  * any purpose and without fee is hereby granted, provided that the above
  * copyright notice appear in all copies and that both the copyright notice
  * and this permission notice appear in supporting documentation.
  *
  * Prentice Hall and the author disclaim all warranties with regard to 
  * this software, including all implied warranties of merchantability and fitness.
  * In no event shall Prentice Hall or the author be liable for any special,
  * indirect or cosequential damages or any damages whatsoever resulting from 
  * loss of use, data or profits, whether in an action of contract, negligence 
  * or other tortious action, arising out of or in connection with the use 
  * or performance of this software.
  *
  * Open Software Foundation is a trademark of The Open Software Foundation, Inc.
  * OSF is a trademark of Open Software Foundation, Inc.
  * OSF/Motif is a trademark of Open Software Foundation, Inc.
  * Motif is a trademark of Open Software Foundation, Inc.
  * DEC is a registered trademark of Digital Equipment Corporation
  * HP is a registered trademark of the Hewlett Packard Company
  * DIGITAL is a registered trademark of Digital Equipment Corporation
  * X Window System is a trademark of the Massachusetts Institute of Technology
  **********************************************************************************/

#include <X11/Intrinsic.h>
#include <X11/StringDefs.h>
#include <Xm/Xm.h>
#include <Xm/Label.h>

create_mouse_tracker(parent, target)
     Widget    parent, target;
{
  extern void  clear_tracker();
  extern void  track_mouse_position();
  extern void  show_mouse_position();

  Widget       tracker;
  /*
   * Create the tracker widget.
   */
  tracker = XtCreateManagedWidget("mousetracker",
                                  xmLabelWidgetClass,
                                  parent, NULL, 0);
  /*
   * Set up event handlers on target widget.
   */
  XtAddEventHandler(target, ButtonPressMask, FALSE,
                    show_mouse_position, tracker);
  XtAddEventHandler(target, ButtonMotionMask, FALSE,
                    track_mouse_position, tracker);
  XtAddEventHandler(target, 
                    ButtonReleaseMask | LeaveWindowMask,
                    FALSE, clear_tracker, tracker);
}

void show_mouse_position(w, tracker, event)
    Widget          w;
    Widget          tracker;
    XEvent         *event;
{
   /*
    * Extract the position of the sprite from the event
    * and display it in the tracker widget. 
    */
   xs_wprintf(tracker, "X: %04d, Y: %04d", 
              event->xbutton.x, event->xbutton.y);
}

void track_mouse_position(w, tracker, event)
    Widget          w;
    Widget          tracker;
    XEvent         *event;
{
   /*
    * Extract the position of the sprite from the event
    * and display it in the tracker widget. 
    */
    xs_wprintf(tracker, "X: %04d, Y: %04d", 
               event->xmotion.x, event->xmotion.y);
}

void clear_tracker(w, tracker, event)
    Widget      w;
    Widget      tracker;
    XEvent     *event;
{
  /*  
   * Display an empty string in the tracker widget. 
   */
  xs_wprintf(tracker, "");
}
@EOF

chmod 644 ch5/tracker2.c

echo x - ch5/select.c
cat >ch5/select.c <<'@EOF'
/**********************************************************************************
  * select.c: Demo a main loop that uses select() to do 
  *           background processing
  *         From:
  *                   The X Window System, 
  *            Programming and Applications with Xt
  *                   OSF/Motif Edition
  *         by
  *                Douglas Young
  *              Prentice Hall, 1990
  *
  *                 Example described on pages:     143-144
  *
  *
  *  Copyright 1989 by Prentice Hall
  *  All Rights Reserved
  *
  * This code is based on the OSF/Motif widget set and the X Window System
  *
  * Permission to use, copy, modify, and distribute this software for 
  * any purpose and without fee is hereby granted, provided that the above
  * copyright notice appear in all copies and that both the copyright notice
  * and this permission notice appear in supporting documentation.
  *
  * Prentice Hall and the author disclaim all warranties with regard to 
  * this software, including all implied warranties of merchantability and fitness.
  * In no event shall Prentice Hall or the author be liable for any special,
  * indirect or cosequential damages or any damages whatsoever resulting from 
  * loss of use, data or profits, whether in an action of contract, negligence 
  * or other tortious action, arising out of or in connection with the use 
  * or performance of this software.
  *
  * Open Software Foundation is a trademark of The Open Software Foundation, Inc.
  * OSF is a trademark of Open Software Foundation, Inc.
  * OSF/Motif is a trademark of Open Software Foundation, Inc.
  * Motif is a trademark of Open Software Foundation, Inc.
  * DEC is a registered trademark of Digital Equipment Corporation
  * HP is a registered trademark of the Hewlett Packard Company
  * DIGITAL is a registered trademark of Digital Equipment Corporation
  * X Window System is a trademark of the Massachusetts Institute of Technology
  **********************************************************************************/


#include <X11/Intrinsic.h> 
#include <Xm/Xm.h>
#include <Xm/PushB.h>
#include <sys/time.h>
#include <signal.h>
#include <errno.h>

/*
 * Define callbacks.
 */
void arm_button(w, client_data, call_data)
   Widget  w;
   void   *client_data;
   void   *call_data;
{
  printf("Button armed\n");
}

void activate_button(w, client_data, call_data)
   Widget  w;
   void   *client_data;
   void   *call_data;
{
  printf("Button activated\n");
}

main(argc, argv)
    int   argc;
    char *argv[];
{
  Widget toplevel, button;
   
  toplevel = XtInitialize(argv[0], "Select", NULL, 0, 
			  &argc, argv);
  /*
   * Create the pushbutton widget.
   */
  button = XtCreateManagedWidget("button", 
				 xmPushButtonWidgetClass, 
				 toplevel, NULL, 0);
  /*
   * Add arm and activate callbacks.
   */
  XtAddCallback(button, XmNarmCallback, arm_button, NULL);
  XtAddCallback(button, XmNactivateCallback, activate_button, NULL);

  XtRealizeWidget(toplevel);

 while(TRUE){
  if(XtPending()){
     XEvent event;
     XtNextEvent(&event);
     XtDispatchEvent (&event);
  }
  else{
    struct timeval timeout;
    int readfds = 0;
    int maxfds = 1 + ConnectionNumber(XtDisplay(toplevel));
    timeout.tv_sec = 1;
    timeout.tv_usec = 0; 
    /* Do something else for a while */
    printf("doing something in the background\n");
    readfds = 1 << ConnectionNumber(XtDisplay(toplevel));
    if (select(maxfds, &readfds, NULL, NULL, &timeout) == -1){
      if (EINTR != errno)
          exit(1);
    }
  }
}
}




@EOF

chmod 644 ch5/select.c

echo x - ch5/tracker3.c
cat >ch5/tracker3.c <<'@EOF'
/**********************************************************************************
  * tracker3.c: 
  *         From:
  *                   The X Window System, 
  *            Programming and Applications with Xt
  *                   OSF/Motif Edition
  *         by
  *                Douglas Young
  *              Prentice Hall, 1990
  *
  *                 Example described on pages:    145-149
  *
  *
  *  Copyright 1989 by Prentice Hall
  *  All Rights Reserved
  *
  * This code is based on the OSF/Motif widget set and the X Window System
  *
  * Permission to use, copy, modify, and distribute this software for 
  * any purpose and without fee is hereby granted, provided that the above
  * copyright notice appear in all copies and that both the copyright notice
  * and this permission notice appear in supporting documentation.
  *
  * Prentice Hall and the author disclaim all warranties with regard to 
  * this software, including all implied warranties of merchantability and fitness.
  * In no event shall Prentice Hall or the author be liable for any special,
  * indirect or cosequential damages or any damages whatsoever resulting from 
  * loss of use, data or profits, whether in an action of contract, negligence 
  * or other tortious action, arising out of or in connection with the use 
  * or performance of this software.
  *
  * Open Software Foundation is a trademark of The Open Software Foundation, Inc.
  * OSF is a trademark of Open Software Foundation, Inc.
  * OSF/Motif is a trademark of Open Software Foundation, Inc.
  * Motif is a trademark of Open Software Foundation, Inc.
  * DEC is a registered trademark of Digital Equipment Corporation
  * HP is a registered trademark of the Hewlett Packard Company
  * DIGITAL is a registered trademark of Digital Equipment Corporation
  * X Window System is a trademark of the Massachusetts Institute of Technology
  **********************************************************************************/


#include <X11/StringDefs.h>
#include <X11/Intrinsic.h>
#include <Xm/Xm.h>
#include <Xm/Label.h>
#include "libXs.h"

typedef struct {
    Widget        tracker;
    Widget        target;
    XtIntervalId  id;
    int           delay;
} track_data, *track_data_ptr; 

#define DELAY 1000

create_mouse_tracker(parent, target)
     Widget          parent, target;
{
  extern void       enter_window_handler();
  static track_data data;

  data.delay = DELAY;
  /*
   * Store the target and tracker widgets in the data.
   */
  data.target  = target;
  data.tracker = XtCreateManagedWidget("mousetracker", 
                                        xmLabelWidgetClass,
                                        parent, NULL, 0);
  /*
   * Start with a single event handler.
   */  
  XtAddEventHandler(data.target, EnterWindowMask, FALSE,
                    enter_window_handler, &data);
}

static void enter_window_handler(w, data, event)
    Widget          w;
    track_data     *data;
    XEvent         *event;
{
   extern void  start_tracking();
   extern void  disable_alarm();
   /*
    * When the sprite enters the window, install
    * a timeout callback, and start the count-down.
    */
   XtAddEventHandler(data->target, LeaveWindowMask, FALSE,
                     disable_alarm, data);
   data->id = XtAddTimeOut(data->delay, start_tracking, data);
}

static void disable_alarm(w, data, event)
   Widget          w;
   track_data     *data;
   XEvent         *event;
{
   /*
    * Remove the timeout callback and then remove
    * ourself as an event handler.
    */
   XtRemoveTimeOut(data->id);
   XtRemoveEventHandler(data->target, LeaveWindowMask, FALSE,
                        disable_alarm, data);
}

static void start_tracking(data, id)
    track_data     *data;
    XtIntervalId    id;
{
    extern void  disable_alarm();
    extern void  leave_window_handler();
    extern void  track_mouse_position();
    /*
     * If this function was called, the alarm must have
     * gone off, so remove the disable_alarm event handler.
     */
    XtRemoveEventHandler(data->target, LeaveWindowMask, 
                         FALSE, disable_alarm, data);
    /*
     * Now add event handlers to track the sprite motion
     * and clear the tracker when we leave the target window.
     */
    XtAddEventHandler(data->target, PointerMotionMask, 
                      FALSE, track_mouse_position, data);
    XtAddEventHandler(data->target, LeaveWindowMask, 
                      FALSE, leave_window_handler, data);
}

static void track_mouse_position(w, data, event)
    Widget          w;
    track_data     *data;
    XEvent         *event;
{
  /*
   * Extract the position of the sprite from the event
   * and display it in the tracker widget. 
   */
  xs_wprintf(data->tracker, "X: %04d, Y: %04d",
             event->xmotion.x, event->xmotion.y);
}

static void leave_window_handler(w, data, event)
   Widget          w;
   track_data     *data;
   XEvent         *event;
{
 extern void  track_mouse_position();
 /*
  * Clear the tracker widget display.
  */
  xs_wprintf(data->tracker, "");
 /*
  * Remove the dynamically installed event handlers.
  */
  XtRemoveEventHandler(data->target, PointerMotionMask, FALSE,
                       track_mouse_position, data);
  XtRemoveEventHandler(data->target, LeaveWindowMask, FALSE,
                       leave_window_handler, data);
}

@EOF

chmod 644 ch5/tracker3.c

echo x - ch5/xclock.c
cat >ch5/xclock.c <<'@EOF'
/**********************************************************************************
  * xbc.c: An X interface to bc
  *         From:
  *                   The X Window System, 
  *            Programming and Applications with Xt
  *                   OSF/Motif Edition
  *         by
  *                Douglas Young
  *              Prentice Hall, 1990
  *
  *                 Example described on pages:   149-151
  *
  *
  *  Copyright 1989 by Prentice Hall
  *  All Rights Reserved
  *
  * This code is based on the OSF/Motif widget set and the X Window System
  *
  * Permission to use, copy, modify, and distribute this software for 
  * any purpose and without fee is hereby granted, provided that the above
  * copyright notice appear in all copies and that both the copyright notice
  * and this permission notice appear in supporting documentation.
  *
  * Prentice Hall and the author disclaim all warranties with regard to 
  * this software, including all implied warranties of merchantability and fitness.
  * In no event shall Prentice Hall or the author be liable for any special,
  * indirect or cosequential damages or any damages whatsoever resulting from 
  * loss of use, data or profits, whether in an action of contract, negligence 
  * or other tortious action, arising out of or in connection with the use 
  * or performance of this software.
  *
  * Open Software Foundation is a trademark of The Open Software Foundation, Inc.
  * OSF is a trademark of Open Software Foundation, Inc.
  * OSF/Motif is a trademark of Open Software Foundation, Inc.
  * Motif is a trademark of Open Software Foundation, Inc.
  * DEC is a registered trademark of Digital Equipment Corporation
  * HP is a registered trademark of the Hewlett Packard Company
  * DIGITAL is a registered trademark of Digital Equipment Corporation
  * X Window System is a trademark of the Massachusetts Institute of Technology
  **********************************************************************************/


#include <X11/Intrinsic.h>
#include <X11/StringDefs.h>
#include <Xm/Xm.h>
#include <Xm/Label.h>
#include <time.h>

void update_time();

main(argc, argv)
   int             argc;
   char           *argv[];
{
   Widget          toplevel, clock;
   /*
    * Create the widgets.
    */
   toplevel = XtInitialize(argv[0], "Clock", NULL, 0, 
                           &argc, argv);
   clock = XtCreateManagedWidget("face", 
                                 xmLabelWidgetClass,
                                 toplevel, NULL, 0);
   /*
    * Get the initial time.
    */
   update_time(clock, NULL);
   XtRealizeWidget(toplevel);
   XtMainLoop();
}
void update_time(w, id)
    Widget          w;
    XtIntervalId    id;
{
    long   tloc, rounded_tloc, next_minute;
   /*
     * Ask Unix for the time.
     */
    time(&tloc);
    /*
     * Convert the time to a string and display it,
     * after rounding it down to the last minute.
     */
    rounded_tloc = tloc / 60 * 60;
    xs_wprintf(w, "%s", ctime(&rounded_tloc));
    /*
     * Adjust the time to reflect the time till 
     * the next round minute.
     */
    next_minute = (60 - tloc % 60) * 1000;
    /*
     * The Intrinsics removes timeouts when they occur,
     * so put ourselves back. 
     */
    XtAddTimeOut(next_minute, update_time, w);
}
@EOF

chmod 644 ch5/xclock.c

echo x - ch5/stopwatch.c
cat >ch5/stopwatch.c <<'@EOF'
/**********************************************************************************
  * stopwatch.c: A digital stopwatch using workprocs.
  *         From:
  *                   The X Window System, 
  *            Programming and Applications with Xt
  *                   OSF/Motif Edition
  *         by
  *                Douglas Young
  *              Prentice Hall, 1990
  *
  *                 Example described on pages:      152-155
  *
  *
  *  Copyright 1989 by Prentice Hall
  *  All Rights Reserved
  *
  * This code is based on the OSF/Motif widget set and the X Window System
  *
  * Permission to use, copy, modify, and distribute this software for 
  * any purpose and without fee is hereby granted, provided that the above
  * copyright notice appear in all copies and that both the copyright notice
  * and this permission notice appear in supporting documentation.
  *
  * Prentice Hall and the author disclaim all warranties with regard to 
  * this software, including all implied warranties of merchantability and fitness.
  * In no event shall Prentice Hall or the author be liable for any special,
  * indirect or cosequential damages or any damages whatsoever resulting from 
  * loss of use, data or profits, whether in an action of contract, negligence 
  * or other tortious action, arising out of or in connection with the use 
  * or performance of this software.
  *
  * Open Software Foundation is a trademark of The Open Software Foundation, Inc.
  * OSF is a trademark of Open Software Foundation, Inc.
  * OSF/Motif is a trademark of Open Software Foundation, Inc.
  * Motif is a trademark of Open Software Foundation, Inc.
  * DEC is a registered trademark of Digital Equipment Corporation
  * HP is a registered trademark of the Hewlett Packard Company
  * DIGITAL is a registered trademark of Digital Equipment Corporation
  * X Window System is a trademark of the Massachusetts Institute of Technology
  **********************************************************************************/


#include <X11/Intrinsic.h>
#include <X11/StringDefs.h>
#include <Xm/Xm.h>
#include <Xm/Label.h>
#include <Xm/RowColumn.h>
#include <Xm/PushB.h>
#include <time.h>
#include "libXs.h"

Boolean update_time();
void    start_timing();
void    stop_timing();

long         start_time;
XtWorkProcId work_proc_id = NULL;

main(argc, argv)
   int      argc;
   char    *argv[];
{
  Widget   toplevel, panel, commands, start, stop, timer;

  toplevel = XtInitialize(argv[0], "Stopwatch", NULL, 0, 
                          &argc, argv);
  /*
   * Create a XmRowColumn widget to hold everything.
   */
  panel = XtCreateManagedWidget("panel", 
                                xmRowColumnWidgetClass,
                                toplevel, NULL, 0);
  /*
   * An XmLabel widget shows the current time.
   */ 
  timer = XtCreateManagedWidget("timer", 
                                xmLabelWidgetClass,
                                panel, NULL, 0);
  /*
   * Add start, stop, and quit buttons and register callbacks.
   * Pass the timer widget to all callbacks.
   */ 
  commands = XtCreateManagedWidget("commands", 
                                   xmRowColumnWidgetClass,
                                   panel, NULL, 0);
  start = XtCreateManagedWidget("start", 
                                 xmPushButtonWidgetClass,
                                 commands, NULL, 0);
  XtAddCallback(start,XmNactivateCallback,start_timing,timer);
  stop = XtCreateManagedWidget("stop", 
                               xmPushButtonWidgetClass,
                               commands, NULL, 0);
  XtAddCallback(stop, XmNactivateCallback,stop_timing,timer);
  xs_create_quit_button(commands);
 
  XtRealizeWidget(toplevel);
  XtMainLoop();
}

void start_timing(w, timer, call_data)
   Widget                w, timer;
   XmAnyCallbackStruct  *call_data;
{
  /* 
   * Get the initial time, and save it in a global.
   */
  time(&start_time); 
  /*
   * If a WorkProc has already been added, remove it.
   */
  if(work_proc_id)
    XtRemoveWorkProc(work_proc_id);
  /*
   * Register update_time() as a WorkProc.
   */
  work_proc_id = XtAddWorkProc(update_time, timer);
}

void stop_timing(w, timer, call_data)
   Widget                w, timer;
   XmAnyCallbackStruct  *call_data;
{
  if(work_proc_id)
    XtRemoveWorkProc(work_proc_id);
  work_proc_id = NULL; 
}
Boolean update_time(w)
      Widget   w;
{
  static long elapsed_time, last_time = -1;
  int minutes, seconds, current_time;
  /*
   * Retrieve the current time and calculate the elapsed time.
   */     
  time(&current_time);
  elapsed_time = current_time - start_time;
  /*
   * WorkProcs are irregularly called; don't update the
   * display if it's been less than a second since the last
   * time it was updated.
   */
  if(last_time == elapsed_time)
    return FALSE;
  /*
   * If one or more seconds has elapsed, remember this time,
   * and convert the elapsed time to minutes and seconds. 
   */
  last_time = elapsed_time;
  minutes = elapsed_time / 60;
  seconds = elapsed_time % 60;
  /*
   * Display the time as minutes and seconds.
   */
  xs_wprintf(w, "%02d : %02d", minutes, seconds);
  /*
   * Return FALSE so this WorkProc keeps getting called.
   */
  return FALSE;
}
@EOF

chmod 644 ch5/stopwatch.c

echo x - ch5/xbc.c
cat >ch5/xbc.c <<'@EOF'
/**********************************************************************************
  * xbc.c: An X interface to bc
  *         From:
  *                   The X Window System, 
  *            Programming and Applications with Xt
  *                   OSF/Motif Edition
  *         by
  *                Douglas Young
  *              Prentice Hall, 1990
  *
  *                 Example described on pages:    157-166
  *
  *
  *  Copyright 1989 by Prentice Hall
  *  All Rights Reserved
  *
  * This code is based on the OSF/Motif widget set and the X Window System
  *
  * Permission to use, copy, modify, and distribute this software for 
  * any purpose and without fee is hereby granted, provided that the above
  * copyright notice appear in all copies and that both the copyright notice
  * and this permission notice appear in supporting documentation.
  *
  * Prentice Hall and the author disclaim all warranties with regard to 
  * this software, including all implied warranties of merchantability and fitness.
  * In no event shall Prentice Hall or the author be liable for any special,
  * indirect or cosequential damages or any damages whatsoever resulting from 
  * loss of use, data or profits, whether in an action of contract, negligence 
  * or other tortious action, arising out of or in connection with the use 
  * or performance of this software.
  *
  * Open Software Foundation is a trademark of The Open Software Foundation, Inc.
  * OSF is a trademark of Open Software Foundation, Inc.
  * OSF/Motif is a trademark of Open Software Foundation, Inc.
  * Motif is a trademark of Open Software Foundation, Inc.
  * DEC is a registered trademark of Digital Equipment Corporation
  * HP is a registered trademark of the Hewlett Packard Company
  * DIGITAL is a registered trademark of Digital Equipment Corporation
  * X Window System is a trademark of the Massachusetts Institute of Technology
  **********************************************************************************/


#include <stdio.h>
#include <ctype.h>
#include <X11/StringDefs.h>
#include <X11/Intrinsic.h>
#include <Xm/Xm.h>
#include <Xm/PushB.h>
#include <Xm/PanedW.h>
#include <Xm/RowColumn.h>
#include <Xm/Text.h>
#include "libXs.h"

Widget     display;
Widget     create_button();
void       quit_bc();
void       get_from_bc();
void       send_to_bc();

main(argc, argv)
  int       argc;
  char     *argv[];
{
  Widget    toplevel, panel, keyboard, qbutton;
  Arg       wargs[10];
  int       n;
  toplevel = XtInitialize(argv[0], "Xbc", NULL, 0, 
                         &argc, argv);
  /*
   * Create a vertical paned widget as a base for the 
   * rest of the calculator.
   */
  panel = XtCreateManagedWidget("panel", 
                                xmPanedWindowWidgetClass,
                                toplevel, NULL, 0);
  /*
   * Create the calculator display.
   */
 display = XtCreateManagedWidget("display",
                                 xmTextWidgetClass,
                                 panel, NULL, 0);
  /*
   * Make the keyboard, which manages 5 rows of buttons
   */
  n = 0; 
  XtSetArg(wargs[n], XmNorientation, XmHORIZONTAL); n++;
  XtSetArg(wargs[n], XmNnumColumns, 5); n++;
  XtSetArg(wargs[n], XmNadjustLast, False); n++;
  XtSetArg(wargs[n], XmNpacking, XmPACK_COLUMN); n++;
  keyboard = XtCreateManagedWidget("keyboard", 
                                   xmRowColumnWidgetClass,
                                   panel, wargs, n);
  /* 
   * Create the keyboard buttons. This order makes it 
   * look like a typical desktop calculator.
   */
  create_button("1", keyboard);
  create_button("2", keyboard);
  create_button("3", keyboard);
  create_button("+", keyboard);
  create_button("4", keyboard);
  create_button("5", keyboard);
  create_button("6", keyboard);
  create_button("-", keyboard);
  create_button("7", keyboard);
  create_button("8", keyboard);
  create_button("9", keyboard);
  create_button("*", keyboard);
  create_button("0", keyboard);
  create_button(".", keyboard);
  create_button("=", keyboard);
  create_button("/", keyboard);
  /*
   *  Create a quit button and add a callback that
   *  tells bc to exit.
   */
  qbutton = xs_create_quit_button(keyboard);
  XtAddCallback(qbutton, XmNactivateCallback, quit_bc, NULL);
  /* 
   * Add callback get_from_bc() --  invoked when input 
   * is available from stdin.
   */
  XtAddInput(fileno(stdin), XtInputReadMask, 
            get_from_bc, display);
  /* 
   * Exec the program "bc" and set up pipes 
   * between it and us.
   */
  xs_talkto("bc");

  XtRealizeWidget(toplevel);
  XtMainLoop();
}

Widget create_button(name, parent)
  char    *name;
  Widget   parent;
{
  extern void send_to_bc();
  Widget      button;  
  /*
   * Create a single button and attach an activate callback.
   */
  button = XtCreateManagedWidget(name, 
                                 xmPushButtonWidgetClass,
                                 parent, NULL, 0);
  XtAddCallback(button, XmNactivateCallback, send_to_bc,name);
  return (button);
}

void quit_bc(w, client_data, call_data)
    Widget    w;
    caddr_t   client_data, call_data;
{
   /*
    * Tell bc to quit.
    */
   fprintf(stdout, "quit\n");
}

void send_to_bc(w, buffer, call_data)
  Widget    w;
  char     *buffer;
  XmAnyCallbackStruct *call_data;
{
  static int  start_new_entry = TRUE;
  /*
   * If this is the beginning of a new operand, 
   * clear the display.
   */
  if(start_new_entry){
    reset_display();
    start_new_entry = FALSE;
  }
  switch (buffer[0]) {
  /*
   * If the user entered and '=', send bc a newline, clear
   * the display, and get ready for a new operand.
   */
  case '=':
    fprintf(stdout, "%s", XmTextGetString(display));       
    fprintf(stdout, "\n");
    reset_display();
    start_new_entry = TRUE;
    break;
  /*
   * If this is an operator, get the previous operand
   * from the display buffer, and send it to bc before 
   * sending the operand.
   */
  case '-':
  case '+':
  case '/':
  case '*':
  case '^':
    fprintf(stdout, "%s", XmTextGetString(display));  
    fprintf(stdout, "%s", buffer);
    reset_display();
    break;
  /*
   * Anything else must be a digit, so append it to the
   * display buffer.
   */
  default:
    xs_insert_string(display, buffer);
  }
  fflush(stdout);
}
void get_from_bc(w, fid, id)
  Widget       w;
  int         *fid;
  XtInputId   *id;
{
  char       buf[BUFSIZ];
  int        nbytes, i;
  /* 
   * Get all pending input and append it to the display 
   * widget. Discard lines that begin with a newline.
   */
  nbytes = read(*fid, buf, BUFSIZ);
  if (nbytes && buf[0] != '\n') {
  /*
   * Null terminate the string at the first newline,
   * or at the end of the bytes read.
   */
   for(i=0;i<nbytes;i++)
     if(buf[i] == '\n')
         buf[i] = '\0';
     buf[nbytes] = '\0'; 
     xs_insert_string(display, buf);
  }
}
reset_display()
{
  /*
   * Clear the text buffer and go to position 1.
   */
  XmTextSetString(display, "");
  XmTextSetInsertionPosition(display, 0);
}
@EOF

chmod 644 ch5/xbc.c

chmod 775 ch5

echo mkdir - ch6
mkdir ch6

echo x - ch6/Makefile
cat >ch6/Makefile <<'@EOF'
CC = cc 
XSLIBDIR = ../lib
DEBUG = 
# HP Machines
CFLAGS = $(DEBUG) -DSYSV  -I$(XSLIBDIR) 
# DEC and Sun
#CFLAGS = $(DEBUG) -I$(XSLIBDIR)

LIBS = ../lib/libXs.a -lXm -lXt -lX11
.o:.c

all: getpixel coloredit 

getpixel : getpixel.o
	$(CC) $(CFLAGS) -o $@ $@.o $(LIBS)
coloredit : coloredit.o
	$(CC) $(CFLAGS) -o $@ $@.o $(LIBS)


@EOF

chmod 644 ch6/Makefile

echo x - ch6/getpixel.c
cat >ch6/getpixel.c <<'@EOF'
/**********************************************************************************
  * getpixel.c: Test the rgb functions from chapter 6
  *         From:
  *                   The X Window System, 
  *            Programming and Applications with Xt
  *                   OSF/Motif Edition
  *         by
  *                Douglas Young
  *              Prentice Hall, 1990
  *
  *                 Example described on pages:   ??
  *
  *
  *  Copyright 1989 by Prentice Hall
  *  All Rights Reserved
  *
  * This code is based on the OSF/Motif widget set and the X Window System
  *
  * Permission to use, copy, modify, and distribute this software for 
  * any purpose and without fee is hereby granted, provided that the above
  * copyright notice appear in all copies and that both the copyright notice
  * and this permission notice appear in supporting documentation.
  *
  * Prentice Hall and the author disclaim all warranties with regard to 
  * this software, including all implied warranties of merchantability and fitness.
  * In no event shall Prentice Hall or the author be liable for any special,
  * indirect or cosequential damages or any damages whatsoever resulting from 
  * loss of use, data or profits, whether in an action of contract, negligence 
  * or other tortious action, arising out of or in connection with the use 
  * or performance of this software.
  *
  * Open Software Foundation is a trademark of The Open Software Foundation, Inc.
  * OSF is a trademark of Open Software Foundation, Inc.
  * OSF/Motif is a trademark of Open Software Foundation, Inc.
  * Motif is a trademark of Open Software Foundation, Inc.
  * DEC is a registered trademark of Digital Equipment Corporation
  * HP is a registered trademark of the Hewlett Packard Company
  * DIGITAL is a registered trademark of Digital Equipment Corporation
  * X Window System is a trademark of the Massachusetts Institute of Technology
  **********************************************************************************/

#include <X11/Intrinsic.h> 

main(argc, argv)
    int   argc;
    char *argv[];
  {
    Widget toplevel;
    int red, green, blue;
    /*
     * Initialize the Intrinsics.
     */
    toplevel = XtInitialize(argv[0], "Getpixel", NULL, 0, 
                            &argc, argv);
    /*
     * Create a Core widget.
     */
    XtCreateManagedWidget("widget", widgetClass, 
                           toplevel, NULL, 0);

    printf("%d\n", get_pixel(toplevel, 1000, 2000, 3000));
    printf("%d\n", get_pixel_by_name(toplevel, "Red"));
    load_rgb(toplevel, &red, &green, &blue);
    printf("%d %d %d\n", red, green, blue);
    XtRealizeWidget(toplevel);

    XtMainLoop();
}

get_pixel(w, red, green, blue)
   Widget  w;
   int     red, green, blue;
{
   Display *dpy =  XtDisplay(w);
   int      scr =  DefaultScreen(dpy);
   Colormap cmap = DefaultColormap(dpy, scr);
   XColor   color;
   /* 
    * Fill in the color structure.
    */
   color.red   = red;
   color.green = green;
   color.blue  = blue;
   /* 
    * Try to allocate the color.
    */
   if(XAllocColor(dpy, cmap, &color))
      return (color.pixel);
   else {
      printf("Warning: Couldn't allocate requested color\n");
      return (BlackPixel(dpy, scr));
   }
}
load_rgb(w, red, green, blue)
   Widget  w;
   int    *red, *green, *blue;
{
   Display *dpy  = XtDisplay(w);
   int      scr  = DefaultScreen(dpy);
   Colormap cmap = DefaultColormap(dpy, scr);
   XColor   color;
   int      cells[3];
  /*
   *  Try to allocate three consecutive color cells.
   */
  if(XAllocColorCells(dpy, cmap, True, 
                      NULL, 0, cells, 3)){
    /* 
          *  If successful, create a red color struct, and store
     *  it in the first allocated cell. 
     */
    color.red = 65535;
    color.green = color.blue = 0;
    *red = color.pixel = cells[0];
    XStoreColor(dpy, cmap, &color);
    /*
     *  Store Green in the second cell.
     */
    color.green = 65535;
    color.red =  color.blue = 0;
    *green = color.pixel = cells[1];
    XStoreColor(dpy, cmap, &color);
    /* 
     * Store Blue in the second cell.
     */
    color.blue = 65535;
    color.red = color.green = 0;
    *blue = color.pixel = cells[2];
    XStoreColor(dpy, cmap, &color);
  }
  else{
    printf("Warning:Couldn't allocate color cells\n");
    *blue = *red = *green = BlackPixel(dpy, scr);
  }
}
get_pixel_by_name(w, colorname)
   Widget w;
   char  *colorname;
{
  Display *dpy  = XtDisplay(w);
  int      scr  = DefaultScreen(dpy);
  Colormap cmap = DefaultColormap(dpy, scr);
  XColor   color, ignore;
  /* 
   * Allocate the named color.
   */
  if(XAllocNamedColor(dpy, cmap, colorname, &color, &ignore))
    return (color.pixel);
  else{
    printf("Warning: Couldn't allocate color %s\n", colorname);
    return (BlackPixel(dpy, scr));
  }
}
@EOF

chmod 644 ch6/getpixel.c

echo x - ch6/coloredit.c
cat >ch6/coloredit.c <<'@EOF'
/**********************************************************************************
  * coloredit.c: A simple color editor.
  *         From:
  *                   The X Window System, 
  *            Programming and Applications with Xt
  *                   OSF/Motif Edition
  *         by
  *                Douglas Young
  *              Prentice Hall, 1990
  *
  *                 Example described on pages:   178-188 
  *
  *
  *  Copyright 1989 by Prentice Hall
  *  All Rights Reserved
  *
  * This code is based on the OSF/Motif widget set and the X Window System
  *
  * Permission to use, copy, modify, and distribute this software for 
  * any purpose and without fee is hereby granted, provided that the above
  * copyright notice appear in all copies and that both the copyright notice
  * and this permission notice appear in supporting documentation.
  *
  * Prentice Hall and the author disclaim all warranties with regard to 
  * this software, including all implied warranties of merchantability and fitness.
  * In no event shall Prentice Hall or the author be liable for any special,
  * indirect or cosequential damages or any damages whatsoever resulting from 
  * loss of use, data or profits, whether in an action of contract, negligence 
  * or other tortious action, arising out of or in connection with the use 
  * or performance of this software.
  *
  * Open Software Foundation is a trademark of The Open Software Foundation, Inc.
  * OSF is a trademark of Open Software Foundation, Inc.
  * OSF/Motif is a trademark of Open Software Foundation, Inc.
  * Motif is a trademark of Open Software Foundation, Inc.
  * DEC is a registered trademark of Digital Equipment Corporation
  * HP is a registered trademark of the Hewlett Packard Company
  * DIGITAL is a registered trademark of Digital Equipment Corporation
  * X Window System is a trademark of the Massachusetts Institute of Technology
  **********************************************************************************/


#include "coloredit.h"

main(argc, argv)
  int    argc;
  char  *argv[];
{
  Widget    toplevel, bb, sliders, rc;
  Colormap  def_colormap;
  XColor    Colors[MAXCOLORS];
  int       i;
 /*
  * Initialize the Intrinsics and save pointer to the display.
  */
  toplevel = XtInitialize(argv[0], "Coloredit", NULL, 0,
                          &argc, argv);
  dpy = XtDisplay(toplevel);
  /*
   * Determine the number of colors to be edited.
   */
  ncolors = DisplayCells(dpy, DefaultScreen(dpy));
if(ncolors > MAXCOLORS) ncolors = MAXCOLORS;
  /* 
   * Create a base to hold everything.
   */
  rc = XtCreateManagedWidget("base",xmRowColumnWidgetClass, 
                             toplevel, NULL, 0);
  /* 
   * Create a grid of buttons, one for each 
   * color to be edited.
   */
  create_color_bar(rc);
  /*
   * A separator widget looks nice, between the colors
   * and the controls.
   */
  XtCreateManagedWidget("sep", xmSeparatorWidgetClass,
                        rc, NULL, 0);
  /*
   * Put the controls inside an XmBulletinBoard widget
   */
  bb = XtCreateManagedWidget("controls",
                             xmBulletinBoardWidgetClass,
                             rc, NULL, 0);
  /*
   * Use an XmLabel widget to display the current rgb values.
   */
 color_display_panel = 
         XtCreateManagedWidget("display",
                               xmLabelWidgetClass, 
                         					      bb, NULL,0);
  /*
   * Create a row column widget containing three sliders,
   * one for each color component.
   */
  sliders = XtCreateManagedWidget("sliderpanel",
                                   xmRowColumnWidgetClass,
                                   bb, NULL, 0);
  red_slider   = make_slider("red", sliders,
                             red_slider_moved);
  green_slider = make_slider("green", sliders,
                             green_slider_moved);
  blue_slider  = make_slider("blue",  sliders,
                            blue_slider_moved);
  /* 
   * Add a quit button.
   */
  xs_create_quit_button(bb);
  /*
   * Get the ID of the default colormap.
   */
  def_colormap = DefaultColormap(dpy, DefaultScreen(dpy));
  for( i = 0; i < ncolors; i++ ) {
    Colors[i].pixel = i;
    Colors[i].flags = DoRed|DoGreen|DoBlue;
  }
  XQueryColors(dpy, def_colormap, Colors, ncolors);
  my_colormap = 
       XCreateColormap(dpy, DefaultRootWindow(dpy), 
                       DefaultVisual(dpy, DefaultScreen(dpy)),
                       AllocAll);
  XStoreColors(dpy, my_colormap, Colors, ncolors);
  /*
   * Initialize the pixel member of the global color struct
   * To the first editable color cell.
   */
  current_color.pixel = 0;

  XtRealizeWidget(toplevel);

  XSetWindowColormap(dpy, XtWindow(toplevel), my_colormap);

  XtMainLoop();
}

Widget make_slider(name, parent, callback) 
  char  *name;
  Widget parent;
  void (*callback)();
{
   Widget  w;
  int     n;
  Arg     wargs[10];
  /*
   * Create an XmScale widget.
   */
  n = 0;
  XtSetArg(wargs[n], XmNminimum, 0); n++;
  XtSetArg(wargs[n], XmNmaximum, 65535); n++;

  w = XtCreateManagedWidget(name, xmScaleWidgetClass, 
                            parent, wargs, n);
  /*
   * Add callbacks to be invoked when the slider moves.
   */
  XtAddCallback(w, XmNvalueChangedCallback, callback,NULL);
  XtAddCallback(w, XmNdragCallback, callback, NULL);

  return (w);
}

Widget create_color_bar(parent)
  Widget parent;
{
  Widget      panel;
  WidgetList  colors;
  int         i, n;
  char        name[10];
  Arg         wargs[10];
 colors = (WidgetList) XtMalloc( ncolors * sizeof(Widget));
  
  /*
   * Create the row column manager to hold all 
   * color buttons.
   */
  n = 0;
  panel = XtCreateManagedWidget("colorpanel",
                                xmRowColumnWidgetClass,
                                parent, wargs, n);
  /* 
   * Create ncolors widgets. Use the relative color 
   * cell number as the name of each color. Add a 
   * XmNactivateCallback for each cell with the color 
   * index as client_data.
   */
  for(i=0;i<ncolors;i++){
   n = 0;
   XtSetArg(wargs[n], XtNbackground, i); n++; 
   sprintf(name,"%d",i);
   colors[i] = XtCreateWidget(name, xmLabelWidgetClass, 
                              panel, wargs, n);
   XtAddEventHandler(colors[i], ButtonPressMask, False,
                     set_current_color, i);
   }
   XtManageChildren(colors, ncolors);
  
   return panel;
}

void red_slider_moved(w, client_data, call_data)
     Widget   w;
     caddr_t  client_data;
     XmScaleCallbackStruct *call_data;
{
 /*
  * Set the red color components of  the global 
  * current_color structure.
  */
  current_color.red =  call_data->value;
  /*
   * Update the digital rgb display and the current 
   * color label.
   */
  update_color();
}

void blue_slider_moved(w, client_data, call_data)
     Widget   w;
     caddr_t  client_data;
     XmScaleCallbackStruct *call_data;
{
 /*
  * Set the blue color components of  the global 
  * current_color structure.
  */
  current_color.blue =  call_data->value;
  /*
   * Update the digital rgb display and the current 
   * color label.
   */
  update_color();
}

void green_slider_moved(w, client_data, call_data)
     Widget   w;
     caddr_t  client_data;
     XmScaleCallbackStruct *call_data;
{
 /*
  * Set the green color components of  the global 
  * current_color structure.
  */
  current_color.green =  call_data->value;
  /*
   * Update the digital rgb display and the current 
   * color label.
   */
  update_color();
}

update_color()
{
  Arg  wargs[1];
  char str[25];

  /*
   * Update the digital display.
   */
xs_wprintf(color_display_panel, "%3d %3d %3d", 
           current_color.red, current_color.green, 
           current_color.blue);
 /*
  * Update the current color.
  */
  XStoreColor(dpy, my_colormap, &current_color); 
}

void set_current_color(w, number, event)
  Widget   w;
  int      number;
  XEvent  *event;
{
  Arg wargs[10];
  current_color.flags = DoRed | DoGreen | DoBlue;
  /*
   * Get the current color components of the selected button.
   */
  current_color.pixel = number;
  XQueryColor(dpy, my_colormap, &current_color);
  /*
   * Use each color component to as the new 
   * position of the corresponding slider.
   */
  XtSetArg(wargs[0], XmNvalue, current_color.red);
  XtSetValues(red_slider, wargs, 1);

  XtSetArg(wargs[0], XmNvalue, current_color.green);
  XtSetValues(green_slider, wargs, 1);

  XtSetArg(wargs[0], XmNvalue, current_color.blue);
  XtSetValues(blue_slider, wargs, 1);
}
@EOF

chmod 644 ch6/coloredit.c

echo x - ch6/coloredit.h
cat >ch6/coloredit.h <<'@EOF'
/**********************************************************************************
  * coloredit.h: Header file for coloredit
  *         From:
  *                   The X Window System, 
  *            Programming and Applications with Xt
  *                   OSF/Motif Edition
  *         by
  *                Douglas Young
  *              Prentice Hall, 1990
  *
  *                 Example described on pages:   178-188 
  *
  *
  *  Copyright 1989 by Prentice Hall
  *  All Rights Reserved
  *
  * This code is based on the OSF/Motif widget set and the X Window System
  *
  * Permission to use, copy, modify, and distribute this software for 
  * any purpose and without fee is hereby granted, provided that the above
  * copyright notice appear in all copies and that both the copyright notice
  * and this permission notice appear in supporting documentation.
  *
  * Prentice Hall and the author disclaim all warranties with regard to 
  * this software, including all implied warranties of merchantability and fitness.
  * In no event shall Prentice Hall or the author be liable for any special,
  * indirect or cosequential damages or any damages whatsoever resulting from 
  * loss of use, data or profits, whether in an action of contract, negligence 
  * or other tortious action, arising out of or in connection with the use 
  * or performance of this software.
  *
  * Open Software Foundation is a trademark of The Open Software Foundation, Inc.
  * OSF is a trademark of Open Software Foundation, Inc.
  * OSF/Motif is a trademark of Open Software Foundation, Inc.
  * Motif is a trademark of Open Software Foundation, Inc.
  * DEC is a registered trademark of Digital Equipment Corporation
  * HP is a registered trademark of the Hewlett Packard Company
  * DIGITAL is a registered trademark of Digital Equipment Corporation
  * X Window System is a trademark of the Massachusetts Institute of Technology
  **********************************************************************************/


#include <X11/StringDefs.h>
#include <X11/Intrinsic.h> 
#include <Xm/Xm.h>
#include <Xm/BulletinB.h>
#include <Xm/Separator.h>
#include <Xm/Scale.h>
#include <Xm/RowColumn.h>
#include <Xm/Label.h>
#include <Xm/PushB.h>
#include "libXs.h"

#define MAXCOLORS   256 

Display    *dpy;
Colormap    my_colormap;
XColor      current_color;
int         ncolors;

Widget      red_slider, 
            blue_slider, 
            green_slider,  
            color_display_panel;
void        slider_selected();
void        red_slider_moved();
void        green_slider_moved();
void        blue_slider_moved();
void        set_current_color();
Widget      make_slider();
Widget      create_color_bar();
@EOF

chmod 644 ch6/coloredit.h

chmod 775 ch6

echo mkdir - ch7
mkdir ch7

echo x - ch7/Makefile
cat >ch7/Makefile <<'@EOF'
CC = cc 
XSLIBDIR = ../lib
DEBUG = 
# HP Machines
CFLAGS = $(DEBUG) -DSYSV  -I$(XSLIBDIR) 
# DEC and Sun
#CFLAGS = $(DEBUG) -I$(XSLIBDIR)

LIBS = ../lib/libXs.a -lXm -lXt -lX11

.o:.c

all: xlogo xlogo2 raster

xlogo : xlogo.o
	$(CC) $(CFLAGS) -o $@ $@.o $(LIBS)

xlogo2 : xlogo2.o
	$(CC) $(CFLAGS) -o $@ $@.o $(LIBS)

raster : raster.o
	$(CC) $(CFLAGS) -o $@ $@.o $(LIBS)



@EOF

chmod 644 ch7/Makefile

echo x - ch7/xlogo.c
cat >ch7/xlogo.c <<'@EOF'
/**********************************************************************************
 * xlogo.c: Display the X logo
  *         From:
  *                   The X Window System, 
  *            Programming and Applications with Xt
  *                   OSF/Motif Edition
  *         by
  *                Douglas Young
  *              Prentice Hall, 1990
  *
  *                 Example described on pages:  191-196
  *
  *
  *  Copyright 1989 by Prentice Hall
  *  All Rights Reserved
  *
  * This code is based on the OSF/Motif widget set and the X Window System
  *
  * Permission to use, copy, modify, and distribute this software for 
  * any purpose and without fee is hereby granted, provided that the above
  * copyright notice appear in all copies and that both the copyright notice
  * and this permission notice appear in supporting documentation.
  *
  * Prentice Hall and the author disclaim all warranties with regard to 
  * this software, including all implied warranties of merchantability and fitness.
  * In no event shall Prentice Hall or the author be liable for any special,
  * indirect or cosequential damages or any damages whatsoever resulting from 
  * loss of use, data or profits, whether in an action of contract, negligence 
  * or other tortious action, arising out of or in connection with the use 
  * or performance of this software.
  *
  * Open Software Foundation is a trademark of The Open Software Foundation, Inc.
  * OSF is a trademark of Open Software Foundation, Inc.
  * OSF/Motif is a trademark of Open Software Foundation, Inc.
  * Motif is a trademark of Open Software Foundation, Inc.
  * DEC is a registered trademark of Digital Equipment Corporation
  * HP is a registered trademark of the Hewlett Packard Company
  * DIGITAL is a registered trademark of Digital Equipment Corporation
  * X Window System is a trademark of the Massachusetts Institute of Technology
  **********************************************************************************/

#include <X11/StringDefs.h>
#include <X11/Intrinsic.h> 
#include <Xm/Xm.h>
#include <Xm/DrawingA.h>
#include <X11/Xutil.h>
#include "xlogo64"

void     redisplay();
void     resize();
extern Pixmap create_logo();

typedef struct {
   Pixmap     pix;
   GC         gc;
   Dimension  width, height;
} pixmap_data;

main(argc, argv)
  int   argc;
  char *argv[];
{
  Widget       toplevel, canvas;
  Arg          wargs[10];
  int          n;
  XGCValues    values;
  pixmap_data  data;
    
  toplevel = XtInitialize(argv[0], "Xlogo", NULL, 0, 
                          &argc, argv);
  /*
   * Create a widget in which to display the logo.
   */
  canvas = XtCreateManagedWidget("canvas", 
                                 xmDrawingAreaWidgetClass, 
                                 toplevel, NULL, 0);
 /*
  * Use the foreground and background colors
  * of the canvas to create a graphics context.
  */
  n = 0;
  XtSetArg(wargs[n], XtNforeground, &values.foreground);n++;
  XtSetArg(wargs[n], XtNbackground, &values.background);n++;
  XtGetValues(canvas, wargs, n);
  data.gc = XtGetGC(canvas, GCForeground | GCBackground, &values);
  /*
   * Create the pixmap conatinign the X logo. Store the 
   * pixmap, as well as the size of the pixmap in the struct.
   */
  data.width = xlogo64_width;
  data.height = xlogo64_height;
  data.pix = create_logo(canvas, data.gc, xlogo64_bits, 
                         xlogo64_width, xlogo64_height );

  XtAddCallback(canvas, XmNexposeCallback, redisplay, &data); 
  XtAddCallback(canvas, XmNresizeCallback, resize, &data);

  XtRealizeWidget(toplevel);
  XtMainLoop();
}

Pixmap create_logo(w, gc, bits, width, height)
   Widget   w;
   char    *bits;
   int      width, height;
{
   Pixmap    bitmap, pix;
  /*
   * Create a bitmap from the data.
   */
  bitmap = XCreateBitmapFromData(XtDisplay(w),  
                               RootWindowOfScreen(XtScreen(w)),
                               bits, width, height);
  /* 
   * Create a pixmap of the same depth as the default screen.
   */
  pix = XCreatePixmap(XtDisplay(w), 
                      RootWindowOfScreen(XtScreen(w)),
                      width, height,
                      DefaultDepthOfScreen(XtScreen(w)));
    /*
   * Copy the contents of plane 1 of the bitmap to the 
   * pixmap, using the widget's colors.
   */
  XCopyPlane(XtDisplay(w), bitmap, pix, gc, 0, 0, 
             xlogo64_width, xlogo64_height, 0, 0, 1);
  /*
   * We don't need the bitmap anymore, so free it.
   */
  XFreePixmap(XtDisplay(w), bitmap);
  return pix;
}


void redisplay (w, data, call_data)
     Widget        w;
     pixmap_data   *data;
     XmDrawingAreaCallbackStruct *call_data;
{
  Arg       wargs[2];
  Dimension widget_width, widget_height;
  int       n;
  /*
   * Get the current size of the widget window.
   */ 
  n = 0;
  XtSetArg(wargs[n], XtNwidth,  &widget_width); n++;
  XtSetArg(wargs[n], XtNheight, &widget_height);n++;
  XtGetValues(w, wargs, n);
  /*
   * Copy the contents of the pixmap to the 
   * center of the window.
   */
  XCopyArea(XtDisplay(w), data->pix, XtWindow(w), data->gc,
            0, 0, data->width, data->height, 
            (widget_width  - data->width) / 2,  
            (widget_height - data->height) / 2);
}

void resize (w, data, call_data)
   Widget                       w;
   caddr_t                      data;
   XmDrawingAreaCallbackStruct *call_data;
   {
    if(XtIsRealized(w))
      XClearArea(XtDisplay(w), XtWindow(w), 0, 0, 0, 0, TRUE);
   }
@EOF

chmod 644 ch7/xlogo.c

echo x - ch7/xlogo64
cat >ch7/xlogo64 <<'@EOF'
#define xlogo64_width 64
#define xlogo64_height 64
static char xlogo64_bits[] = {
   0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf8, 0xfe, 0xff, 0x01, 0x00,
   0x00, 0x00, 0x00, 0xf8, 0xfc, 0xff, 0x03, 0x00, 0x00, 0x00, 0x00, 0x7c,
   0xf8, 0xff, 0x07, 0x00, 0x00, 0x00, 0x00, 0x3e, 0xf8, 0xff, 0x07, 0x00,
   0x00, 0x00, 0x00, 0x1f, 0xf0, 0xff, 0x0f, 0x00, 0x00, 0x00, 0x80, 0x0f,
   0xe0, 0xff, 0x1f, 0x00, 0x00, 0x00, 0x80, 0x0f, 0xc0, 0xff, 0x3f, 0x00,
   0x00, 0x00, 0xc0, 0x07, 0xc0, 0xff, 0x3f, 0x00, 0x00, 0x00, 0xe0, 0x03,
   0x80, 0xff, 0x7f, 0x00, 0x00, 0x00, 0xf0, 0x01, 0x00, 0xff, 0xff, 0x00,
   0x00, 0x00, 0xf8, 0x00, 0x00, 0xfe, 0xff, 0x01, 0x00, 0x00, 0xf8, 0x00,
   0x00, 0xfe, 0xff, 0x01, 0x00, 0x00, 0x7c, 0x00, 0x00, 0xfc, 0xff, 0x03,
   0x00, 0x00, 0x3e, 0x00, 0x00, 0xf8, 0xff, 0x07, 0x00, 0x00, 0x1f, 0x00,
   0x00, 0xf0, 0xff, 0x0f, 0x00, 0x80, 0x0f, 0x00, 0x00, 0xf0, 0xff, 0x0f,
   0x00, 0xc0, 0x07, 0x00, 0x00, 0xe0, 0xff, 0x1f, 0x00, 0xc0, 0x07, 0x00,
   0x00, 0xc0, 0xff, 0x3f, 0x00, 0xe0, 0x03, 0x00, 0x00, 0x80, 0xff, 0x7f,
   0x00, 0xf0, 0x01, 0x00, 0x00, 0x80, 0xff, 0x7f, 0x00, 0xf8, 0x00, 0x00,
   0x00, 0x00, 0xff, 0xff, 0x00, 0x7c, 0x00, 0x00, 0x00, 0x00, 0xfe, 0xff,
   0x01, 0x7c, 0x00, 0x00, 0x00, 0x00, 0xfc, 0xff, 0x03, 0x3e, 0x00, 0x00,
   0x00, 0x00, 0xfc, 0xff, 0x03, 0x1f, 0x00, 0x00, 0x00, 0x00, 0xf8, 0xff,
   0x87, 0x0f, 0x00, 0x00, 0x00, 0x00, 0xf0, 0xff, 0xcf, 0x07, 0x00, 0x00,
   0x00, 0x00, 0xe0, 0xff, 0xcf, 0x07, 0x00, 0x00, 0x00, 0x00, 0xe0, 0xff,
   0xe7, 0x03, 0x00, 0x00, 0x00, 0x00, 0xc0, 0xff, 0xf3, 0x01, 0x00, 0x00,
   0x00, 0x00, 0x80, 0xff, 0xf9, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff,
   0xfc, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7f, 0xfe, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x7e, 0xfe, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3e,
   0xff, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x9f, 0xff, 0x07, 0x00, 0x00,
   0x00, 0x00, 0x80, 0xcf, 0xff, 0x07, 0x00, 0x00, 0x00, 0x00, 0xc0, 0xe7,
   0xff, 0x0f, 0x00, 0x00, 0x00, 0x00, 0xc0, 0xe7, 0xff, 0x1f, 0x00, 0x00,
   0x00, 0x00, 0xe0, 0xc3, 0xff, 0x3f, 0x00, 0x00, 0x00, 0x00, 0xf0, 0xc1,
   0xff, 0x3f, 0x00, 0x00, 0x00, 0x00, 0xf8, 0x80, 0xff, 0x7f, 0x00, 0x00,
   0x00, 0x00, 0x7c, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x7c, 0x00,
   0xfe, 0xff, 0x01, 0x00, 0x00, 0x00, 0x3e, 0x00, 0xfe, 0xff, 0x01, 0x00,
   0x00, 0x00, 0x1f, 0x00, 0xfc, 0xff, 0x03, 0x00, 0x00, 0x80, 0x0f, 0x00,
   0xf8, 0xff, 0x07, 0x00, 0x00, 0xc0, 0x07, 0x00, 0xf0, 0xff, 0x0f, 0x00,
   0x00, 0xe0, 0x03, 0x00, 0xf0, 0xff, 0x0f, 0x00, 0x00, 0xe0, 0x03, 0x00,
   0xe0, 0xff, 0x1f, 0x00, 0x00, 0xf0, 0x01, 0x00, 0xc0, 0xff, 0x3f, 0x00,
   0x00, 0xf8, 0x00, 0x00, 0x80, 0xff, 0x7f, 0x00, 0x00, 0x7c, 0x00, 0x00,
   0x80, 0xff, 0x7f, 0x00, 0x00, 0x3e, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00,
   0x00, 0x3e, 0x00, 0x00, 0x00, 0xfe, 0xff, 0x01, 0x00, 0x1f, 0x00, 0x00,
   0x00, 0xfc, 0xff, 0x03, 0x80, 0x0f, 0x00, 0x00, 0x00, 0xfc, 0xff, 0x03,
   0xc0, 0x07, 0x00, 0x00, 0x00, 0xf8, 0xff, 0x07, 0xe0, 0x03, 0x00, 0x00,
   0x00, 0xf0, 0xff, 0x0f, 0xe0, 0x03, 0x00, 0x00, 0x00, 0xe0, 0xff, 0x1f,
   0xf0, 0x01, 0x00, 0x00, 0x00, 0xe0, 0xff, 0x1f, 0xf8, 0x00, 0x00, 0x00,
   0x00, 0xc0, 0xff, 0x3f, 0x7c, 0x00, 0x00, 0x00, 0x00, 0x80, 0xff, 0x7f,
   0x3e, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff};
@EOF

chmod 444 ch7/xlogo64

echo x - ch7/xlogo2.c
cat >ch7/xlogo2.c <<'@EOF'
/**********************************************************************************
   * xlog2o.c: Display the X logo
  *         From:
  *                   The X Window System, 
  *            Programming and Applications with Xt
  *                   OSF/Motif Edition
  *         by
  *                Douglas Young
  *              Prentice Hall, 1990
  *
  *                 Example described on pages:  195-196
  *
  *
  *  Copyright 1989 by Prentice Hall
  *  All Rights Reserved
  *
  * This code is based on the OSF/Motif widget set and the X Window System
  *
  * Permission to use, copy, modify, and distribute this software for 
  * any purpose and without fee is hereby granted, provided that the above
  * copyright notice appear in all copies and that both the copyright notice
  * and this permission notice appear in supporting documentation.
  *
  * Prentice Hall and the author disclaim all warranties with regard to 
  * this software, including all implied warranties of merchantability and fitness.
  * In no event shall Prentice Hall or the author be liable for any special,
  * indirect or cosequential damages or any damages whatsoever resulting from 
  * loss of use, data or profits, whether in an action of contract, negligence 
  * or other tortious action, arising out of or in connection with the use 
  * or performance of this software.
  *
  * Open Software Foundation is a trademark of The Open Software Foundation, Inc.
  * OSF is a trademark of Open Software Foundation, Inc.
  * OSF/Motif is a trademark of Open Software Foundation, Inc.
  * Motif is a trademark of Open Software Foundation, Inc.
  * DEC is a registered trademark of Digital Equipment Corporation
  * HP is a registered trademark of the Hewlett Packard Company
  * DIGITAL is a registered trademark of Digital Equipment Corporation
  * X Window System is a trademark of the Massachusetts Institute of Technology
  **********************************************************************************/


#include <X11/StringDefs.h>
#include <X11/Intrinsic.h> 
#include <Xm/Xm.h>
#include <Xm/DrawingA.h>
#include <X11/Xutil.h>
#include "xlogo64"

void     redisplay();
void     resize();
extern Pixmap create_logo();

typedef struct {
   Pixmap     pix;
   GC         gc;
   Dimension  width, height;
} pixmap_data;

main(argc, argv)
  int   argc;
  char *argv[];
{
  Widget       toplevel, canvas;
  Arg          wargs[10];
  int          n;
  XGCValues    values;
  pixmap_data  data;
    
  toplevel = XtInitialize(argv[0], "Xlogo", NULL, 0, 
                          &argc, argv);
  /*
   * Create a widget in which to display the logo.
   */
  canvas = XtCreateManagedWidget("canvas", 
                                 xmDrawingAreaWidgetClass, 
                                 toplevel, NULL, 0);
 /*
  * Use the foreground and background colors
  * of the canvas to create a graphics context.
  */
  n = 0;
  XtSetArg(wargs[n], XtNforeground, &values.foreground);n++;
  XtSetArg(wargs[n], XtNbackground, &values.background);n++;
  XtGetValues(canvas, wargs, n);
  data.gc = XtGetGC(canvas, GCForeground | GCBackground, &values);
  /*
   * Create the pixmap conatinign the X logo. Store the 
   * pixmap, as well as the size of the pixmap in the struct.
   */
  data.width = xlogo64_width;
  data.height = xlogo64_height;
  data.pix = create_logo(canvas, data.gc, xlogo64_bits, 
                         xlogo64_width, xlogo64_height );

  XtAddCallback(canvas, XmNexposeCallback, redisplay, &data); 
  XtAddCallback(canvas, XmNresizeCallback, resize, &data);

  XtRealizeWidget(toplevel);
  XtMainLoop();
}

Pixmap create_logo(w, gc, bits, width, height)
   Widget   w;
   char    *bits;
   int      width, height;
{
   Pixmap bitmap;
  /* 
   * Create a bitmap containing the logo.
   */
  bitmap=XCreateBitmapFromData(XtDisplay(w), 
                               RootWindowOfScreen(XtScreen(w)),
                               bits, width, height);
  return bitmap;
}

void redisplay (w, data, call_data)
     Widget         w;
     pixmap_data   *data;
     XmDrawingAreaCallbackStruct *call_data;
{
  Arg wargs[10];
  int n;
  Dimension widget_width, widget_height;
  /* 
   * Get the current size of the widget window.
   */
  n = 0;
  XtSetArg(wargs[n], XtNwidth,  &widget_width);n++;
  XtSetArg(wargs[n], XtNheight, &widget_height);n++;
  XtGetValues(w, wargs, n);
  /*
   * Copy plane 1 of the bitmap to the center
   * of the window, using the widget's foreground 
   * and background color.
   */
  XCopyPlane(XtDisplay(w), data->pix, XtWindow(w), data->gc,
             0, 0,  data->width, data->height, 
             (widget_width - data->width)/ 2,  
             (widget_height - data->height)/ 2, 1);
}


void resize (w, data, call_data)
   Widget                       w;
   caddr_t                      data;
   XmDrawingAreaCallbackStruct *call_data;
   {
    if(XtIsRealized(w))
      XClearArea(XtDisplay(w), XtWindow(w), 0, 0, 0, 0, TRUE);
   }
@EOF

chmod 644 ch7/xlogo2.c

echo x - ch7/raster.c
cat >ch7/raster.c <<'@EOF'
/**********************************************************************************
  * browser.c : Display some tiling patterns
  *         From:
  *                   The X Window System, 
  *            Programming and Applications with Xt
  *                   OSF/Motif Edition
  *         by
  *                Douglas Young
  *              Prentice Hall, 1990
  *
  *                 Example described on pages:  199-203
  *
  *
  *  Copyright 1989 by Prentice Hall
  *  All Rights Reserved
  *
  * This code is based on the OSF/Motif widget set and the X Window System
  *
  * Permission to use, copy, modify, and distribute this software for 
  * any purpose and without fee is hereby granted, provided that the above
  * copyright notice appear in all copies and that both the copyright notice
  * and this permission notice appear in supporting documentation.
  *
  * Prentice Hall and the author disclaim all warranties with regard to 
  * this software, including all implied warranties of merchantability and fitness.
  * In no event shall Prentice Hall or the author be liable for any special,
  * indirect or cosequential damages or any damages whatsoever resulting from 
  * loss of use, data or profits, whether in an action of contract, negligence 
  * or other tortious action, arising out of or in connection with the use 
  * or performance of this software.
  *
  * Open Software Foundation is a trademark of The Open Software Foundation, Inc.
  * OSF is a trademark of Open Software Foundation, Inc.
  * OSF/Motif is a trademark of Open Software Foundation, Inc.
  * Motif is a trademark of Open Software Foundation, Inc.
  * DEC is a registered trademark of Digital Equipment Corporation
  * HP is a registered trademark of the Hewlett Packard Company
  * DIGITAL is a registered trademark of Digital Equipment Corporation
  * X Window System is a trademark of the Massachusetts Institute of Technology
  **********************************************************************************/


#include <X11/StringDefs.h>
#include <X11/Intrinsic.h> 
#include <Xm/Xm.h>
#include "libXs.h"
static unsigned char fg_bitmap[32] = {   /*  foreground */
      0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
      0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
      0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
      0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff  
};

#define fg_width  16
#define fg_height 16

static char *patterns[] = {  "foreground", 
                             "background",
                             "25_foreground",
                             "50_foreground",
                             "75_foreground",
                             "vertical",
                             "horizontal",
                             "slant_right",
                             "slant_left",
                           };
main(argc, argv)
   int   argc;
   char *argv[];
 {
   Widget toplevel, browser;
   
   toplevel = XtInitialize(argv[0], "Browser", NULL, 0, 
                           &argc, argv);
   xs_register_pattern(toplevel, "foreground", 
                       fg_bitmap, fg_width, fg_height);   
   /*
    * Create the browser.
    */
   browser = xs_create_pixmap_browser(toplevel,patterns, 
                                      XtNumber(patterns), 
                                      NULL, NULL);
   XtManageChild(browser);
   XtRealizeWidget(toplevel);
   XtMainLoop();
}

@EOF

chmod 644 ch7/raster.c

chmod 775 ch7

echo mkdir - ch9
mkdir ch9

echo x - ch9/fileview.h
cat >ch9/fileview.h <<'@EOF'
/**********************************************************************************
  * fileview.h: declarations for fileview program
  *         From:
  *                   The X Window System, 
  *            Programming and Applications with Xt
  *                   OSF/Motif Edition
  *         by
  *                Douglas Young
  *              Prentice Hall, 1990
  *
  *                 Example described on pages:  220-230
  *
  *
  *  Copyright 1989 by Prentice Hall
  *  All Rights Reserved
  *
  * This code is based on the OSF/Motif widget set and the X Window System
  *
  * Permission to use, copy, modify, and distribute this software for 
  * any purpose and without fee is hereby granted, provided that the above
  * copyright notice appear in all copies and that both the copyright notice
  * and this permission notice appear in supporting documentation.
  *
  * Prentice Hall and the author disclaim all warranties with regard to 
  * this software, including all implied warranties of merchantability and fitness.
  * In no event shall Prentice Hall or the author be liable for any special,
  * indirect or cosequential damages or any damages whatsoever resulting from 
  * loss of use, data or profits, whether in an action of contract, negligence 
  * or other tortious action, arising out of or in connection with the use 
  * or performance of this software.
  *
  * Open Software Foundation is a trademark of The Open Software Foundation, Inc.
  * OSF is a trademark of Open Software Foundation, Inc.
  * OSF/Motif is a trademark of Open Software Foundation, Inc.
  * Motif is a trademark of Open Software Foundation, Inc.
  * DEC is a registered trademark of Digital Equipment Corporation
  * HP is a registered trademark of the Hewlett Packard Company
  * DIGITAL is a registered trademark of Digital Equipment Corporation
  * X Window System is a trademark of the Massachusetts Institute of Technology
  **********************************************************************************/


#include <stdio.h>
#include <X11/Intrinsic.h> 

#include <X11/StringDefs.h>
#include <X11/Xutil.h>
#include <Xm/Xm.h>
#include <Xm/DrawingA.h>
#include <Xm/ScrolledW.h>
#include <Xm/ScrollBar.h>
#include "libXs.h"

#define MAXLINESIZE  300
#define MAXLINES    2000
#define MIN(a,b)     (((a) < (b)) ? (a) : (b))
#define ABS(a)       (((a) >= 0) ? (a) : -(a))
#define MAX(a,b)     ((a > b) ? a : b)
#define MARGIN         5


typedef struct {
  char         *chars[MAXLINES];   /* Lines of text         */
  int           length[MAXLINES];  /* Length of each line   */
  int           rbearing[MAXLINES];/* right bearing of line */
  int           descent;           /* descent below baseline*/
  XFontStruct  *font;              /* The font struct       */
  GC            gc;                /* A read/write GC       */
  Widget        scrollbar;
  Widget        canvas;
  Dimension     canvas_height;     /* canvas dimensions     */
  Dimension     canvas_width;
  int           fontheight;        /* descent + ascent      */
  int           nitems;            /* number of text lines  */
  int           top;               /* line at top of window */
 } text_data, *text_data_ptr;

void       handle_exposures();
void       scroll_bar_moved ();
void       resize ();

static XtResource resources[] = {
 {XtNfont, XtCFont, XtRFontStruct, sizeof (XFontStruct *),
    XtOffset(text_data_ptr, font), XtRString, "Fixed"      },
};
@EOF

chmod 644 ch9/fileview.h

echo x - ch9/fileview.c
cat >ch9/fileview.c <<'@EOF'
/**********************************************************************************
 * fileview.c: a file viewer
  *         From:
  *                   The X Window System, 
  *            Programming and Applications with Xt
  *                   OSF/Motif Edition
  *         by
  *                Douglas Young
  *              Prentice Hall, 1990
  *
  *                 Example described on pages:  220-230
  *
  *
  *  Copyright 1989 by Prentice Hall
  *  All Rights Reserved
  *
  * This code is based on the OSF/Motif widget set and the X Window System
  *
  * Permission to use, copy, modify, and distribute this software for 
  * any purpose and without fee is hereby granted, provided that the above
  * copyright notice appear in all copies and that both the copyright notice
  * and this permission notice appear in supporting documentation.
  *
  * Prentice Hall and the author disclaim all warranties with regard to 
  * this software, including all implied warranties of merchantability and fitness.
  * In no event shall Prentice Hall or the author be liable for any special,
  * indirect or cosequential damages or any damages whatsoever resulting from 
  * loss of use, data or profits, whether in an action of contract, negligence 
  * or other tortious action, arising out of or in connection with the use 
  * or performance of this software.
  *
  * Open Software Foundation is a trademark of The Open Software Foundation, Inc.
  * OSF is a trademark of Open Software Foundation, Inc.
  * OSF/Motif is a trademark of Open Software Foundation, Inc.
  * Motif is a trademark of Open Software Foundation, Inc.
  * DEC is a registered trademark of Digital Equipment Corporation
  * HP is a registered trademark of the Hewlett Packard Company
  * DIGITAL is a registered trademark of Digital Equipment Corporation
  * X Window System is a trademark of the Massachusetts Institute of Technology
  **********************************************************************************/


#include "fileview.h" 

extern Widget create_scrollbar ();

main (argc, argv)
  int       argc;
  char     *argv[];
{
  Widget     toplevel, sb, sw;
  Arg        wargs[10];
  int        n;
  text_data  data;

  toplevel = XtInitialize (argv[0], "Fileview", 
                           NULL, 0, &argc, argv);
  XtGetApplicationResources (toplevel, &data, resources,
                              XtNumber (resources), NULL, 0);
 /*
  * Read the file specified in argv[1] into the
  * text buffer. 
  */
 load_file (&data, (argc == 2) ? argv[1] : NULL);
 /*
  * Create a ScrolledWindow widget as a base. 
  */
 sw = XtCreateManagedWidget ("framework", 
                             xmScrolledWindowWidgetClass,
                             toplevel, NULL, 0);
 /*
  * Create the drawing surface.
  */
 data.canvas= XtCreateManagedWidget("canvas",
                                    xmDrawingAreaWidgetClass,
                                    sw, NULL, 0);
 /*
  * Determine the initial size of the canvas and store it
  */
 XtSetArg (wargs[0], XtNheight, &data.canvas_height);
 XtSetArg (wargs[1], XtNwidth, &data.canvas_width);
 XtGetValues (data.canvas, wargs, 2);
 /*
  * Register callbacks for resizes and exposes.
  */
 XtAddCallback (data.canvas, XmNexposeCallback, 
                handle_exposures, &data);
 XtAddCallback (data.canvas, XmNresizeCallback, 
                resize, &data);
 /*
  * Create the scrollbar
  */
 data.scrollbar = create_scrollbar (sw, &data);
 /*
  * Registee the scrollbar and work area for the
  * ScrolledWindow widget.
  */
 n = 0;
 XtSetArg(wargs[n], XmNverticalScrollBar, data.scrollbar);n++;
 XtSetArg(wargs[n], XmNworkWindow, data.canvas); n++;
 XtSetValues(sw, wargs, n);

 XtRealizeWidget (toplevel);
 create_gc (&data);
 XtMainLoop ();
}

load_file (data, filename)
  text_data    *data;
  char         *filename;
{
  int           foreground, background, i, dir, ascent, desc;
  XCharStruct   char_info;
  FILE         *fp, *fopen ();
  char          buf[MAXLINESIZE];
  /*
   * Open the file. 
   */
  if ((fp = fopen (filename, "r")) == NULL) {
    fprintf (stderr, "Unable to open %s\n", filename);
    exit (1);
  }
  /*
   * Read each line of the file into the buffer,
   * calculating and caching the extents of
   * each line. 
   */
  i = 0;
  while ((fgets (buf, MAXLINESIZE, fp)) != NULL && 
          i < MAXLINES) {
   data->chars[i] = XtMalloc (strlen (buf) + 1);
    buf[strlen (buf) - 1] = '\0';
    strcpy (data->chars[i], buf);
    data->length[i] = strlen (data->chars[i]);
    XTextExtents(data->font, data->chars[i],
                 data->length[i], &dir, &ascent, 
                 &desc, &char_info);
    data->rbearing[i] = char_info.rbearing;
    data->descent     = desc;
    data->fontheight  = ascent + desc;
    i++;
  }
  /*
   * Close the file.
   */
  fclose(fp);
  /*
   * Remember the number of lines, and initialize the
   * current line number to be 0.
   */
  data->nitems = i;
  data->top = 0;
}

Widget create_scrollbar (parent, data)
  Widget        parent;
  text_data    *data;
{
  Arg    wargs[10];
  int    n = 0;
  Widget scrollbar;
  /*
   * Set the scrollbar so that movements are
   * reported in terms of lines of text. Set the
   * scrolling increment to a single line, and the page
   * increment to the number of lines the canvas widget
   * can hold. Also set the slider size to be proportional.
   */
  XtSetArg (wargs[n], XmNminimum, 0);  n++;
  XtSetArg (wargs[n], XmNmaximum, data->nitems);  n++;
  XtSetArg (wargs[n], XmNincrement, 1);  n++;	
#ifndef JUST_LIKE_BOOK
  XtSetArg (wargs[n], XmNsliderSize, data->canvas_height / data->fontheight);n++;
#else
  /*
   * Dumb. All this work just to find out it is equivalent to the number
   * of lines in the view area.
   */
  XtSetArg (wargs[n], XmNsliderSize, 
	            (data->canvas_height * data->canvas_height) / 
        	    (data->nitems * data->fontheight) );  n++;
#endif
  XtSetArg (wargs[n], XmNpageIncrement,
	            data->canvas_height/ data->fontheight);  n++;
  scrollbar = XtCreateManagedWidget ("scrollbar",
                                     xmScrollBarWidgetClass,
                                     parent, wargs, n);
  XtAddCallback (scrollbar, XmNvalueChangedCallback,
                 scroll_bar_moved, data);
  XtAddCallback (scrollbar, XmNdragCallback,
                 scroll_bar_moved, data);
  return scrollbar;
}

create_gc (data)
  text_data  *data;
{
  XGCValues  gcv;
  Display   *dpy  = XtDisplay(data->canvas);
  Window     w    = XtWindow(data->canvas);
  int        mask = GCFont | GCForeground | GCBackground;
  Arg        wargs[10];
  int        n;
  /*
   * Create a GC using the colors of the canvas widget.
   */
   n = 0;
   XtSetArg(wargs[n], XtNforeground, &gcv.foreground); n++;
   XtSetArg(wargs[n], XtNbackground, &gcv.background); n++;
   XtGetValues(data->canvas, wargs, n);
  
   gcv.font       = data->font->fid;
   data->gc       = XCreateGC (dpy, w, mask, &gcv);
}

void handle_exposures (w, data, cb)
   Widget          w;
   text_data      *data;
   XmDrawingAreaCallbackStruct *cb;
{
  int     yloc = 0, index = data->top;
  Region  region;
  /*
   * Create a region and add the contents of the of the event
   */
   region = XCreateRegion();

   XtAddExposureToRegion(cb->event, region);
  /*
   * Set the clip mask of the GC.
   */
  XSetRegion (XtDisplay(w), data->gc, region); 
  /*
   * Loop through each line until the bottom of the
   * window is reached, or we run out of lines. Redraw any 
   * lines that intersect the exposed region.
   */
  while (index < data->nitems && yloc < data->canvas_height) {
    yloc += data->fontheight;
    if(XRectInRegion(region, MARGIN, yloc - data->fontheight,
                     data->rbearing[index],
                     data->fontheight) != RectangleOut)  
       XDrawImageString(XtDisplay (w), XtWindow (w), data->gc,
                         MARGIN, yloc, data->chars[index], 
                         data->length[index]);
    index++;
  }
  /*
   * Free the region.
   */
   XDestroyRegion(region);
}

void scroll_bar_moved (w, data, call_data)
  Widget          w;
  text_data      *data;
  XmScrollBarCallbackStruct *call_data;
{
  data->top = call_data->value;
  XClearArea (XtDisplay (w), XtWindow (data->canvas), 
              0, 0, 0, 0, TRUE);
}
void resize (w, data, call_data)
  Widget          w;
  text_data      *data;
  caddr_t         call_data;
{
  Arg   wargs[10];
  int   n;
  /*
   * Determine the new widget of the canvas widget.
   */
  n = 0;
  XtSetArg (wargs[n], XtNheight, &data->canvas_height);n++;
  XtSetArg (wargs[n], XtNwidth,  &data->canvas_width);n++;
  XtGetValues (w, wargs, n);
  /*
   * Reset the scrollbar slider to indictae the relative
   * proportion of text displayed and also the new page size.
   */
  n = 0;
#ifndef JUST_LIKE_BOOK
  XtSetArg (wargs[n], XmNsliderSize, data->canvas_height / data->fontheight);n++;
#else
  /*
   * Dumb. All this work just to find out it is equivalent to the number
   * of lines in the view area.
   */
  XtSetArg (wargs[n], XmNsliderSize, 
	            (data->canvas_height * data->canvas_height) / 
        	    (data->nitems * data->fontheight) );  n++;
#endif
  XtSetArg (wargs[n], XmNpageIncrement, 
            data->canvas_height / data->fontheight);  n++;
  XtSetValues (data->scrollbar, wargs, n);
}
@EOF

chmod 644 ch9/fileview.c

echo x - ch9/Makefile
cat >ch9/Makefile <<'@EOF'
CC = cc 
XSLIBDIR = ../lib
DEBUG = -g
# HP Machines
CFLAGS = $(DEBUG) -DSYSV  -I$(XSLIBDIR) 
# DEC and Sun
#CFLAGS = $(DEBUG) -I$(XSLIBDIR)

LIBS = ../lib/libXs.a -lXm -lXt -lX11

.o:.c

all: fileview fileview2 fileview3 fileview4

fileview: fileview.o
	$(CC) $(CFLAGS) -o $@ $@.o $(LIBS)

fileview2: fileview2.o
	$(CC) $(CFLAGS) -o $@ $@.o $(LIBS)

fileview3: fileview3.o
	$(CC) $(CFLAGS) -o $@ $@.o $(LIBS)

fileview4: fileview4.o
	$(CC) $(CFLAGS) -o $@ $@.o $(LIBS)

@EOF

chmod 644 ch9/Makefile

echo x - ch9/fileview2.c
cat >ch9/fileview2.c <<'@EOF'
/**********************************************************************************
  * fileview.c: a file viewer, adding smooth scrolling 
  *         From:
  *                   The X Window System, 
  *            Programming and Applications with Xt
  *                   OSF/Motif Edition
  *         by
  *                Douglas Young
  *              Prentice Hall, 1990
  *
  *                 Example described on pages:  230-233
  *
  *
  *  Copyright 1989 by Prentice Hall
  *  All Rights Reserved
  *
  * This code is based on the OSF/Motif widget set and the X Window System
  *
  * Permission to use, copy, modify, and distribute this software for 
  * any purpose and without fee is hereby granted, provided that the above
  * copyright notice appear in all copies and that both the copyright notice
  * and this permission notice appear in supporting documentation.
  *
  * Prentice Hall and the author disclaim all warranties with regard to 
  * this software, including all implied warranties of merchantability and fitness.
  * In no event shall Prentice Hall or the author be liable for any special,
  * indirect or cosequential damages or any damages whatsoever resulting from 
  * loss of use, data or profits, whether in an action of contract, negligence 
  * or other tortious action, arising out of or in connection with the use 
  * or performance of this software.
  *
  * Open Software Foundation is a trademark of The Open Software Foundation, Inc.
  * OSF is a trademark of Open Software Foundation, Inc.
  * OSF/Motif is a trademark of Open Software Foundation, Inc.
  * Motif is a trademark of Open Software Foundation, Inc.
  * DEC is a registered trademark of Digital Equipment Corporation
  * HP is a registered trademark of the Hewlett Packard Company
  * DIGITAL is a registered trademark of Digital Equipment Corporation
  * X Window System is a trademark of the Massachusetts Institute of Technology
  **********************************************************************************/


#include "fileview.h" 

extern Widget create_scrollbar ();


main (argc, argv)
  int       argc;
  char     *argv[];
{
  Widget     toplevel, sb, sw;
  Arg        wargs[10];
  int        n;
  text_data  data;

  toplevel = XtInitialize (argv[0], "Fileview", 
                           NULL, 0, &argc, argv);
  XtGetApplicationResources (toplevel, &data, resources,
                              XtNumber (resources), NULL, 0);
 /*
  * Read the file specified in argv[1] into the
  * text buffer. 
  */
 load_file (&data, (argc == 2) ? argv[1] : NULL);
 /*
  * Create a ScrolledWindow widget as a base. 
  */
 sw = XtCreateManagedWidget ("framework", 
                             xmScrolledWindowWidgetClass,
                             toplevel, NULL, 0);
 /*
  * Create the drawing surface.
  */
 data.canvas= XtCreateManagedWidget("canvas",
                                    xmDrawingAreaWidgetClass,
                                    sw, NULL, 0);
 /*
  * Determine the initial size of the canvas and store it
  */
 XtSetArg (wargs[0], XtNheight, &data.canvas_height);
 XtSetArg (wargs[1], XtNwidth, &data.canvas_width);
 XtGetValues (data.canvas, wargs, 2);
 /*
  * Register callbacks for resizes and exposes.
  */
 XtAddCallback (data.canvas, XmNexposeCallback, 
                handle_exposures, &data);
 XtAddCallback (data.canvas, XmNresizeCallback, 
                resize, &data);
 /*
  * Create the scrollbar
  */
 data.scrollbar = create_scrollbar (sw, &data);
 /*
  * Registee the scrollbar and work area for the
  * ScrolledWindow widget.
  */
 n = 0;
 XtSetArg(wargs[n], XmNverticalScrollBar, data.scrollbar);n++;
 XtSetArg(wargs[n], XmNworkWindow, data.canvas); n++;
 XtSetValues(sw, wargs, n);

 XtRealizeWidget (toplevel);
 create_gc (&data);
 XtMainLoop ();
}

load_file (data, filename)
  text_data    *data;
  char         *filename;
{
  int           foreground, background, i, dir, ascent, desc;
  XCharStruct   char_info;
  FILE         *fp, *fopen ();
  char          buf[MAXLINESIZE];
  /*
   * Open the file. 
   */
  if ((fp = fopen (filename, "r")) == NULL) {
    fprintf (stderr, "Unable to open %s\n", filename);
    exit (1);
  }
  /*
   * Read each line of the file into the buffer,
   * calculating and caching the extents of
   * each line. 
   */
  i = 0;
  while ((fgets (buf, MAXLINESIZE, fp)) != NULL && 
          i < MAXLINES) {
   data->chars[i] = XtMalloc (strlen (buf) + 1);
    buf[strlen (buf) - 1] = '\0';
    strcpy (data->chars[i], buf);
    data->length[i] = strlen (data->chars[i]);
    XTextExtents(data->font, data->chars[i],
                 data->length[i], &dir, &ascent, 
                 &desc, &char_info);
    data->rbearing[i] = char_info.rbearing;
    data->descent     = desc;
    data->fontheight  = ascent + desc;
    i++;
  }
  /*
   * Close the file.
   */
  fclose(fp);
  /*
   * Remember the number of lines, and initialize the
   * current line number to be 0.
   */
  data->nitems = i;
  data->top = 0;
}

Widget create_scrollbar (parent, data)
  Widget        parent;
  text_data    *data;
{
  Arg    wargs[10];
  int    n = 0;
  Widget scrollbar;
  /*
   * Set the scrollbar so that movements are
   * reported in terms of lines of text. Set the
   * scrolling increment to a single line, and the page
   * increment to the number of lines the canvas widget
   * can hold. Also set the slider size to be proportional.
   */
  XtSetArg (wargs[n], XmNminimum, 0);  n++;
  XtSetArg (wargs[n], XmNmaximum, data->nitems);  n++;
  XtSetArg (wargs[n], XmNincrement, 1);  n++;	
#ifndef JUST_LIKE_BOOK
  XtSetArg (wargs[n], XmNsliderSize, data->canvas_height / data->fontheight);n++;
#else
  /*
   * Dumb. All this work just to find out it is equivalent to the number
   * of lines in the view area.
   */
  XtSetArg (wargs[n], XmNsliderSize, 
	            (data->canvas_height * data->canvas_height) / 
        	    (data->nitems * data->fontheight) );  n++;
#endif
  XtSetArg (wargs[n], XmNpageIncrement,
	            data->canvas_height/ data->fontheight);  n++;
  scrollbar = XtCreateManagedWidget ("scrollbar",
                                     xmScrollBarWidgetClass,
                                     parent, wargs, n);
  XtAddCallback (scrollbar, XmNvalueChangedCallback,
                 scroll_bar_moved, data);
  XtAddCallback (scrollbar, XmNdragCallback,
                 scroll_bar_moved, data);
  return scrollbar;
}

create_gc (data)
  text_data  *data;
{
  XGCValues  gcv;
  Display   *dpy  = XtDisplay(data->canvas);
  Window     w    = XtWindow(data->canvas);
  int        mask = GCFont | GCForeground | GCBackground;
  Arg        wargs[10];
  int        n;
  /*
   * Create a GC using the colors of the canvas widget.
   */
   n = 0;
   XtSetArg(wargs[n], XtNforeground, &gcv.foreground); n++;
   XtSetArg(wargs[n], XtNbackground, &gcv.background); n++;
   XtGetValues(data->canvas, wargs, n);
  
   gcv.font       = data->font->fid;
   data->gc       = XCreateGC (dpy, w, mask, &gcv);

}



void handle_exposures (w, data, cb)
   Widget          w;
   text_data      *data;
   XmDrawingAreaCallbackStruct *cb;
{
  int     yloc = 0, index = data->top;
  Region  region;
  /*
   * Create a region and add the contents of the of the event
   */
   region = XCreateRegion();

   XtAddExposureToRegion(cb->event, region);
  /*
   * Set the clip mask of the GC.
   */
  XSetRegion (XtDisplay(w), data->gc, region); 
  /*
   * Loop through each line until the bottom of the
   * window is reached, or we run out of lines. Redraw any 
   * lines that intersect the exposed region.
   */
  while (index < data->nitems && yloc < data->canvas_height) {
    yloc += data->fontheight;
    if(XRectInRegion(region, MARGIN, yloc - data->fontheight,
                     data->rbearing[index],
                     data->fontheight) != RectangleOut)  
       XDrawImageString(XtDisplay (w), XtWindow (w), data->gc,
                         MARGIN, yloc, data->chars[index], 
                         data->length[index]);
    index++;
  }
  /*
   * Free the region.
   */
   XDestroyRegion(region);
}

void scroll_bar_moved(w, data, call_data)
     Widget     w;
     text_data *data;
     XmScrollBarCallbackStruct *call_data;
{
   int     sliderpos = call_data->value;
   int     ysrc,  redraw_top, delta;
   
   /* 
    * Compute number of pixels the text needs to be moved.
    */
   delta = ABS((data->top - sliderpos) * data->fontheight);   
   delta = MIN(delta, data->canvas_height);
   /*
    * If we are scrolling down, we start at zero and simply 
    * move by the delta. The portion that must be redrawn
    * is simply between zero and delta.
    */ 
   ysrc = redraw_top = 0;
   /* 
    * If we are scrolling up, we start at the delta and move
    * to zero. The part to redraw lies between the bottom
    * of the window and the bottom - delta.
    */
   if(sliderpos >= data->top){ 
     ysrc        =  delta;
     redraw_top  =  data->canvas_height - delta;
   }
   /*
    * Set the top line of the text buffer.
    */
   data->top = sliderpos;
   /*
    * Move the existing text to its new position.
    * Turn off any clipping on the GC first.
    */
   XSetClipMask(XtDisplay(w), data->gc, None);
   XCopyArea(XtDisplay(data->canvas), XtWindow(data->canvas), 
                       XtWindow(data->canvas), data->gc,
                       0, ysrc, 
                       data->canvas_width,  
                       data->canvas_height - delta,
                       0,  delta - ysrc);
   /*
    * Clear the remaining area of any old text, 
    * Request server to generate Expose events for the
    * area by setting exposures to TRUE.
    */
   XClearArea(XtDisplay(w), XtWindow(data->canvas),
	      0, redraw_top,
	      0, delta, TRUE); 
}


void resize (w, data, call_data)
  Widget          w;
  text_data      *data;
  caddr_t         call_data;
{
  Arg   wargs[10];
  int   n;
  /*
   * Determine the new widget of the canvas widget.
   */
  n = 0;
  XtSetArg (wargs[n], XtNheight, &data->canvas_height);n++;
  XtSetArg (wargs[n], XtNwidth,  &data->canvas_width);n++;
  XtGetValues (w, wargs, n);
  /*
   * Reset the scrollbar slider to indictae the relative
   * proportion of text displayed and also the new page size.
   */
  n = 0;
#ifndef JUST_LIKE_BOOK
  XtSetArg (wargs[n], XmNsliderSize, data->canvas_height / data->fontheight);n++;
#else
  /*
   * Dumb. All this work just to find out it is equivalent to the number
   * of lines in the view area.
   */
  XtSetArg (wargs[n], XmNsliderSize, 
	            (data->canvas_height * data->canvas_height) / 
        	    (data->nitems * data->fontheight) );  n++;
#endif
  XtSetArg (wargs[n], XmNpageIncrement, 
            data->canvas_height / data->fontheight);  n++;
  XtSetValues (data->scrollbar, wargs, n);
}
@EOF

chmod 644 ch9/fileview2.c

echo x - ch9/fileview3.c
cat >ch9/fileview3.c <<'@EOF'
/**********************************************************************************
  * fileview.c: a file viewer, using compound strings
  *         From:
  *                   The X Window System, 
  *            Programming and Applications with Xt
  *                   OSF/Motif Edition
  *         by
  *                Douglas Young
  *              Prentice Hall, 1990
  *
  *                 Example described on pages:  241-235
  *
  *
  *  Copyright 1989 by Prentice Hall
  *  All Rights Reserved
  *
  * This code is based on the OSF/Motif widget set and the X Window System
  *
  * Permission to use, copy, modify, and distribute this software for 
  * any purpose and without fee is hereby granted, provided that the above
  * copyright notice appear in all copies and that both the copyright notice
  * and this permission notice appear in supporting documentation.
  *
  * Prentice Hall and the author disclaim all warranties with regard to 
  * this software, including all implied warranties of merchantability and fitness.
  * In no event shall Prentice Hall or the author be liable for any special,
  * indirect or cosequential damages or any damages whatsoever resulting from 
  * loss of use, data or profits, whether in an action of contract, negligence 
  * or other tortious action, arising out of or in connection with the use 
  * or performance of this software.
  *
  * Open Software Foundation is a trademark of The Open Software Foundation, Inc.
  * OSF is a trademark of Open Software Foundation, Inc.
  * OSF/Motif is a trademark of Open Software Foundation, Inc.
  * Motif is a trademark of Open Software Foundation, Inc.
  * DEC is a registered trademark of Digital Equipment Corporation
  * HP is a registered trademark of the Hewlett Packard Company
  * DIGITAL is a registered trademark of Digital Equipment Corporation
  * X Window System is a trademark of the Massachusetts Institute of Technology
  **********************************************************************************/



#include "fileview3.h" 

extern Widget create_scrollbar ();

main (argc, argv)
  int       argc;
  char     *argv[];
{
  Widget     toplevel, sb, sw;
  Arg        wargs[10];
  int        n;
  text_data  data;

  toplevel = XtInitialize (argv[0], "Fileview", 
                           NULL, 0, &argc, argv);
  XtGetApplicationResources (toplevel, &data, resources,
                              XtNumber (resources), NULL, 0);
  data.fontlist = XmFontListCreate (data.font, "Fileview_Charset");
 /*
  * Read the file specified in argv[1] into the
  * text buffer. 
  */
 load_file (&data, (argc == 2) ? argv[1] : NULL);
 /*
  * Create a ScrolledWindow widget as a base. 
  */
 sw = XtCreateManagedWidget ("framework", 
                             xmScrolledWindowWidgetClass,
                             toplevel, NULL, 0);
 /*
  * Create the drawing surface.
  */
 data.canvas= XtCreateManagedWidget("canvas",
                                    xmDrawingAreaWidgetClass,
                                    sw, NULL, 0);
 /*
  * Determine the initial size of the canvas and store it
  */
 XtSetArg (wargs[0], XtNheight, &data.canvas_height);
 XtSetArg (wargs[1], XtNwidth, &data.canvas_width);
 XtGetValues (data.canvas, wargs, 2);
 /*
  * Register callbacks for resizes and exposes.
  */
 XtAddCallback (data.canvas, XmNexposeCallback, 
                handle_exposures, &data);
 XtAddCallback (data.canvas, XmNresizeCallback, 
                resize, &data);
 /*
  * Create the scrollbar
  */
 data.scrollbar = create_scrollbar (sw, &data);
 /*
  * Registee the scrollbar and work area for the
  * ScrolledWindow widget.
  */
 n = 0;
 XtSetArg(wargs[n], XmNverticalScrollBar, data.scrollbar);n++;
 XtSetArg(wargs[n], XmNworkWindow, data.canvas); n++;
 XtSetValues(sw, wargs, n);

 XtRealizeWidget (toplevel);
 create_gc (&data);
 XtMainLoop ();
}


Widget create_scrollbar (parent, data)
  Widget        parent;
  text_data    *data;
{
  Arg    wargs[10];
  int    n = 0;
  Widget scrollbar;
  /*
   * Set the scrollbar so that movements are
   * reported in terms of lines of text. Set the
   * scrolling increment to a single line, and the page
   * increment to the number of lines the canvas widget
   * can hold. Also set the slider size to be proportional.
   */
  XtSetArg (wargs[n], XmNminimum, 0);  n++;
  XtSetArg (wargs[n], XmNmaximum, data->nitems);  n++;
  XtSetArg (wargs[n], XmNincrement, 1);  n++;	
#ifndef JUST_LIKE_BOOK
  XtSetArg (wargs[n], XmNsliderSize, data->canvas_height / data->fontheight);n++;
#else
  /*
   * Dumb. All this work just to find out it is equivalent to the number
   * of lines in the view area.
   */
  XtSetArg (wargs[n], XmNsliderSize, 
	            (data->canvas_height * data->canvas_height) / 
        	    (data->nitems * data->fontheight) );   n++;
#endif
  XtSetArg (wargs[n], XmNpageIncrement,
	            data->canvas_height/ data->fontheight);  n++;
  scrollbar = XtCreateManagedWidget ("scrollbar",
                                     xmScrollBarWidgetClass,
                                     parent, wargs, n);
  XtAddCallback (scrollbar, XmNvalueChangedCallback,
                 scroll_bar_moved, data);
  XtAddCallback (scrollbar, XmNdragCallback,
                 scroll_bar_moved, data);
  return scrollbar;
}

create_gc (data)
  text_data  *data;
{
  XGCValues  gcv;
  Display   *dpy  = XtDisplay(data->canvas);
  Window     w    = XtWindow(data->canvas);
  int        mask = GCFont | GCForeground | GCBackground;
  Arg        wargs[10];
  int        n;
  /*
   * Create a GC using the colors of the canvas widget.
   */
   n = 0;
   XtSetArg(wargs[n], XtNforeground, &gcv.foreground); n++;
   XtSetArg(wargs[n], XtNbackground, &gcv.background); n++;
   XtGetValues(data->canvas, wargs, n);
  
   gcv.font       = data->font->fid;
   data->gc       = XCreateGC (dpy, w, mask, &gcv);
}

void scroll_bar_moved(w, data, call_data)
     Widget     w;
     text_data *data;
     XmScrollBarCallbackStruct *call_data;
{
   int     sliderpos = call_data->value;
   int     ysrc,  redraw_top, delta;
   
   /* 
    * Compute number of pixels the text needs to be moved.
    */
   delta = ABS((data->top - sliderpos) * data->fontheight);   
   delta = MIN(delta, data->canvas_height);
   /*
    * If we are scrolling down, we start at zero and simply 
    * move by the delta. The portion that must be redrawn
    * is simply between zero and delta.
    */ 
   ysrc = redraw_top = 0;
   /* 
    * If we are scrolling up, we start at the delta and move
    * to zero. The part to redraw lies between the bottom
    * of the window and the bottom - delta.
    */
   if(sliderpos >= data->top){ 
     ysrc        =  delta;
     redraw_top  =  data->canvas_height - delta;
   }
   /*
    * Set the top line of the text buffer.
    */
   data->top = sliderpos;
   /*
    * Move the existing text to its new position.
    * Turn off any clipping on the GC first.
    */
   XSetClipMask(XtDisplay(w), data->gc, None);
   XCopyArea(XtDisplay(data->canvas), XtWindow(data->canvas), 
                       XtWindow(data->canvas), data->gc,
                       0, ysrc, 
                       data->canvas_width,  
                       data->canvas_height - delta,
                       0,  delta - ysrc);
   /*
    * Clear the remaining area of any old text, 
    * Request server to generate Expose events for the
    * area by setting exposures to TRUE.
    */
   XClearArea(XtDisplay(w), XtWindow(data->canvas),
	      0, redraw_top,
	      0, delta, TRUE); 
}



void resize (w, data, call_data)
  Widget          w;
  text_data      *data;
  caddr_t         call_data;
{
  Arg   wargs[10];
  int   n;
  /*
   * Determine the new widget of the canvas widget.
   */
  n = 0;
  XtSetArg (wargs[n], XtNheight, &data->canvas_height);n++;
  XtSetArg (wargs[n], XtNwidth,  &data->canvas_width);n++;
  XtGetValues (w, wargs, n);
  /*
   * Reset the scrollbar slider to indictae the relative
   * proportion of text displayed and also the new page size.
   */
  n = 0;
#ifndef JUST_LIKE_BOOK
  XtSetArg (wargs[n], XmNsliderSize, data->canvas_height / data->fontheight);n++;
#else
  /*
   * Dumb. All this work just to find out it is equivalent to the number
   * of lines in the view area.
   */
  XtSetArg (wargs[n], XmNsliderSize, 
	            (data->canvas_height * data->canvas_height) / 
        	    (data->nitems * data->fontheight) );  n++;
#endif
  XtSetArg (wargs[n], XmNpageIncrement, data->canvas_height / data->fontheight);  n++;
  XtSetValues (data->scrollbar, wargs, n);
}

load_file (data, filename)
  text_data      *data;
  char           *filename;
{
  XCharStruct     char_info;
  FILE           *fp, *fopen ();
  char            buf[MAXLINESIZE];
  int             height, i;
  /*
   * Open the file. 
   */
  if ((fp = fopen (filename, "r")) == NULL) {
    fprintf (stderr, "Unable to open %s\n", filename);
    exit (1);
  }
  /*
   * Read each line of the file into the buffer,
   * calculating and caching the extents of
   * each line. 
   */
  i = 0;
  while ((fgets (buf, MAXLINESIZE, fp)) != NULL && 
          i < MAXLINES) {
    buf[strlen (buf) - 1] = ' ';
    data->chars[i] = XmStringCreate(buf, "Fileview_Charset");
    XmStringExtent (data->fontlist, data->chars[i], 
		    &data->width[i], &height);
    data->fontheight = MAX(data->fontheight, height);
    i++;
  }
  /*
   * Close the file.
   */
  fclose(fp);
  /*
   * Set the number of lines, and initialize the
   * current line number to be 0.
   */
  data->nitems = i;
  data->top = 0;
}

void handle_exposures (w, data, cb)
   Widget          w;
   text_data      *data;
   XmDrawingAreaCallbackStruct *cb;
{
  int        yloc = 0, 
             index = data->top;
   Region  region;
  /*
   * Create a region and add the 
   * contents of the of the event
   */
  region = XCreateRegion();
  XtAddExposureToRegion(cb->event, region);
  /*
   * Set the clip mask of the GC.
   */
  XSetRegion (XtDisplay(w), data->gc, region); 
  /*
   * Redraw each line until the bottom of the
   * window is reached, or we run out of lines. 
   */
  while (index < data->nitems && yloc < data->canvas_height) {
       XmStringDrawImage (XtDisplay (w), XtWindow (w), 
			  data->fontlist,
			  data->chars[index],
			  data->gc, 
			  MARGIN, yloc, data->width[index], 
			  XmALIGNMENT_BEGINNING,
			  XmSTRING_DIRECTION_R_TO_L,
			  NULL);
    yloc += data->fontheight;
    index++;
  }
  /*
   * Free the region.
   */
  XDestroyRegion(region);
}
@EOF

chmod 664 ch9/fileview3.c

echo x - ch9/fileview4.c
cat >ch9/fileview4.c <<'@EOF'
/**********************************************************************************
 * fileview.c: a file viewer, compressing expose events
  *         From:
  *                   The X Window System, 
  *            Programming and Applications with Xt
  *                   OSF/Motif Edition
  *         by
  *                Douglas Young
  *              Prentice Hall, 1990
  *
  *                 Example described on pages:   233-235
  *
  *
  *  Copyright 1989 by Prentice Hall
  *  All Rights Reserved
  *
  * This code is based on the OSF/Motif widget set and the X Window System
  *
  * Permission to use, copy, modify, and distribute this software for 
  * any purpose and without fee is hereby granted, provided that the above
  * copyright notice appear in all copies and that both the copyright notice
  * and this permission notice appear in supporting documentation.
  *
  * Prentice Hall and the author disclaim all warranties with regard to 
  * this software, including all implied warranties of merchantability and fitness.
  * In no event shall Prentice Hall or the author be liable for any special,
  * indirect or cosequential damages or any damages whatsoever resulting from 
  * loss of use, data or profits, whether in an action of contract, negligence 
  * or other tortious action, arising out of or in connection with the use 
  * or performance of this software.
  *
  * Open Software Foundation is a trademark of The Open Software Foundation, Inc.
  * OSF is a trademark of Open Software Foundation, Inc.
  * OSF/Motif is a trademark of Open Software Foundation, Inc.
  * Motif is a trademark of Open Software Foundation, Inc.
  * DEC is a registered trademark of Digital Equipment Corporation
  * HP is a registered trademark of the Hewlett Packard Company
  * DIGITAL is a registered trademark of Digital Equipment Corporation
  * X Window System is a trademark of the Massachusetts Institute of Technology
  **********************************************************************************/

#include "fileview.h" 

extern Widget create_scrollbar ();

main (argc, argv)
  int       argc;
  char     *argv[];
{
  Widget     toplevel, sb, sw;
  Arg        wargs[10];
  int        n;
  text_data  data;

  toplevel = XtInitialize (argv[0], "Fileview", 
                           NULL, 0, &argc, argv);
  XtGetApplicationResources (toplevel, &data, resources,
                              XtNumber (resources), NULL, 0);
 /*
  * Read the file specified in argv[1] into the
  * text buffer. 
  */
 load_file (&data, (argc == 2) ? argv[1] : NULL);
 /*
  * Create a ScrolledWindow widget as a base. 
  */
 sw = XtCreateManagedWidget ("framework", 
                             xmScrolledWindowWidgetClass,
                             toplevel, NULL, 0);
 /*
  * Create the drawing surface.
  */
 data.canvas= XtCreateManagedWidget("canvas",
                                    xmDrawingAreaWidgetClass,
                                    sw, NULL, 0);
 /*
  * Determine the initial size of the canvas and store it
  */
 XtSetArg (wargs[0], XtNheight, &data.canvas_height);
 XtSetArg (wargs[1], XtNwidth, &data.canvas_width);
 XtGetValues (data.canvas, wargs, 2);
 /*
  * Register callbacks for resizes and exposes.
  */
 XtAddCallback (data.canvas, XmNexposeCallback, 
                handle_exposures, &data);
 XtAddCallback (data.canvas, XmNresizeCallback, 
                resize, &data);
 /*
  * Create the scrollbar
  */
 data.scrollbar = create_scrollbar (sw, &data);
 /*
  * Register the scrollbar and work area for the
  * ScrolledWindow widget.
  */
 n = 0;
 XtSetArg(wargs[n], XmNverticalScrollBar, data.scrollbar);n++;
 XtSetArg(wargs[n], XmNworkWindow, data.canvas); n++;
 XtSetValues(sw, wargs, n);

 XtRealizeWidget (toplevel);
 create_gc (&data);
 XtMainLoop ();
}

load_file (data, filename)
  text_data    *data;
  char         *filename;
{
  int           foreground, background, i, dir, ascent, desc;
  XCharStruct   char_info;
  FILE         *fp, *fopen ();
  char          buf[MAXLINESIZE];
  /*
   * Open the file. 
   */
  if ((fp = fopen (filename, "r")) == NULL) {
    fprintf (stderr, "Unable to open %s\n", filename);
    exit (1);
  }
  /*
   * Read each line of the file into the buffer,
   * calculating and caching the extents of
   * each line. 
   */
  i = 0;
  while ((fgets (buf, MAXLINESIZE, fp)) != NULL && 
          i < MAXLINES) {
   data->chars[i] = XtMalloc (strlen (buf) + 1);
    buf[strlen (buf) - 1] = '\0';
    strcpy (data->chars[i], buf);
    data->length[i] = strlen (data->chars[i]);
    XTextExtents(data->font, data->chars[i],
                 data->length[i], &dir, &ascent, 
                 &desc, &char_info);
    data->rbearing[i] = char_info.rbearing;
    data->descent     = desc;
    data->fontheight  = ascent + desc;
    i++;
  }
  /*
   * Close the file.
   */
  fclose(fp);
  /*
   * Remember the number of lines, and initialize the
   * current line number to be 0.
   */
  data->nitems = i;
  data->top = 0;
}

Widget create_scrollbar (parent, data)
  Widget        parent;
  text_data    *data;
{
  Arg    wargs[10];
  int    n = 0;
  Widget scrollbar;
  /*
   * Set the scrollbar so that movements are
   * reported in terms of lines of text. Set the
   * scrolling increment to a single line, and the page
   * increment to the number of lines the canvas widget
   * can hold. Also set the slider size to be proportional.
   */
  XtSetArg (wargs[n], XmNminimum, 0);  n++;
  XtSetArg (wargs[n], XmNmaximum, data->nitems);  n++;
  XtSetArg (wargs[n], XmNincrement, 1);  n++;	
#ifndef JUST_LIKE_BOOK
  XtSetArg (wargs[n], XmNsliderSize, data->canvas_height / data->fontheight);n++;
#else
  /*
   * Dumb. All this work just to find out it is equivalent to the number
   * of lines in the view area.
   */
  XtSetArg (wargs[n], XmNsliderSize, 
	            (data->canvas_height * data->canvas_height) / 
        	    (data->nitems * data->fontheight) );  n++;
#endif
  XtSetArg (wargs[n], XmNpageIncrement,
	            data->canvas_height/ data->fontheight);  n++;
  scrollbar = XtCreateManagedWidget ("scrollbar",
                                     xmScrollBarWidgetClass,
                                     parent, wargs, n);
  XtAddCallback (scrollbar, XmNvalueChangedCallback,
                 scroll_bar_moved, data);
  XtAddCallback (scrollbar, XmNdragCallback,
                 scroll_bar_moved, data);
  return scrollbar;
}

create_gc (data)
  text_data  *data;
{
  XGCValues  gcv;
  Display   *dpy  = XtDisplay(data->canvas);
  Window     w    = XtWindow(data->canvas);
  int        mask = GCFont | GCForeground | GCBackground;
  Arg        wargs[10];
  int        n;
  /*
   * Create a GC using the colors of the canvas widget.
   */
   n = 0;
   XtSetArg(wargs[n], XtNforeground, &gcv.foreground); n++;
   XtSetArg(wargs[n], XtNbackground, &gcv.background); n++;
   XtGetValues(data->canvas, wargs, n);
  
   gcv.font       = data->font->fid;
   data->gc       = XCreateGC (dpy, w, mask, &gcv);
}

void handle_exposures (w, data, cb)
   Widget          w;
   text_data      *data;
   XmDrawingAreaCallbackStruct *cb;
{
  int     yloc = 0, index = data->top;
  static Region  region = NULL;
  /*
   * Create a region and add the contents of the of the event
   */
  if(!region)
    region = XCreateRegion();

  XtAddExposureToRegion(cb->event, region);

  if(cb->event->xexpose.count != 0)
    return;
  /*
   * Set the clip mask of the GC.
   */
  XSetRegion (XtDisplay(w), data->gc, region); 
  /*
   * Loop through each line until the bottom of the
   * window is reached, or we run out of lines. Redraw any 
   * lines that intersect the exposed region.
   */
  while (index < data->nitems && yloc < data->canvas_height) {
    yloc += data->fontheight;
    if(XRectInRegion(region, MARGIN, yloc - data->fontheight,
                     data->rbearing[index],
                     data->fontheight) != RectangleOut)  
       XDrawImageString(XtDisplay (w), XtWindow (w), data->gc,
                         MARGIN, yloc, data->chars[index], 
                         data->length[index]);
    index++;
  }
  /*
   * Free the region.
   */
   XDestroyRegion(region);
   region = NULL;
}

void scroll_bar_moved(w, data, call_data)
     Widget     w;
     text_data *data;
     XmScrollBarCallbackStruct *call_data;
{
   int     sliderpos = call_data->value;
   int     ysrc,  redraw_top, delta;
   
   /* 
    * Compute number of pixels the text needs to be moved.
    */
   delta = ABS((data->top - sliderpos) * data->fontheight);   
   delta = MIN(delta, data->canvas_height);
   /*
    * If we are scrolling down, we start at zero and simply 
    * move by the delta. The portion that must be redrawn
    * is simply between zero and delta.
    */ 
   ysrc = redraw_top = 0;
   /* 
    * If we are scrolling up, we start at the delta and move
    * to zero. The part to redraw lies between the bottom
    * of the window and the bottom - delta.
    */
   if(sliderpos >= data->top){ 
     ysrc        =  delta;
     redraw_top  =  data->canvas_height - delta;
   }
   /*
    * Set the top line of the text buffer.
    */
   data->top = sliderpos;
   /*
    * Move the existing text to its new position.
    * Turn off any clipping on the GC first.
    */
   XSetClipMask(XtDisplay(w), data->gc, None);
   XCopyArea(XtDisplay(data->canvas), XtWindow(data->canvas), 
                       XtWindow(data->canvas), data->gc,
                       0, ysrc, 
                       data->canvas_width,  
                       data->canvas_height - delta,
                       0,  delta - ysrc);
   /*
    * Clear the remaining area of any old text, 
    */
   XClearArea(XtDisplay(w), XtWindow(data->canvas),
	      0, redraw_top,
	      0, delta, FALSE); 
   {
     int     yloc = 0, index = data->top;
     while (index < data->nitems && yloc < data->canvas_height) {
       yloc += data->fontheight;
       if(yloc >= redraw_top
	  && (yloc - data->fontheight) <= (redraw_top + delta))
	 XDrawImageString(XtDisplay (w), XtWindow (data->canvas), data->gc,
			  MARGIN, yloc, data->chars[index], 
			  data->length[index]);
       index++;
     }
   }
}

void resize (w, data, call_data)
  Widget          w;
  text_data      *data;
  caddr_t         call_data;
{
  Arg   wargs[10];
  int   n;
  /*
   * Determine the new widget of the canvas widget.
   */
  n = 0;
  XtSetArg (wargs[n], XtNheight, &data->canvas_height);n++;
  XtSetArg (wargs[n], XtNwidth,  &data->canvas_width);n++;
  XtGetValues (w, wargs, n);
  /*
   * Reset the scrollbar slider to indictae the relative
   * proportion of text displayed and also the new page size.
   */
  n = 0;
#ifndef JUST_LIKE_BOOK
  XtSetArg (wargs[n], XmNsliderSize, data->canvas_height / data->fontheight);n++;
#else
  /*
   * Dumb. All this work just to find out it is equivalent to the number
   * of lines in the view area.
   */
  XtSetArg (wargs[n], XmNsliderSize, 
	            (data->canvas_height * data->canvas_height) / 
        	    (data->nitems * data->fontheight) );  n++;
#endif
  XtSetArg (wargs[n], XmNpageIncrement, 
            data->canvas_height / data->fontheight);  n++;
  XtSetValues (data->scrollbar, wargs, n);
}
@EOF

chmod 664 ch9/fileview4.c

echo x - ch9/fileview3.h
cat >ch9/fileview3.h <<'@EOF'
/**********************************************************************************
  * fileview2.h: declarations for fileview program
  *         From:
  *                   The X Window System, 
  *            Programming and Applications with Xt
  *                   OSF/Motif Edition
  *         by
  *                Douglas Young
  *              Prentice Hall, 1990
  *
  *                 Example described on pages:  241-235
  *
  *
  *  Copyright 1989 by Prentice Hall
  *  All Rights Reserved
  *
  * This code is based on the OSF/Motif widget set and the X Window System
  *
  * Permission to use, copy, modify, and distribute this software for 
  * any purpose and without fee is hereby granted, provided that the above
  * copyright notice appear in all copies and that both the copyright notice
  * and this permission notice appear in supporting documentation.
  *
  * Prentice Hall and the author disclaim all warranties with regard to 
  * this software, including all implied warranties of merchantability and fitness.
  * In no event shall Prentice Hall or the author be liable for any special,
  * indirect or cosequential damages or any damages whatsoever resulting from 
  * loss of use, data or profits, whether in an action of contract, negligence 
  * or other tortious action, arising out of or in connection with the use 
  * or performance of this software.
  *
  * Open Software Foundation is a trademark of The Open Software Foundation, Inc.
  * OSF is a trademark of Open Software Foundation, Inc.
  * OSF/Motif is a trademark of Open Software Foundation, Inc.
  * Motif is a trademark of Open Software Foundation, Inc.
  * DEC is a registered trademark of Digital Equipment Corporation
  * HP is a registered trademark of the Hewlett Packard Company
  * DIGITAL is a registered trademark of Digital Equipment Corporation
  * X Window System is a trademark of the Massachusetts Institute of Technology
  **********************************************************************************/


#include <stdio.h>
#include <X11/Intrinsic.h> 
#include <X11/StringDefs.h>
#include <X11/Xutil.h>
#include <Xm/Xm.h>
#include <Xm/DrawingA.h>
#include <Xm/ScrolledW.h>
#include <Xm/ScrollBar.h>
#include "libXs.h"

#define MAXLINESIZE  300
#define MAXLINES    2000
#define MIN(a,b)     (((a) < (b)) ? (a) : (b))
#define MAX(a,b)     (((a) > (b)) ? (a) : (b))
#define ABS(a) (((a) >= 0) ? (a) : -(a))
#define MARGIN         5

typedef struct {
  XmString      chars[MAXLINES];
  Dimension     width[MAXLINES];
  int           descent;
  XFontStruct   *font;
  XmFontList    fontlist;
  GC            gc;
  Widget        scrollbar;
  Widget        canvas;
  Dimension     canvas_height;
  Dimension     canvas_width;
  int           fontheight;
  int           nitems;
  int           top;
  } text_data, *text_data_ptr;

void       handle_exposures();
void       scroll_bar_moved ();
void       resize ();

static XtResource resources[] = {
  {XtNfont, XtCFont, XtRFontStruct, sizeof (XFontStruct *),
     XtOffset(text_data_ptr, font), XtRString, "Fixed"   }, 
};


@EOF

chmod 664 ch9/fileview3.h

echo x - ch9/fileview2.back
cat >ch9/fileview2.back <<'@EOF'
/*
 *                Copyright 1989 by Douglas A. Young
 *
 */
/**************************************************************
 * fileview.c: a file viewer, adding smooth scrolling 230-233
 **************************************************************/
#include "fileview.h" 

extern Widget create_scrollbar ();

main (argc, argv)
  int       argc;
  char     *argv[];
{
  Widget     toplevel, sb, sw;
  Arg        wargs[10];
  int        n;
  text_data  data;

  toplevel = XtInitialize (argv[0], "Fileview", 
                           NULL, 0, &argc, argv);
  XtGetApplicationResources (toplevel, &data, resources,
                              XtNumber (resources), NULL, 0);
 /*
  * Read the file specified in argv[1] into the
  * text buffer. 
  */
 load_file (&data, (argc == 2) ? argv[1] : NULL);
 /*
  * Create a ScrolledWindow widget as a base. 
  */
 sw = XtCreateManagedWidget ("framework", 
                             xmScrolledWindowWidgetClass,
                             toplevel, NULL, 0);
 /*
  * Create the drawing surface.
  */
 data.canvas= XtCreateManagedWidget("canvas",
                                    xmDrawingAreaWidgetClass,
                                    sw, NULL, 0);
 /*
  * Determine the initial size of the canvas and store it
  */
 XtSetArg (wargs[0], XtNheight, &data.canvas_height);
 XtSetArg (wargs[1], XtNwidth, &data.canvas_width);
 XtGetValues (data.canvas, wargs, 2);
 /*
  * Register callbacks for resizes and exposes.
  */
 XtAddCallback (data.canvas, XmNexposeCallback, 
                handle_exposures, &data);
 XtAddCallback (data.canvas, XmNresizeCallback, 
                resize, &data);
 /*
  * Create the scrollbar
  */
 data.scrollbar = create_scrollbar (sw, &data);
 /*
  * Registee the scrollbar and work area for the
  * ScrolledWindow widget.
  */
 n = 0;
 XtSetArg(wargs[n], XmNverticalScrollBar, data.scrollbar);n++;
 XtSetArg(wargs[n], XmNworkWindow, data.canvas); n++;
 XtSetValues(sw, wargs, n);

 XtRealizeWidget (toplevel);
 create_gc (&data);
 XtMainLoop ();
}

load_file (data, filename)
  text_data    *data;
  char         *filename;
{
  int           foreground, background, i, dir, ascent, desc;
  XCharStruct   char_info;
  FILE         *fp, *fopen ();
  char          buf[MAXLINESIZE];
  /*
   * Open the file. 
   */
  if ((fp = fopen (filename, "r")) == NULL) {
    fprintf (stderr, "Unable to open %s\n", filename);
    exit (1);
  }
  /*
   * Read each line of the file into the buffer,
   * calculating and caching the extents of
   * each line. 
   */
  i = 0;
  while ((fgets (buf, MAXLINESIZE, fp)) != NULL && 
          i < MAXLINES) {
   data->chars[i] = XtMalloc (strlen (buf) + 1);
    buf[strlen (buf) - 1] = '\0';
    strcpy (data->chars[i], buf);
    data->length[i] = strlen (data->chars[i]);
    XTextExtents(data->font, data->chars[i],
                 data->length[i], &dir, &ascent, 
                 &desc, &char_info);
    data->rbearing[i] = char_info.rbearing;
    data->descent     = desc;
    data->fontheight  = ascent + desc;
    i++;
  }
  /*
   * Close the file.
   */
  fclose(fp);
  /*
   * Remember the number of lines, and initialize the
   * current line number to be 0.
   */
  data->nitems = i;
  data->top = 0;
}

Widget create_scrollbar (parent, data)
  Widget        parent;
  text_data    *data;
{
  Arg    wargs[10];
  int    n = 0;
  Widget scrollbar;
  /*
   * Set the scrollbar so that movements are
   * reported in terms of lines of text. Set the
   * scrolling increment to a single line, and the page
   * increment to the number of lines the canvas widget
   * can hold. Also set the slider size to be proportional.
   */
  XtSetArg (wargs[n], XmNminimum, 0);  n++;
  XtSetArg (wargs[n], XmNmaximum, data->nitems);  n++;
  XtSetArg (wargs[n], XmNincrement, 1);  n++;	
  XtSetArg (wargs[n], XmNsliderSize, 
	            (data->canvas_height * data->canvas_height) / 
        	    (data->nitems * data->fontheight) );  n++;
  XtSetArg (wargs[n], XmNpageIncrement,
	            data->canvas_height/ data->fontheight);  n++;
  scrollbar = XtCreateManagedWidget ("scrollbar",
                                     xmScrollBarWidgetClass,
                                     parent, wargs, n);
  XtAddCallback (scrollbar, XmNvalueChangedCallback,
                 scroll_bar_moved, data);
  XtAddCallback (scrollbar, XmNdragCallback,
                 scroll_bar_moved, data);
  return scrollbar;
}

create_gc (data)
  text_data  *data;
{
  XGCValues  gcv;
  Display   *dpy  = XtDisplay(data->canvas);
  Window     w    = XtWindow(data->canvas);
  int        mask = GCFont | GCForeground | GCBackground;
  Arg        wargs[10];
  int        n;
  /*
   * Create a GC using the colors of the canvas widget.
   */
   n = 0;
   XtSetArg(wargs[n], XtNforeground, &gcv.foreground); n++;
   XtSetArg(wargs[n], XtNbackground, &gcv.background); n++;
   XtGetValues(data->canvas, wargs, n);
  
   gcv.font       = data->font->fid;
   data->gc       = XCreateGC (dpy, w, mask, &gcv);
   XSetGraphicsExposures(dpy, data->gc,True);
}

void handle_exposures (w, data, cb)
   Widget          w;
   text_data      *data;
   XmDrawingAreaCallbackStruct *cb;
{
  int     yloc = 0, index = data->top;
  Region  region;
  /*
   * Create a region and add the contents of the of the event
   */
   region = XCreateRegion();

   XtAddExposureToRegion(cb->event, region);
  /*
   * Set the clip mask of the GC.
   */
  XSetRegion (XtDisplay(w), data->gc, region); 
  /*
   * Loop through each line until the bottom of the
   * window is reached, or we run out of lines. Redraw any 
   * lines that intersect the exposed region.
   */
  while (index < data->nitems && yloc < data->canvas_height) {
    yloc += data->fontheight;
    if(XRectInRegion(region, MARGIN, yloc - data->fontheight,
                     data->rbearing[index],
                     data->fontheight) != RectangleOut)  
       XDrawImageString(XtDisplay (w), XtWindow (w), data->gc,
                         MARGIN, yloc, data->chars[index], 
                         data->length[index]);
    index++;
  }
  /*
   * Free the region.
   */
   XDestroyRegion(region);
}

void scroll_bar_moved(w, data, call_data)
     Widget     w;
     text_data *data;
     XmScrollBarCallbackStruct *call_data;
{
   int     sliderpos = call_data->value;
   int     ysrc,  redraw_top, delta;
   
   /* 
    * Compute number of pixels the text needs to be moved.
    */
   delta = ABS((data->top - sliderpos) * data->fontheight);   
   delta = MIN(delta, data->canvas_height);
   /*
    * If we are scrolling down, we start at zero and simply 
    * move by the delta. The portion that must be redrawn
    * is simply between zero and delta.
    */ 
   ysrc = redraw_top = 0;
   /* 
    * If we are scrolling up, we start at the delta and move
    * to zero. The part to redraw lies between the bottom
    * of the window and the bottom - delta.
    */
   if(sliderpos >= data->top){ 
     ysrc        =  delta;
     redraw_top  =  data->canvas_height - delta;
   }
   /*
    * Set the top line of the text buffer.
    */
   data->top = sliderpos;
   /*
    * Move the existing text to its new position.
    * Turn off any clipping on the GC first.
    */
   XSetClipMask(XtDisplay(w), data->gc, None);
   XCopyArea(XtDisplay(data->canvas), XtWindow(data->canvas), 
                       XtWindow(data->canvas), data->gc,
                       0, ysrc, 
                       data->canvas_width,  
                       data->canvas_height - delta,
                       0,  delta - ysrc);
   /*
    * Clear the remaining area of any old text, 
    * Request server to generate Expose events for the
    * area by setting exposures to TRUE.
    */
   XClearArea(XtDisplay(w), XtWindow(data->canvas),
	      0, redraw_top,
	      0, delta, TRUE); 
}




void resize (w, data, call_data)
  Widget          w;
  text_data      *data;
  caddr_t         call_data;
{
  Arg   wargs[10];
  int   n;
  /*
   * Determine the new widget of the canvas widget.
   */
  n = 0;
  XtSetArg (wargs[n], XtNheight, &data->canvas_height);n++;
  XtSetArg (wargs[n], XtNwidth,  &data->canvas_width);n++;
  XtGetValues (w, wargs, n);
  /*
   * Reset the scrollbar slider to indictae the relative
   * proportion of text displayed and also the new page size.
   */
  n = 0;
  XtSetArg (wargs[n], XmNsliderSize, 
	            (data->canvas_height * data->canvas_height) / 
        	    (data->nitems * data->fontheight) );  n++;
  XtSetArg (wargs[n], XmNpageIncrement, 
            data->canvas_height / data->fontheight);  n++;
  XtSetValues (data->scrollbar, wargs, n);
}
@EOF

chmod 644 ch9/fileview2.back

echo x - ch9/fileview5.c
cat >ch9/fileview5.c <<'@EOF'
/**********************************************************************************
 * fileview.c: a file viewer, compressing expose events
  *         From:
  *                   The X Window System, 
  *            Programming and Applications with Xt
  *                   OSF/Motif Edition
  *         by
  *                Douglas Young
  *              Prentice Hall, 1990
  *
  *                 Example described on pages:   not in book
  *                       Adds a graphics expose handler
  *
  *
  *  Copyright 1989 by Prentice Hall
  *  All Rights Reserved
  *
  * This code is based on the OSF/Motif widget set and the X Window System
  *
  * Permission to use, copy, modify, and distribute this software for 
  * any purpose and without fee is hereby granted, provided that the above
  * copyright notice appear in all copies and that both the copyright notice
  * and this permission notice appear in supporting documentation.
  *
  * Prentice Hall and the author disclaim all warranties with regard to 
  * this software, including all implied warranties of merchantability and fitness.
  * In no event shall Prentice Hall or the author be liable for any special,
  * indirect or cosequential damages or any damages whatsoever resulting from 
  * loss of use, data or profits, whether in an action of contract, negligence 
  * or other tortious action, arising out of or in connection with the use 
  * or performance of this software.
  *
  * Open Software Foundation is a trademark of The Open Software Foundation, Inc.
  * OSF is a trademark of Open Software Foundation, Inc.
  * OSF/Motif is a trademark of Open Software Foundation, Inc.
  * Motif is a trademark of Open Software Foundation, Inc.
  * DEC is a registered trademark of Digital Equipment Corporation
  * HP is a registered trademark of the Hewlett Packard Company
  * DIGITAL is a registered trademark of Digital Equipment Corporation
  * X Window System is a trademark of the Massachusetts Institute of Technology
  **********************************************************************************/

#include "fileview.h" 

extern Widget create_scrollbar ();

main (argc, argv)
  int       argc;
  char     *argv[];
{
  Widget     toplevel, sb, sw;
  Arg        wargs[10];
  int        n;
  text_data  data;

  toplevel = XtInitialize (argv[0], "Fileview", 
                           NULL, 0, &argc, argv);
  XtGetApplicationResources (toplevel, &data, resources,
                              XtNumber (resources), NULL, 0);
 /*
  * Read the file specified in argv[1] into the
  * text buffer. 
  */
 load_file (&data, (argc == 2) ? argv[1] : NULL);
 /*
  * Create a ScrolledWindow widget as a base. 
  */
 sw = XtCreateManagedWidget ("framework", 
                             xmScrolledWindowWidgetClass,
                             toplevel, NULL, 0);
 /*
  * Create the drawing surface.
  */
 data.canvas= XtCreateManagedWidget("canvas",
                                    xmDrawingAreaWidgetClass,
                                    sw, NULL, 0);
 /*
  * Determine the initial size of the canvas and store it
  */
 XtSetArg (wargs[0], XtNheight, &data.canvas_height);
 XtSetArg (wargs[1], XtNwidth, &data.canvas_width);
 XtGetValues (data.canvas, wargs, 2);
 /*
  * Register callbacks for resizes and exposes.
  */
 XtAddCallback (data.canvas, XmNexposeCallback, 
                handle_exposures, &data);
 XtAddCallback (data.canvas, XmNresizeCallback, 
                resize, &data); 
 /*
  * The DrawingArea widget doesn't call its expose callback when 
  * Graphics Expose events occur. This event handler watches for them
  */
 XtAddEventHandler (data.canvas, 0, TRUE,  handle_g_exposures, &data);
 /*
  * Create the scrollbar
  */
 data.scrollbar = create_scrollbar (sw, &data);
 /*
  * Register the scrollbar and work area for the
  * ScrolledWindow widget.
  */
 n = 0;
 XtSetArg(wargs[n], XmNverticalScrollBar, data.scrollbar);n++;
 XtSetArg(wargs[n], XmNworkWindow, data.canvas); n++;
 XtSetValues(sw, wargs, n);

 XtRealizeWidget (toplevel);
 create_gc (&data);
 XtMainLoop ();
}

load_file (data, filename)
  text_data    *data;
  char         *filename;
{
  int           foreground, background, i, dir, ascent, desc;
  XCharStruct   char_info;
  FILE         *fp, *fopen ();
  char          buf[MAXLINESIZE];
  /*
   * Open the file. 
   */
  if ((fp = fopen (filename, "r")) == NULL) {
    fprintf (stderr, "Unable to open %s\n", filename);
    exit (1);
  }
  /*
   * Read each line of the file into the buffer,
   * calculating and caching the extents of
   * each line. 
   */
  i = 0;
  while ((fgets (buf, MAXLINESIZE, fp)) != NULL && 
          i < MAXLINES) {
   data->chars[i] = XtMalloc (strlen (buf) + 1);
    buf[strlen (buf) - 1] = '\0';
    strcpy (data->chars[i], buf);
    data->length[i] = strlen (data->chars[i]);
    XTextExtents(data->font, data->chars[i],
                 data->length[i], &dir, &ascent, 
                 &desc, &char_info);
    data->rbearing[i] = char_info.rbearing;
    data->descent     = desc;
    data->fontheight  = ascent + desc;
    i++;
  }
  /*
   * Close the file.
   */
  fclose(fp);
  /*
   * Remember the number of lines, and initialize the
   * current line number to be 0.
   */
  data->nitems = i;
  data->top = 0;
}

Widget create_scrollbar (parent, data)
  Widget        parent;
  text_data    *data;
{
  Arg    wargs[10];
  int    n = 0;
  Widget scrollbar;
  /*
   * Set the scrollbar so that movements are
   * reported in terms of lines of text. Set the
   * scrolling increment to a single line, and the page
   * increment to the number of lines the canvas widget
   * can hold. Also set the slider size to be proportional.
   */
  XtSetArg (wargs[n], XmNminimum, 0);  n++;
  XtSetArg (wargs[n], XmNmaximum, data->nitems);  n++;
  XtSetArg (wargs[n], XmNincrement, 1);  n++;	
#ifndef JUST_LIKE_BOOK
  XtSetArg (wargs[n], XmNsliderSize, data->canvas_height / data->fontheight);n++;
#else
  /*
   * Dumb. All this work just to find out it is equivalent to the number
   * of lines in the view area.
   */
  XtSetArg (wargs[n], XmNsliderSize, 
	            (data->canvas_height * data->canvas_height) / 
        	    (data->nitems * data->fontheight) );  n++;
#endif
  XtSetArg (wargs[n], XmNpageIncrement,
	            data->canvas_height/ data->fontheight);  n++;
  scrollbar = XtCreateManagedWidget ("scrollbar",
                                     xmScrollBarWidgetClass,
                                     parent, wargs, n);
  XtAddCallback (scrollbar, XmNvalueChangedCallback,
                 scroll_bar_moved, data);
  XtAddCallback (scrollbar, XmNdragCallback,
                 scroll_bar_moved, data);
  return scrollbar;
}

create_gc (data)
  text_data  *data;
{
  XGCValues  gcv;
  Display   *dpy  = XtDisplay(data->canvas);
  Window     w    = XtWindow(data->canvas);
  int        mask = GCFont | GCForeground | GCBackground;
  Arg        wargs[10];
  int        n;
  /*
   * Create a GC using the colors of the canvas widget.
   */
   n = 0;
   XtSetArg(wargs[n], XtNforeground, &gcv.foreground); n++;
   XtSetArg(wargs[n], XtNbackground, &gcv.background); n++;
   XtGetValues(data->canvas, wargs, n);
  
   gcv.font       = data->font->fid;
   data->gc       = XCreateGC (dpy, w, mask, &gcv);
}

void handle_exposures (w, data, cb)
   Widget          w;
   text_data      *data;
   XmDrawingAreaCallbackStruct *cb;
{
  int     yloc = 0, index = data->top;
  static Region  region = NULL;
  /*
   * Create a region and add the contents of the of the event
   */
  if(!region)
    region = XCreateRegion();

  XtAddExposureToRegion(cb->event, region);

  if(cb->event->xexpose.count != 0)
    return;
  /*
   * Set the clip mask of the GC.
   */
  XSetRegion (XtDisplay(w), data->gc, region); 
  /*
   * Loop through each line until the bottom of the
   * window is reached, or we run out of lines. Redraw any 
   * lines that intersect the exposed region.
   */
  while (index < data->nitems && yloc < data->canvas_height) {
    yloc += data->fontheight;
    if(XRectInRegion(region, MARGIN, yloc - data->fontheight,
                     data->rbearing[index],
                     data->fontheight) != RectangleOut)  
       XDrawImageString(XtDisplay (w), XtWindow (w), data->gc,
                         MARGIN, yloc, data->chars[index], 
                         data->length[index]);
    index++;
  }
  /*
   * Free the region.
   */
   XDestroyRegion(region);
   region = NULL;
}

void scroll_bar_moved(w, data, call_data)
     Widget     w;
     text_data *data;
     XmScrollBarCallbackStruct *call_data;
{
   int     sliderpos = call_data->value;
   int     ysrc,  redraw_top, delta;
   
   /* 
    * Compute number of pixels the text needs to be moved.
    */
   delta = ABS((data->top - sliderpos) * data->fontheight);   
   delta = MIN(delta, data->canvas_height);
   /*
    * If we are scrolling down, we start at zero and simply 
    * move by the delta. The portion that must be redrawn
    * is simply between zero and delta.
    */ 
   ysrc = redraw_top = 0;
   /* 
    * If we are scrolling up, we start at the delta and move
    * to zero. The part to redraw lies between the bottom
    * of the window and the bottom - delta.
    */
   if(sliderpos >= data->top){ 
     ysrc        =  delta;
     redraw_top  =  data->canvas_height - delta;
   }
   /*
    * Set the top line of the text buffer.
    */
   data->top = sliderpos;
   /*
    * Move the existing text to its new position.
    * Turn off any clipping on the GC first.
    */
   XSetClipMask(XtDisplay(w), data->gc, None);
   XCopyArea(XtDisplay(data->canvas), XtWindow(data->canvas), 
                       XtWindow(data->canvas), data->gc,
                       0, ysrc, 
                       data->canvas_width,  
                       data->canvas_height - delta,
                       0,  delta - ysrc);
   /*
    * Clear the remaining area of any old text, 
    */
   XClearArea(XtDisplay(w), XtWindow(data->canvas),
	      0, redraw_top,
	      0, delta, FALSE); 
   {
     int     yloc = 0, index = data->top;
     while (index < data->nitems && yloc < data->canvas_height) {
       yloc += data->fontheight;
       if(yloc >= redraw_top
	  && (yloc - data->fontheight) <= (redraw_top + delta))
	 XDrawImageString(XtDisplay (w), XtWindow (data->canvas), data->gc,
			  MARGIN, yloc, data->chars[index], 
			  data->length[index]);
       index++;
     }
   }
}

void resize (w, data, call_data)
  Widget          w;
  text_data      *data;
  caddr_t         call_data;
{
  Arg   wargs[10];
  int   n;
  /*
   * Determine the new widget of the canvas widget.
   */
  n = 0;
  XtSetArg (wargs[n], XtNheight, &data->canvas_height);n++;
  XtSetArg (wargs[n], XtNwidth,  &data->canvas_width);n++;
  XtGetValues (w, wargs, n);
  /*
   * Reset the scrollbar slider to indictae the relative
   * proportion of text displayed and also the new page size.
   */
  n = 0;
#ifndef JUST_LIKE_BOOK
  XtSetArg (wargs[n], XmNsliderSize, data->canvas_height / data->fontheight);n++;
#else
  /*
   * Dumb. All this work just to find out it is equivalent to the number
   * of lines in the view area.
   */
  XtSetArg (wargs[n], XmNsliderSize, 
	            (data->canvas_height * data->canvas_height) / 
        	    (data->nitems * data->fontheight) );  n++;
#endif
  XtSetArg (wargs[n], XmNpageIncrement, 
            data->canvas_height / data->fontheight);  n++;
  XtSetValues (data->scrollbar, wargs, n);
}


/*
 * Workaround for DrawingArea widget deficiency:
 *
 * If a GraphicsExpose is recieved, redraw the window by calling the
 * DrawingArea widget's XmNexposeCallback list.
 */

void handle_g_exposures (w, data, event)
   Widget          w;
   text_data      *data;
   XEvent *event;
{
  /*
   * This routine will be called for all non-maskable events. Make sure 
   * it's the type we want.
   */
  if(event->type == GraphicsExpose){

    XmDrawingAreaCallbackStruct cb;
    /*
     * Fill out a call data struct.
     */
    cb.reason = XmCR_EXPOSE;
    cb.event = event;
    cb.window = XtWindow (w);
    /*
     * Invoke all handlers on the XmNexposeCallback list.
     */
    XtCallCallbacks(w, XmNexposeCallback, &cb);
  }
}
@EOF

chmod 664 ch9/fileview5.c

chmod 775 ch9

echo mkdir - lib
mkdir lib

echo x - lib/Makefile
cat >lib/Makefile <<'@EOF'
CC = cc 
DEBUG = -O
CFLAGS = -DSYSV $(DEBUG) 

all: libXs.a

SOURCE =  concat.c str2flt.c invert.c quit.c talkto.c wprintf.c insert.c xmstr_to_str.c\
	send_msg.c xor.c strtoxmstr.c menus.c help_dialog.c pix_buttons.c

OBJS =  concat.o str2flt.o invert.o quit.o talkto.o wprintf.o insert.o xmstr_to_str.o\
	send_msg.o  xor.o strtoxmstr.o menus.o help_dialog.o pix_buttons.o

libXs.a: $(OBJS)
	ar ruv libXs.a $(OBJS)

@EOF

chmod 644 lib/Makefile

echo x - lib/concat.c
cat >lib/concat.c <<'@EOF'
/***************************************************
 * concat.c: utility function to concatenate 
 *           command-line arguments into a string.   
  *         From:
  *                   The X Window System, 
  *            Programming and Applications with Xt
  *                   OSF/Motif Edition
  *         by
  *                Douglas Young
  *              Prentice Hall, 1990
  *
  *                 Example described on pages:  28
  *
  *
  *  Copyright 1989 by Prentice Hall
  *  All Rights Reserved
  *
  * This code is based on the OSF/Motif widget set and the X Window System
  *
  * Permission to use, copy, modify, and distribute this software for 
  * any purpose and without fee is hereby granted, provided that the above
  * copyright notice appear in all copies and that both the copyright notice
  * and this permission notice appear in supporting documentation.
  *
  * Prentice Hall and the author disclaim all warranties with regard to 
  * this software, including all implied warranties of merchantability and fitness.
  * In no event shall Prentice Hall or the author be liable for any special,
  * indirect or cosequential damages or any damages whatsoever resulting from 
  * loss of use, data or profits, whether in an action of contract, negligence 
  * or other tortious action, arising out of or in connection with the use 
  * or performance of this software.
  *
  * Open Software Foundation is a trademark of The Open Software Foundation, Inc.
  * OSF is a trademark of Open Software Foundation, Inc.
  * OSF/Motif is a trademark of Open Software Foundation, Inc.
  * Motif is a trademark of Open Software Foundation, Inc.
  * DEC is a registered trademark of Digital Equipment Corporation
  * HP is a registered trademark of the Hewlett Packard Company
  * DIGITAL is a registered trademark of Digital Equipment Corporation
  * X Window System is a trademark of the Massachusetts Institute of Technology
  **********************************************************************************/

#include <X11/Intrinsic.h>
#include <X11/StringDefs.h>
#include <Xm/Xm.h>

XmString xs_concat_words(n, words)
    int   n;
    char *words[];
{
   XmString   xmstr;
   int   i, len = 0;
   /*
    * If there are no arguments other than the program
    * name, just return an empty string.
    */
   if (n <= 0)
      return (XmStringCreate("", XmSTRING_DEFAULT_CHARSET));
   xmstr = (XmString) NULL;

  for (i = 0; i < n; i++)  {
    XmString tmp;
   if (i > 0){
       tmp   = XmStringCreate(" ", XmSTRING_DEFAULT_CHARSET);
       xmstr = XmStringConcat(xmstr, tmp);
       XmStringFree (tmp);
    }
    tmp = XmStringCreate(words[i], XmSTRING_DEFAULT_CHARSET);
    xmstr = XmStringConcat(xmstr, tmp);
    XmStringFree (tmp);
  }
  return (xmstr);
}

@EOF

chmod 644 lib/concat.c

echo x - lib/insert.c
cat >lib/insert.c <<'@EOF'
 /*************************************************
  *  xs_insert_string()
  *        
  *         From:
  *                   The X Window System, 
  *            Programming and Applications with Xt
  *                   OSF/Motif Edition
  *         by
  *                Douglas Young
  *              Prentice Hall, 1990
  *
  *                 Example described on pages:  165
  *
  *
  *  Copyright 1989 by Prentice Hall
  *  All Rights Reserved
  *
  * This code is based on the OSF/Motif widget set and the X Window System
  *
  * Permission to use, copy, modify, and distribute this software for 
  * any purpose and without fee is hereby granted, provided that the above
  * copyright notice appear in all copies and that both the copyright notice
  * and this permission notice appear in supporting documentation.
  *
  * Prentice Hall and the author disclaim all warranties with regard to 
  * this software, including all implied warranties of merchantability and fitness.
  * In no event shall Prentice Hall or the author be liable for any special,
  * indirect or cosequential damages or any damages whatsoever resulting from 
  * loss of use, data or profits, whether in an action of contract, negligence 
  * or other tortious action, arising out of or in connection with the use 
  * or performance of this software.
  *
  * Open Software Foundation is a trademark of The Open Software Foundation, Inc.
  * OSF is a trademark of Open Software Foundation, Inc.
  * OSF/Motif is a trademark of Open Software Foundation, Inc.
  * Motif is a trademark of Open Software Foundation, Inc.
  * DEC is a registered trademark of Digital Equipment Corporation
  * HP is a registered trademark of the Hewlett Packard Company
  * DIGITAL is a registered trademark of Digital Equipment Corporation
  * X Window System is a trademark of the Massachusetts Institute of Technology
  **********************************************************************************/
#include <X11/StringDefs.h>
#include <X11/Intrinsic.h>
#include <Xm/Xm.h>
#include <Xm/Text.h>

xs_insert_string(text_widget, buf)
     Widget   text_widget;
     char    *buf;
{
  int pos = XmTextGetInsertionPosition(text_widget);
  XmTextReplace(text_widget, pos, pos, buf);
}
@EOF

chmod 664 lib/insert.c

echo x - lib/quit.c
cat >lib/quit.c <<'@EOF'
/*******************************************************
 * quit.c: A utility function that adds a quit button 
  *         From:
  *                   The X Window System, 
  *            Programming and Applications with Xt
  *                   OSF/Motif Edition
  *         by
  *                Douglas Young
  *              Prentice Hall, 1990
  *
  *                 Example described on pages:  77-78
  *
  *
  *  Copyright 1989 by Prentice Hall
  *  All Rights Reserved
  *
  * This code is based on the OSF/Motif widget set and the X Window System
  *
  * Permission to use, copy, modify, and distribute this software for 
  * any purpose and without fee is hereby granted, provided that the above
  * copyright notice appear in all copies and that both the copyright notice
  * and this permission notice appear in supporting documentation.
  *
  * Prentice Hall and the author disclaim all warranties with regard to 
  * this software, including all implied warranties of merchantability and fitness.
  * In no event shall Prentice Hall or the author be liable for any special,
  * indirect or cosequential damages or any damages whatsoever resulting from 
  * loss of use, data or profits, whether in an action of contract, negligence 
  * or other tortious action, arising out of or in connection with the use 
  * or performance of this software.
  *
  * Open Software Foundation is a trademark of The Open Software Foundation, Inc.
  * OSF is a trademark of Open Software Foundation, Inc.
  * OSF/Motif is a trademark of Open Software Foundation, Inc.
  * Motif is a trademark of Open Software Foundation, Inc.
  * DEC is a registered trademark of Digital Equipment Corporation
  * HP is a registered trademark of the Hewlett Packard Company
  * DIGITAL is a registered trademark of Digital Equipment Corporation
  * X Window System is a trademark of the Massachusetts Institute of Technology
  **********************************************************************************/

#include <X11/Intrinsic.h>
#include <X11/StringDefs.h>
#include <Xm/Xm.h>
#include <Xm/PushB.h>

/* 
 * Define three callbacks. Make them static - no need 
 * to make them known outside this file.
 */
static void arm_callback(w, flag, call_data)
     Widget     w;
     int       *flag;
     XmAnyCallbackStruct *call_data; 
{
 *flag = FALSE;
}
static void activate_callback(w, flag, call_data)
     Widget     w;
     int       *flag;
     XmAnyCallbackStruct *call_data; 
{
  *flag = TRUE;
}
static void disarm_callback(w, flag, call_data)
     Widget     w;
     int       *flag;
     XmAnyCallbackStruct *call_data; 
{
  if(*flag){
    XtCloseDisplay(XtDisplay(w));
    exit(0);
  }
}
/* 
 * Function to add a quit button as a child of any widget.
 */
Widget xs_create_quit_button(parent)
   Widget  parent;
{
   Widget     w;
   static int really_quit;
   w = XtCreateManagedWidget("quit", xmPushButtonWidgetClass,
                            parent, NULL, 0);
   XtAddCallback(w, XmNarmCallback, 
                 arm_callback, &really_quit);
   XtAddCallback(w, XmNdisarmCallback, 
                 disarm_callback, &really_quit);
   XtAddCallback(w, XmNactivateCallback, 
                 activate_callback, &really_quit);     
   return (w);
}
@EOF

chmod 644 lib/quit.c

echo x - lib/libXs.h
cat >lib/libXs.h <<'@EOF'
#ifndef _LIBXs_h
#define _LIBXs_h

#include <Xm/Xm.h>

#define XtRFloat "Float"

typedef struct _menu_struct{
   char*                  name;           /* name of the button */
   void                  (*func)();       /* Callback to be invoked */
   caddr_t                data;           /* Data for the callback */
   struct _menu_struct   *sub_menu;       /* data for submenu of this button */
   int                    n_sub_items;    /* How many items in sub_menu */
   char                  *sub_menu_title; /* Title of submenu */
 } xs_menu_struct;

extern Widget    xs_create_quit_button ();
extern void      xs_invert_widget ();
extern XmString  xs_concat_words ();
extern void      xs_cvt_str_to_float ();
XmString         xs_str_array_to_xmstr();
extern Widget    xs_create_pixmap_button ();
extern Widget    xs_create_pixmap_browser ();
extern char     *xs_get_string_from_xmstring ();
void             xs_help_callback();
extern GC        xs_create_xor_gc();
/*
 * Horrible hack for BSD systems which don't have vsprintf().
 * Instead of xs_wprintf(), use the macro which matches the 
 * number of args passed. Extend as needed.
 */
#define XS_WPRINTF_ONE(_widget,_format,_arg) { \
        Arg _tmp[10];  char _tmp_buf[1000]; \
        sprintf(_tmp_buf, _format, _arg); \
        XtSetArg(_tmp[0], XmNlabelString, \
		 XmStringLtoRCreate(_tmp_buf, XmSTRING_DEFAULT_CHARSET)); \
        XtSetValues(_widget,_tmp, 1); \
	}

#define XS_WPRINTF_TWO(_widget,_format,_a,_b) { \
        Arg _tmp[10];  char _tmp_buf[1000]; \
        sprintf(_tmp_buf, _format, _a, _b); \
        XtSetArg(_tmp[0], XmNlabelString, \
		 XmStringLtoRCreate(_tmp_buf, XmSTRING_DEFAULT_CHARSET)); \
        XtSetValues(_widget,_tmp, 1); \
	}

#define XS_WPRINTF_THREE(_widget,_format,_a,_b,_c) { \
        Arg _tmp[10];  char _tmp_buf[1000]; \
        sprintf(_tmp_buf, _format, _a, _b, _c); \
        XtSetArg(_tmp[0], XmNlabelString, \
		 XmStringLtoRCreate(_tmp_buf, XmSTRING_DEFAULT_CHARSET)); \
        XtSetValues(_widget,_tmp, 1); \
	}

#define XS_WPRINTF_FOUR(_widget,_format,_a,_b,_c,_d) { \
        Arg _tmp[10];  char _tmp_buf[1000]; \
        sprintf(_tmp_buf, _format, _a, _b, _c, _d); \
        XtSetArg(_tmp[0], XmNlabelString, \
		 XmStringLtoRCreate(_tmp_buf, XmSTRING_DEFAULT_CHARSET)); \
        XtSetValues(_widget,_tmp, 1); \
	}
      
#endif


@EOF

chmod 644 lib/libXs.h

echo x - lib/invert.c
cat >lib/invert.c <<'@EOF'
/*************************************************************
 * invert.c: utility function for inverting a widget's color.
  *         From:
  *                   The X Window System, 
  *            Programming and Applications with Xt
  *                   OSF/Motif Edition
  *         by
  *                Douglas Young
  *              Prentice Hall, 1990
  *
  *                 Example described on pages:  319
  *
  *
  *  Copyright 1989 by Prentice Hall
  *  All Rights Reserved
  *
  * This code is based on the OSF/Motif widget set and the X Window System
  *
  * Permission to use, copy, modify, and distribute this software for 
  * any purpose and without fee is hereby granted, provided that the above
  * copyright notice appear in all copies and that both the copyright notice
  * and this permission notice appear in supporting documentation.
  *
  * Prentice Hall and the author disclaim all warranties with regard to 
  * this software, including all implied warranties of merchantability and fitness.
  * In no event shall Prentice Hall or the author be liable for any special,
  * indirect or cosequential damages or any damages whatsoever resulting from 
  * loss of use, data or profits, whether in an action of contract, negligence 
  * or other tortious action, arising out of or in connection with the use 
  * or performance of this software.
  *
  * Open Software Foundation is a trademark of The Open Software Foundation, Inc.
  * OSF is a trademark of Open Software Foundation, Inc.
  * OSF/Motif is a trademark of Open Software Foundation, Inc.
  * Motif is a trademark of Open Software Foundation, Inc.
  * DEC is a registered trademark of Digital Equipment Corporation
  * HP is a registered trademark of the Hewlett Packard Company
  * DIGITAL is a registered trademark of Digital Equipment Corporation
  * X Window System is a trademark of the Massachusetts Institute of Technology
  **********************************************************************************/

#include <X11/Intrinsic.h>
#include <X11/StringDefs.h>

xs_invert_widget(w)
     Widget  w;
{
  Arg  wargs[3];
  int  fg, bg;
  /*
   * Get the widget's current colors.
   */
  XtSetArg(wargs[0], XtNforeground, &fg);
  XtSetArg(wargs[1], XtNbackground, &bg);
  XtGetValues(w, wargs, 2);
  /*
   * Reverse them and set the new colors.
   */
  XtSetArg(wargs[0], XtNforeground, bg);
  XtSetArg(wargs[1], XtNbackground, fg);
  XtSetValues(w, wargs, 2);
}
@EOF

chmod 644 lib/invert.c

echo x - lib/menus.c
cat >lib/menus.c <<'@EOF'
/*********************************************************
 * menus.c: Simple menu package
  *         From:
  *                   The X Window System, 
  *            Programming and Applications with Xt
  *                   OSF/Motif Edition
  *         by
  *                Douglas Young
  *              Prentice Hall, 1990
  *
  *                 Example described on pages:  104-106
  *
  *
  *  Copyright 1989 by Prentice Hall
  *  All Rights Reserved
  *
  * This code is based on the OSF/Motif widget set and the X Window System
  *
  * Permission to use, copy, modify, and distribute this software for 
  * any purpose and without fee is hereby granted, provided that the above
  * copyright notice appear in all copies and that both the copyright notice
  * and this permission notice appear in supporting documentation.
  *
  * Prentice Hall and the author disclaim all warranties with regard to 
  * this software, including all implied warranties of merchantability and fitness.
  * In no event shall Prentice Hall or the author be liable for any special,
  * indirect or cosequential damages or any damages whatsoever resulting from 
  * loss of use, data or profits, whether in an action of contract, negligence 
  * or other tortious action, arising out of or in connection with the use 
  * or performance of this software.
  *
  * Open Software Foundation is a trademark of The Open Software Foundation, Inc.
  * OSF is a trademark of Open Software Foundation, Inc.
  * OSF/Motif is a trademark of Open Software Foundation, Inc.
  * Motif is a trademark of Open Software Foundation, Inc.
  * DEC is a registered trademark of Digital Equipment Corporation
  * HP is a registered trademark of the Hewlett Packard Company
  * DIGITAL is a registered trademark of Digital Equipment Corporation
  * X Window System is a trademark of the Massachusetts Institute of Technology
  **********************************************************************************/

#include <X11/StringDefs.h>
#include <X11/Intrinsic.h>
#include <Xm/Xm.h>
#include <Xm/Separator.h>
#include <Xm/PushB.h>
#include <Xm/CascadeB.h>
#include <Xm/RowColumn.h>
#include <Xm/Label.h>
#include "libXs.h"

xs_create_menu_buttons(title, menu, menulist, nitems)
   char           *title;
   Widget          menu;
   xs_menu_struct *menulist;
   int             nitems;
{
  Arg        wargs[1];
  int        i;
  WidgetList buttons;
  int        separators = 0;
  /*
   * Allocate a widget list to hold all 
   * button widgets.
   */
   buttons = (WidgetList) XtMalloc(nitems * sizeof(Widget));
  /*
   * If a title is given, create Label and Separator widgets.
  */
  if(title){
    XtCreateManagedWidget(title, xmLabelWidgetClass, menu,
                          NULL, 0);
    XtCreateManagedWidget("separator", xmSeparatorWidgetClass,
                          menu, NULL, 0);
  }
  /*
   * Create an entry for each item in the menu.
   */
  for(i=0;i<nitems;i++){
   /* 
    * A NULL name represents a separator.
    */
   if(menulist[i].name == NULL){ 
     XtCreateManagedWidget("separator",
                           xmSeparatorWidgetClass,
                           menu, NULL, 0);
     separators++; /* Count how many entries aren't buttons */
   }
   /*
    * If there is a name and a callback, create a "normal"
    * menu entry and register the callback function.
    */
   else if(menulist[i].func){
     buttons[i-separators] = XtCreateWidget(menulist[i].name,
                                     					xmPushButtonWidgetClass,
                                     menu, NULL, 0);
     XtAddCallback(buttons[i-separators], XmNactivateCallback,
                   menulist[i].func, menulist[i].data);
   }
   /*
    * If there is a name, but no callback function, the entry
    * must be a label, unless there is a submenu.
    */
   else if(!menulist[i].sub_menu)
     buttons[i-separators] = XtCreateWidget(menulist[i].name,
                                           xmLabelWidgetClass,
                                           menu, NULL, 0);
   /*
    * If we got here, the entry must be a submenu.
    * Create a pulldown menu pane and an XmCascadeButton
    * widget. Attach the menu pane and make a recursive call
    * to create the entries in the submenu.
    */
   else{  
    Widget sub_menu;
    sub_menu =XmCreatePulldownMenu(menu,
                                   menulist[i].sub_menu_title,
                                   NULL, 0);
    XtSetArg(wargs[0], XmNsubMenuId, sub_menu);
    buttons[i-separators] =
          XtCreateWidget(menulist[i].name,
                         xmCascadeButtonWidgetClass,
                         menu, wargs, 1);
    xs_create_menu_buttons(menulist[i].sub_menu_title,
                          sub_menu, menulist[i].sub_menu,
                          menulist[i].n_sub_items);
    }
  } 
  /*
   * Manage all button widgets. Menu panes are not managed.
   */
  XtManageChildren(buttons, nitems - separators);
}
@EOF

chmod 644 lib/menus.c

echo x - lib/str2flt.c
cat >lib/str2flt.c <<'@EOF'
/*************************************************
 * str2flt.c: Convert a string to a float.
  *
  *         From:
  *                   The X Window System, 
  *            Programming and Applications with Xt
  *                   OSF/Motif Edition
  *         by
  *                Douglas Young
  *              Prentice Hall, 1990
  *
  *                 Example described on pages: ??
  *
  *
  *  Copyright 1989 by Prentice Hall
  *  All Rights Reserved
  *
  * This code is based on the OSF/Motif widget set and the X Window System
  *
  * Permission to use, copy, modify, and distribute this software for 
  * any purpose and without fee is hereby granted, provided that the above
  * copyright notice appear in all copies and that both the copyright notice
  * and this permission notice appear in supporting documentation.
  *
  * Prentice Hall and the author disclaim all warranties with regard to 
  * this software, including all implied warranties of merchantability and fitness.
  * In no event shall Prentice Hall or the author be liable for any special,
  * indirect or cosequential damages or any damages whatsoever resulting from 
  * loss of use, data or profits, whether in an action of contract, negligence 
  * or other tortious action, arising out of or in connection with the use 
  * or performance of this software.
  *
  * Open Software Foundation is a trademark of The Open Software Foundation, Inc.
  * OSF is a trademark of Open Software Foundation, Inc.
  * OSF/Motif is a trademark of Open Software Foundation, Inc.
  * Motif is a trademark of Open Software Foundation, Inc.
  * DEC is a registered trademark of Digital Equipment Corporation
  * HP is a registered trademark of the Hewlett Packard Company
  * DIGITAL is a registered trademark of Digital Equipment Corporation
  * X Window System is a trademark of the Massachusetts Institute of Technology
  **********************************************************************************/

#include <X11/Intrinsic.h>
#include <X11/StringDefs.h>

void xs_cvt_str_to_float(args, nargs, fromVal, toVal)
     XrmValue    *args;
     int         *nargs;
     XrmValue    *fromVal, *toVal;
{
  static float result;
  /*
   * Make sure the number of args is correct.
   */
  if (*nargs != 0)
   XtWarning("String to Float conversion needs no arguments");
  /*
   * Convert the string in the fromVal to a floating pt.
   */
  if (sscanf((char *)fromVal->addr, "%f", &result) == 1) {
    /*
     * Make the toVal point to the result.
     */
    toVal->size = sizeof (float); 
    toVal->addr = (caddr_t) &result; 
  } 
  else 
  /* 
   * If sscanf fails, issue a warning that something is wrong.
   */
   XtStringConversionWarning((char *) fromVal->addr, "Float");
}
@EOF

chmod 644 lib/str2flt.c

echo x - lib/talkto.c
cat >lib/talkto.c <<'@EOF'
/********************************************************************************
 *  xs_talkto(): connect two processes suchj that stdin of each reads from 
 *  stdout of the other
  *         From:
  *                   The X Window System, 
  *            Programming and Applications with Xt
  *                   OSF/Motif Edition
  *         by
  *                Douglas Young
  *              Prentice Hall, 1990
  *
  *                 Example described on pages:  ??
  *
  *
  *  Copyright 1989 by Prentice Hall
  *  All Rights Reserved
  *
  * This code is based on the OSF/Motif widget set and the X Window System
  *
  * Permission to use, copy, modify, and distribute this software for 
  * any purpose and without fee is hereby granted, provided that the above
  * copyright notice appear in all copies and that both the copyright notice
  * and this permission notice appear in supporting documentation.
  *
  * Prentice Hall and the author disclaim all warranties with regard to 
  * this software, including all implied warranties of merchantability and fitness.
  * In no event shall Prentice Hall or the author be liable for any special,
  * indirect or cosequential damages or any damages whatsoever resulting from 
  * loss of use, data or profits, whether in an action of contract, negligence 
  * or other tortious action, arising out of or in connection with the use 
  * or performance of this software.
  *
  * Open Software Foundation is a trademark of The Open Software Foundation, Inc.
  * OSF is a trademark of Open Software Foundation, Inc.
  * OSF/Motif is a trademark of Open Software Foundation, Inc.
  * Motif is a trademark of Open Software Foundation, Inc.
  * DEC is a registered trademark of Digital Equipment Corporation
  * HP is a registered trademark of the Hewlett Packard Company
  * DIGITAL is a registered trademark of Digital Equipment Corporation
  * X Window System is a trademark of the Massachusetts Institute of Technology
  **********************************************************************************/
#include 	<stdio.h>
void xs_talkto(cmd)
   char   *cmd;
{
  int   to_child[2], /* pipe descriptors from parent->child */
        to_parent[2];/* pipe descriptors from child->parent */
  int   pid;
  pipe(to_child);
  pipe(to_parent);
  if (pid = fork(), pid == 0){    /* in the child   */
     close(0);                    /* redirect stdin */
     dup(to_child[0]);
     close(1);                    /* redirect stdout*/
     dup(to_parent[1]);
     close(to_child[0]);          /* close pipes    */
     close(to_child[1]);
     close(to_parent[0]);
     close(to_parent[1]);
     execlp(cmd, cmd, NULL);      /* exec the new cmd */
   }
   else if (pid > 0){             /* in the parent  */
      close(0);                   /* redirect stdin */
      dup(to_parent[0]);
      close(1);                   /* redirect stdout  */
      dup(to_child[1]);
      setbuf(stdout, NULL);       /* no buffered output */
      close(to_child[0]);         /* close pipes */
      close(to_child[1]);
      close(to_parent[0]);
      close(to_parent[1]);
    }
    else {                        /* error!       */
      fprintf(stderr,"Couldn't fork process %s\n", cmd);
      exit(1);
    }
}
@EOF

chmod 644 lib/talkto.c

echo x - lib/pix_buttons.c
cat >lib/pix_buttons.c <<'@EOF'
 /*************************************************
  *    pixmap_browser functions
  *         From:
  *                   The X Window System, 
  *            Programming and Applications with Xt
  *                   OSF/Motif Edition
  *         by
  *                Douglas Young
  *              Prentice Hall, 1990
  *
  *                 Example described on pages:  200-202
  *
  *
  *  Copyright 1989 by Prentice Hall
  *  All Rights Reserved
  *
  * This code is based on the OSF/Motif widget set and the X Window System
  *
  * Permission to use, copy, modify, and distribute this software for 
  * any purpose and without fee is hereby granted, provided that the above
  * copyright notice appear in all copies and that both the copyright notice
  * and this permission notice appear in supporting documentation.
  *
  * Prentice Hall and the author disclaim all warranties with regard to 
  * this software, including all implied warranties of merchantability and fitness.
  * In no event shall Prentice Hall or the author be liable for any special,
  * indirect or cosequential damages or any damages whatsoever resulting from 
  * loss of use, data or profits, whether in an action of contract, negligence 
  * or other tortious action, arising out of or in connection with the use 
  * or performance of this software.
  *
  * Open Software Foundation is a trademark of The Open Software Foundation, Inc.
  * OSF is a trademark of Open Software Foundation, Inc.
  * OSF/Motif is a trademark of Open Software Foundation, Inc.
  * Motif is a trademark of Open Software Foundation, Inc.
  * DEC is a registered trademark of Digital Equipment Corporation
  * HP is a registered trademark of the Hewlett Packard Company
  * DIGITAL is a registered trademark of Digital Equipment Corporation
  * X Window System is a trademark of the Massachusetts Institute of Technology
  **********************************************************************************/
#include <X11/StringDefs.h>
#include <X11/Intrinsic.h> 
#include <Xm/Xm.h>
#include <Xm/ToggleB.h>
#include <Xm/RowColumn.h>
#include "libXs.h"


 Widget 
xs_create_pixmap_browser (parent,tiles,n_tiles,callback,data)
   Widget     parent;       /* widget to manage the browser */
   char      *tiles[];      /* list of tile names           */
   int        n_tiles;      /* how many tiles               */
   void      (*callback)(); /* invoked when state changes   */
   caddr_t    data;         /* data to be passed to callback*/
{
  Widget     browser;
  WidgetList buttons;
  int        i;
  Arg        wargs[10];
  /*
   * Malloc room for button widgets.
   */
  buttons = (WidgetList) XtMalloc(n_tiles * sizeof(Widget));
  /*
   * Create a "RadioBox" RowColumn widget.
   */
  XtSetArg(wargs[0], XmNentryClass, xmToggleButtonWidgetClass);
  browser = XmCreateRadioBox(parent, "browser", wargs, 1);
  /*
   * Create a button for each tile. If a callback function
   * has been given, register it as an XmNvalueChangedCallback
   */
  for(i=0;i< n_tiles;i++){
   buttons[i] = xs_create_pixmap_button(browser, tiles[i]);
   if(callback)
     XtAddCallback(buttons[i], XmNvalueChangedCallback, 
                   callback, data);
 }
 /*
  * Manage all buttons and return the RadioBox widget, which
  * is still unmanaged
  */ 
 XtManageChildren(buttons, n_tiles);
 return browser;
}

Widget xs_create_pixmap_button(parent, pattern)
     Widget         parent;
     char *         pattern;
{
   Pixmap   tile;
   Widget   button;
   Arg      wargs[10];
   Pixel    foreground, background;
   int      n;

   button = XtCreateWidget(pattern, xmToggleButtonWidgetClass,
                           parent, NULL, 0);
   /*
    * Retrieve the colors of the widget.
    */
   n = 0;
   XtSetArg(wargs[n], XtNforeground, &foreground);n++;
   XtSetArg(wargs[n], XtNbackground, &background);n++;
   XtGetValues(button, wargs, n);
   /*
    * Get a tile corresponding the given pattern.
   */
   tile = XmGetPixmap (XtScreen(button),  pattern,
                       foreground, background);
   /*
    * Display the pixmap in the button and also store it
    * so it can be retrieved from the button later.
    */
   n = 0;
   XtSetArg(wargs[n], XmNlabelType,   XmPIXMAP); n++;
   XtSetArg(wargs[n], XmNlabelPixmap, tile); n++;
   XtSetArg(wargs[n], XmNuserData,    tile); n++;
   XtSetValues(button, wargs, n);
   /*
    * Return the unmanaged button.
    */
   return button;
}

xs_register_pattern(w, name, bits, width, height)
  Widget         w;
  char          *name;
  unsigned char *bits;
  int            width, height;
 {
    XImage *image;
    image = XCreateImage(XtDisplay(w),
                         DefaultVisualOfScreen(XtScreen(w)), 
                      1, XYBitmap, 0, 
                         bits, width, height, 8, 2);
    XmInstallImage(image, name);
   }
@EOF

chmod 664 lib/pix_buttons.c

echo x - lib/wprintf.c
cat >lib/wprintf.c <<'@EOF'
/*********************************************************
 * xs_wprintf: fprintf-like function for XmLabel widgets
  *         From:
  *                   The X Window System, 
  *            Programming and Applications with Xt
  *                   OSF/Motif Edition
  *         by
  *                Douglas Young
  *              Prentice Hall, 1990
  *
  *                 Example described on pages: ??
  *
  *
  *  Copyright 1989 by Prentice Hall
  *  All Rights Reserved
  *
  * This code is based on the OSF/Motif widget set and the X Window System
  *
  * Permission to use, copy, modify, and distribute this software for 
  * any purpose and without fee is hereby granted, provided that the above
  * copyright notice appear in all copies and that both the copyright notice
  * and this permission notice appear in supporting documentation.
  *
  * Prentice Hall and the author disclaim all warranties with regard to 
  * this software, including all implied warranties of merchantability and fitness.
  * In no event shall Prentice Hall or the author be liable for any special,
  * indirect or cosequential damages or any damages whatsoever resulting from 
  * loss of use, data or profits, whether in an action of contract, negligence 
  * or other tortious action, arising out of or in connection with the use 
  * or performance of this software.
  *
  * Open Software Foundation is a trademark of The Open Software Foundation, Inc.
  * OSF is a trademark of Open Software Foundation, Inc.
  * OSF/Motif is a trademark of Open Software Foundation, Inc.
  * Motif is a trademark of Open Software Foundation, Inc.
  * DEC is a registered trademark of Digital Equipment Corporation
  * HP is a registered trademark of the Hewlett Packard Company
  * DIGITAL is a registered trademark of Digital Equipment Corporation
  * X Window System is a trademark of the Massachusetts Institute of Technology
  **********************************************************************************/
#include <varargs.h>
#include <stdio.h>
#include <X11/Intrinsic.h>
#include <X11/StringDefs.h>
#include <Xm/Xm.h>
#include <Xm/Label.h>

void xs_wprintf(va_alist)
     va_dcl
{
  Widget    w;
  char     *format;
  va_list   args;
  char      str[1000];  /* DANGER: Fixed buffer size */
  Arg       wargs[1];
  XmString  xmstr;
  /*
   * Init the variable length args list.
   */
  va_start(args);
  /*
   * Extract the destination widget.
   * Make sure it is a subclass of XmLabel.
   */
  w = va_arg(args, Widget);
  if(!XtIsSubclass(w, xmLabelWidgetClass))
     XtError("xs_wprintf() requires a Label Widget");
  /*
   * Extract the format to be used.
   */
  format = va_arg(args, char *);
  /*
   * Use vsprintf to format the string to be displayed in the
   * XmLabel widget, then convert it to a compound string
   */
  vsprintf(str, format, args);
  xmstr =  XmStringLtoRCreate(str, XmSTRING_DEFAULT_CHARSET);

  XtSetArg(wargs[0], XmNlabelString, xmstr);
  XtSetValues(w, wargs, 1);     

  va_end(args);
}
@EOF

chmod 644 lib/wprintf.c

echo x - lib/help_dialog.c
cat >lib/help_dialog.c <<'@EOF'
/**********************************************************
 * A help callback.
  *         From:
  *                   The X Window System, 
  *            Programming and Applications with Xt
  *                   OSF/Motif Edition
  *         by
  *                Douglas Young
  *              Prentice Hall, 1990
  *
  *                 Example described on pages:  119-121
  *
  *
  *  Copyright 1989 by Prentice Hall
  *  All Rights Reserved
  *
  * This code is based on the OSF/Motif widget set and the X Window System
  *
  * Permission to use, copy, modify, and distribute this software for 
  * any purpose and without fee is hereby granted, provided that the above
  * copyright notice appear in all copies and that both the copyright notice
  * and this permission notice appear in supporting documentation.
  *
  * Prentice Hall and the author disclaim all warranties with regard to 
  * this software, including all implied warranties of merchantability and fitness.
  * In no event shall Prentice Hall or the author be liable for any special,
  * indirect or cosequential damages or any damages whatsoever resulting from 
  * loss of use, data or profits, whether in an action of contract, negligence 
  * or other tortious action, arising out of or in connection with the use 
  * or performance of this software.
  *
  * Open Software Foundation is a trademark of The Open Software Foundation, Inc.
  * OSF is a trademark of Open Software Foundation, Inc.
  * OSF/Motif is a trademark of Open Software Foundation, Inc.
  * Motif is a trademark of Open Software Foundation, Inc.
  * DEC is a registered trademark of Digital Equipment Corporation
  * HP is a registered trademark of the Hewlett Packard Company
  * DIGITAL is a registered trademark of Digital Equipment Corporation
  * X Window System is a trademark of the Massachusetts Institute of Technology
  **********************************************************************************/
#include <X11/StringDefs.h>
#include <X11/Intrinsic.h> 
#include <Xm/Xm.h>
#include <Xm/MessageB.h>
#include "libXs.h"

static void xs_ok_callback();

void xs_help_callback(w, str, call_data) 
     Widget    w; 
     char     *str[];
     caddr_t   call_data;
{
  int        i, n;
  Widget     dialog;
  Widget     label;
  XmString   xmstr;
  Arg        wargs[5];
  /*
   * Create the message dialog to display the help.
   */
   n = 0;
   XtSetArg(wargs[n], XmNautoUnmanage, FALSE); n++;
   dialog = XmCreateMessageDialog(w, "Help", wargs, n);
   /*
    * We won't be using the cancel widget. Unmanage it.
    */
   XtUnmanageChild(XmMessageBoxGetChild (dialog,
                   XmDIALOG_CANCEL_BUTTON));
   /*
    * Retrieve the label widget and make the 
    * text left justified
    */
   label = XmMessageBoxGetChild (dialog,
                                 XmDIALOG_MESSAGE_LABEL);
   n = 0;
   XtSetArg(wargs[n],XmNalignment,XmALIGNMENT_BEGINNING);n++;
   XtSetValues(label, wargs, n);
   /*
    * Add an OK callback to pop down the dialog.
    */
   XtAddCallback(dialog, XmNokCallback, 
                 xs_ok_callback, NULL);
  /*
   * Count the text up to the first NULL string.
   */
  for(i=0; str[i][0] != '\0'; i++)
    ;
  /*
   * Convert the string array to an XmString array and 
   * set it as the label text.
   */
  xmstr  = xs_str_array_to_xmstr(str, i);
  n = 0;
  XtSetArg(wargs[n],  XmNmessageString, xmstr);n++;
  XtSetValues(dialog, wargs, n);
  /*
   * If the next entry in the help string array is also NULL,
   * then this is the last message. Unmanage the help button.
   */
  if(str[++i][0] == '\0')
    XtUnmanageChild(XmMessageBoxGetChild (dialog,
                    XmDIALOG_HELP_BUTTON));
  /*
   * Otherwise, add a help callback function with the address of 
   * the next entry  in the help string as client_data.
   */
  else{
    XtAddCallback(dialog, XmNhelpCallback, 
                  xs_help_callback, &str[i]);
  }
  /*
   * Display the dialog.
   */
  XtManageChild(dialog);
}

static void xs_ok_callback(w, client_data, call_data) 
   Widget               w; 
   caddr_t              client_data;
   XmAnyCallbackStruct *call_data; 
{
   XtUnmanageChild(w);
   XtDestroyWidget(w);   
}
@EOF

chmod 664 lib/help_dialog.c

echo x - lib/xmstr_to_str.c
cat >lib/xmstr_to_str.c <<'@EOF'
/***********************************************************************
 * Retrieve the character string from a possibly composite compound string, such as
 * created by xs_concat_words()
*         From:
  *                   The X Window System, 
  *            Programming and Applications with Xt
  *                   OSF/Motif Edition
  *         by
  *                Douglas Young
  *              Prentice Hall, 1990
  *
  *                 Example described on pages:  ??
  *
  *
  *  Copyright 1989 by Prentice Hall
  *  All Rights Reserved
  *
  * This code is based on the OSF/Motif widget set and the X Window System
  *
  * Permission to use, copy, modify, and distribute this software for 
  * any purpose and without fee is hereby granted, provided that the above
  * copyright notice appear in all copies and that both the copyright notice
  * and this permission notice appear in supporting documentation.
  *
  * Prentice Hall and the author disclaim all warranties with regard to 
  * this software, including all implied warranties of merchantability and fitness.
  * In no event shall Prentice Hall or the author be liable for any special,
  * indirect or cosequential damages or any damages whatsoever resulting from 
  * loss of use, data or profits, whether in an action of contract, negligence 
  * or other tortious action, arising out of or in connection with the use 
  * or performance of this software.
  *
  * Open Software Foundation is a trademark of The Open Software Foundation, Inc.
  * OSF is a trademark of Open Software Foundation, Inc.
  * OSF/Motif is a trademark of Open Software Foundation, Inc.
  * Motif is a trademark of Open Software Foundation, Inc.
  * DEC is a registered trademark of Digital Equipment Corporation
  * HP is a registered trademark of the Hewlett Packard Company
  * DIGITAL is a registered trademark of Digital Equipment Corporation
  * X Window System is a trademark of the Massachusetts Institute of Technology
  **********************************************************************************/
#include <X11/Intrinsic.h> 
#include <Xm/Xm.h>

char * xs_get_string_from_xmstring (string) 
    XmString string; 
{ 
   caddr_t           context; 
   char             *text; 
   XmStringCharSet   charset; 
   XmStringDirection dir; 
   Boolean           separator; 
   char             *buf = NULL; 

 int               done = FALSE;
  XmStringInitContext (&context, string);
  while (!done)
   if(XmStringGetNextSegment (context, &text, &charset,
                              &dir, &separator)){ 
     if(separator) /* Stop when next segment is a separator */
        done = TRUE;

     if(buf){
        buf = XtRealloc(buf, strlen(buf) + strlen(text) + 2);
        strcat(buf, text);			
     }
     else {
        buf = (char *) XtMalloc(strlen(text) +1);
        strcpy(buf, text);
      }
     XtFree(text);
   }
     else
     done = TRUE;

  XmStringFreeContext (context);
  return buf;
}
@EOF

chmod 664 lib/xmstr_to_str.c

echo x - lib/send_msg.c
cat >lib/send_msg.c <<'@EOF'
/*******************************************************
 * xs_send_message(): send a client message
  *         From:
  *                   The X Window System, 
  *            Programming and Applications with Xt
  *                   OSF/Motif Edition
  *         by
  *                Douglas Young
  *              Prentice Hall, 1990
  *
  *                 Example described on pages:  ??
  *
  *
  *  Copyright 1989 by Prentice Hall
  *  All Rights Reserved
  *
  * This code is based on the OSF/Motif widget set and the X Window System
  *
  * Permission to use, copy, modify, and distribute this software for 
  * any purpose and without fee is hereby granted, provided that the above
  * copyright notice appear in all copies and that both the copyright notice
  * and this permission notice appear in supporting documentation.
  *
  * Prentice Hall and the author disclaim all warranties with regard to 
  * this software, including all implied warranties of merchantability and fitness.
  * In no event shall Prentice Hall or the author be liable for any special,
  * indirect or cosequential damages or any damages whatsoever resulting from 
  * loss of use, data or profits, whether in an action of contract, negligence 
  * or other tortious action, arising out of or in connection with the use 
  * or performance of this software.
  *
  * Open Software Foundation is a trademark of The Open Software Foundation, Inc.
  * OSF is a trademark of Open Software Foundation, Inc.
  * OSF/Motif is a trademark of Open Software Foundation, Inc.
  * Motif is a trademark of Open Software Foundation, Inc.
  * DEC is a registered trademark of Digital Equipment Corporation
  * HP is a registered trademark of the Hewlett Packard Company
  * DIGITAL is a registered trademark of Digital Equipment Corporation
  * X Window System is a trademark of the Massachusetts Institute of Technology
  **********************************************************************************/
#include <stdio.h>
#include <X11/Intrinsic.h>
#include <X11/StringDefs.h>
#include <X11/Xatom.h>

xs_send_message(display, window, msg_name, data)
     Display *display;
     Window   window;
     char    *msg_name;
     char    *data;
{
 XClientMessageEvent event;
 Atom                MSG_ATOM;
 /*
  * Get the atom used 
  * by the display.
  */
 MSG_ATOM = XInternAtom(display, msg_name, FALSE);
 /*
  * Fill out the client message event structure.
  */
 event.display = display; 
 event.window  = window;
 event.type    = ClientMessage;
 event.format  = 8;
 event.message_type = MSG_ATOM;
 strcpy(event.data.b, data);
 /*
  * Send it and flush.
  */
 XSendEvent(display, window, 
            TRUE, XtAllEvents, &event);
 XFlush(display);
}
@EOF

chmod 664 lib/send_msg.c

echo x - lib/strtoxmstr.c
cat >lib/strtoxmstr.c <<'@EOF'
/***********************************************************************
 * Convert an arrays of string sto an array of compound strings

  *         From:
  *                   The X Window System, 
  *            Programming and Applications with Xt
  *                   OSF/Motif Edition
  *         by
  *                Douglas Young
  *              Prentice Hall, 1990
  *
  *                 Example described on pages:  ??
  *
  *
  *  Copyright 1989 by Prentice Hall
  *  All Rights Reserved
  *
  * This code is based on the OSF/Motif widget set and the X Window System
  *
  * Permission to use, copy, modify, and distribute this software for 
  * any purpose and without fee is hereby granted, provided that the above
  * copyright notice appear in all copies and that both the copyright notice
  * and this permission notice appear in supporting documentation.
  *
  * Prentice Hall and the author disclaim all warranties with regard to 
  * this software, including all implied warranties of merchantability and fitness.
  * In no event shall Prentice Hall or the author be liable for any special,
  * indirect or cosequential damages or any damages whatsoever resulting from 
  * loss of use, data or profits, whether in an action of contract, negligence 
  * or other tortious action, arising out of or in connection with the use 
  * or performance of this software.
  *
  * Open Software Foundation is a trademark of The Open Software Foundation, Inc.
  * OSF is a trademark of Open Software Foundation, Inc.
  * OSF/Motif is a trademark of Open Software Foundation, Inc.
  * Motif is a trademark of Open Software Foundation, Inc.
  * DEC is a registered trademark of Digital Equipment Corporation
  * HP is a registered trademark of the Hewlett Packard Company
  * DIGITAL is a registered trademark of Digital Equipment Corporation
  * X Window System is a trademark of the Massachusetts Institute of Technology
  **********************************************************************************/
#include <X11/Intrinsic.h>
#include <Xm/Xm.h>
  
XmString xs_str_array_to_xmstr(cs, n)
   char   *cs[];
   int     n;
{
   XmString   xmstr;
   int        i;
   /*
    * If the array is empty just return an empty string.
    */
   if (n <= 0)
      return (XmStringCreate("", XmSTRING_DEFAULT_CHARSET));

  xmstr = (XmString) NULL;

  for (i = 0; i < n; i++)  {
    if (i > 0)
       xmstr = XmStringConcat(xmstr,XmStringSeparatorCreate ()); 
    xmstr = XmStringConcat(xmstr, XmStringCreate(cs[i], XmSTRING_DEFAULT_CHARSET));
  }
  return (xmstr);
}




@EOF

chmod 664 lib/strtoxmstr.c

echo x - lib/xor.c
cat >lib/xor.c <<'@EOF'
/**************************************************************************
 * xs_create_xor_gc():  utility routine  
  *         From:
  *                   The X Window System, 
  *            Programming and Applications with Xt
  *                   OSF/Motif Edition
  *         by
  *                Douglas Young
  *              Prentice Hall, 1990
  *
  *                 Example described on pages:  ??
  *
  *
  *  Copyright 1989 by Prentice Hall
  *  All Rights Reserved
  *
  * This code is based on the OSF/Motif widget set and the X Window System
  *
  * Permission to use, copy, modify, and distribute this software for 
  * any purpose and without fee is hereby granted, provided that the above
  * copyright notice appear in all copies and that both the copyright notice
  * and this permission notice appear in supporting documentation.
  *
  * Prentice Hall and the author disclaim all warranties with regard to 
  * this software, including all implied warranties of merchantability and fitness.
  * In no event shall Prentice Hall or the author be liable for any special,
  * indirect or cosequential damages or any damages whatsoever resulting from 
  * loss of use, data or profits, whether in an action of contract, negligence 
  * or other tortious action, arising out of or in connection with the use 
  * or performance of this software.
  *
  * Open Software Foundation is a trademark of The Open Software Foundation, Inc.
  * OSF is a trademark of Open Software Foundation, Inc.
  * OSF/Motif is a trademark of Open Software Foundation, Inc.
  * Motif is a trademark of Open Software Foundation, Inc.
  * DEC is a registered trademark of Digital Equipment Corporation
  * HP is a registered trademark of the Hewlett Packard Company
  * DIGITAL is a registered trademark of Digital Equipment Corporation
  * X Window System is a trademark of the Massachusetts Institute of Technology
  **********************************************************************************/
#include <X11/StringDefs.h>
#include <X11/Intrinsic.h> 

GC xs_create_xor_gc(w)
   Widget            w;
{
  XGCValues values;
  GC        gc;
  Arg       wargs[10];
  /*
   * Get the colors used by the widget.
   */
  XtSetArg(wargs[0], XtNforeground, &values.foreground);
  XtSetArg(wargs[1], XtNbackground, &values.background);
  XtGetValues(w, wargs,2);
  /*
   * Set the fg to the XOR of the fg and bg, so if it is
   * XOR'ed with bg, the result will be fg and vice-versa.
   * This effectively achieves inverse video for the line.
   */
  values.foreground = values.foreground ^ values.background;
  /*
   * Set the rubber band gc to use XOR mode and draw 
   * a dashed line.
   */
  values.line_style = LineOnOffDash;
  values.function   = GXxor;
  gc = XtGetGC(w, GCForeground | GCBackground | 
               GCFunction | GCLineStyle, &values);
  return gc;
}
@EOF

chmod 664 lib/xor.c

chmod 775 lib

echo x - more
cat >more <<'@EOF'

*** /disc/book/version2/release_code: directory ***

::::::::::::::
ERRATA
::::::::::::::
The following are various minor changes and problems that have been found
in the accompanying code or the first printing of the book. Code changes
have already been incorporated in the code and will be fixed in later
printings of the text.

Feb 2,1990

** Makefile

On some systems the library may need to be built with the "clq" or other
options to ar rather than the "ruv" options specified in the makefile

** Appendix B

Several widget resource listings specify NULL as the default for resources
such as XmNokLabelString, XmNhelpLabelString, etc. These get defaulted at
run time to "OK", "Help", etc.

** Pg 199.

#include <Xw/Xw.h> is unnecessary and should be removed or changed to Xm/Xm.h


** pg 240

strdup() isn't available on all systems. To be safe, replace

      else
        buf = strdup(text);

with

    else {
      buf = (char *) XtMalloc(strlen(text) +1);
      strcpy(buf, text);
    }


** Pg 318.

The event handler must be registered using ButtonPressMask instead of
ButtonPress.

** pg. 322.

The request_selection function should be registered as a callback, not an
event handler. The correct line is:

 XtAddCallback(request, XmNactivateCallback,
               request_selection, selection);

Also, on the next line, the event handler must be registered using
ButtonPressMask instead of ButtonPress.


** Chapter 12. 

The Dial example has some confused mis-use of GC's. The following changes
should be made:

** Pg 353-354

Replace all XCreateGC() calls in Initialize() with XtGetGC()

** Pg. 355 

Accordingly, change all calls to XFreeGC() in Destroy() to XtReleaseGC():

static void Destroy (w)
     XsDialWidget w;
{
  XtReleaseGC (w, w->dial.indicator_GC);
  XtReleaseGC (w, w->dial.dial_GC);
  XtReleaseGC (w, w->dial.inverse_GC);
  XtRemoveAllCallbacks (w, XtNselectCallback,
                         w->dial.select);
}


** Pg 357.

Add the following text before the last sentence, first paragraph

"However, in this example, the graphics contexts have been created using
XtGetGC(), which creates GCs that may be shared by others.  Therefore we
must not alter the GC in any way, or at least we must undo any changes
immediately. For this example we will take the easy way out and simply not
use the information in the region argument, redrawing the entire face of
the dial instead."

** Finally,

Eliminate the calls to XSetRegion() in the Redisplay() method.

** pg 376

The heading of section 13.2.2 should say "Public" not "Private"

** pg 382: 

The first field of the XtWidgetGeometry structure is request_mode, not
mask. The structure also has a border_width member.

** Pg. 382.

Second to the last sentence, last full paragraph should read:

"If the changes are unacceptable, or if the child's current geometry is
identical to the child's preferred geometry, the method should return
XtGeometryNo."

** Pg 383.

The comparison on the last two lines of code is incorrect in the book. It
should be

if(preferred->width <= request->width &&  
            preferred->height <= request->height){

similarly, in the same routine, the logic should be

if(request->request_mode & CWWidth){
      if(preferred->width <= request->width){
         	preferred->width = request->width;
         return (XtGeometryYes);

and 

if(request->request_mode & CWHeight){
      if(preferred->height <= request->height){
         	preferred->height = request->height;
         	return (XtGeometryYes);






@EOF

chmod 664 more

rm -f /tmp/unpack$$
exit 0
