// -*- C++ -*-
// automatically generated by autodoc

// ========== HEADER FILE src/comb/acgray.h: ==========

// ----- SRCFILE=src/comb/acgray.cc: -----
void ac_gray_delta(uchar *d, ulong ldn);
// Generate a delta sequence for an adjacent-changes (AC) Gray code
//  of length n=2**ldn where ldn<=6.
// Example (ldn=4):
//    0:  .... 0    0
//    1:  ...1 1    1    0  ...1
//    2:  ..11 2    3    1  ..1.
//    3:  .111 3    7    2  .1..
//    4:  .1.1 2    5    1  ..1.
//    5:  .1.. 1    4    0  ...1
//    6:  .11. 2    6    1  ..1.
//    7:  ..1. 1    2    2  .1..
//    8:  1.1. 2   10    3  1...
//    9:  111. 3   14    2  .1..
//   10:  11.. 2   12    1  ..1.
//   11:  11.1 3   13    0  ...1
//   12:  1111 4   15    1  ..1.
//   13:  1.11 3   11    2  .1..
//   14:  1..1 2    9    1  ..1.
//   15:  1... 1    8    0  ...1
// For ldn>=7 the routine produces delta sequences with
//   2**(ldn-5) - 1  (ldn odd)
//   2**(ldn-5) - 2  (ldn even)
// non-AC transitions ("flaws"):
//   ldn =0..6  #non-ac = 0
//   ldn =  7   #non-ac = 3
//   ldn =  8   #non-ac = 6
//   ldn =  9   #non-ac = 15
//   ldn = 10   #non-ac = 30
//   ldn = 11   #non-ac = 63
//   ldn = 12   #non-ac = 126
// Near-AC Gray codes with fewer "flaws" may well exist.

ulong test_ac_gray(ulong *g, ulong n);
// Count the number of non-AC transitions in a Gray path.
// If the returned value is zero, the Gray path is an AC-path.

void ac_gray(ulong *g, ulong ldn);
// Create an AC Gray code.
// (see ac_gray_delta())

// ========== HEADER FILE src/comb/arrangement-rgs.h: ==========

class arrangement_rgs;
// RGS for arrangements (all permutations of all subsets):
//   a digit is at most 1 + the number of nonzero digits in the prefix.
// The positions of nonzero digits determine the subset, and
//   their values (decreased by 1) are the (left) inversion table
//   (a rising factorial number) for the permutation.
// Lexicographic order.
// Cf. OEIS sequence A000522.

// ========== HEADER FILE src/comb/ascent-nonflat-rgs.h: ==========

class ascent_nonflat_rgs;
// Ascent sequences (restricted growth strings, RGS) without flat steps
// (i.e., no two adjacent digits are equal), lexicographic order.
// An ascent sequence is a sequence [d(1), d(2), ..., d(n)] where d(k)>=0
//   and d(k) <= 1 + asc([d(1), d(2), ..., d(k-1)]) and asc(.) counts the
//   number of ascents of its argument.
// The number of length-n RGS is (OEIS sequence A138265)
//   1, 1, 1, 2, 5, 16, 61, 271, 1372, 7795, 49093, 339386, 2554596, ...

// ========== HEADER FILE src/comb/ascent-rgs.h: ==========

class ascent_rgs;
// Ascent sequences (restricted growth strings, RGS), lexicographic order.
// An ascent sequence is a sequence [d(1), d(2), ..., d(n)] where d(1)=0, d(k)>=0,
//   and d(k) <= 1 + asc([d(1), d(2), ..., d(k-1)]) and asc(.) counts the
//   number of ascents of its argument.
// The number of length-n RGS is (OEIS sequence A022493)
//   1, 1, 2, 5, 15, 53, 217, 1014, 5335, 31240, 201608, ...

// ========== HEADER FILE src/comb/big-fact2perm.h: ==========

// ----- SRCFILE=src/comb/big-fact2perm.cc: -----
void perm2ffact(const ulong *x, ulong n, ulong *fc, left_right_array &LR);
// Convert permutation in x[0,...,n-1] into
//   the (n-1) digit factorial representation in fc[0,...,n-2].
// We have: fc[0]<n, fc[1]<n-1, ..., fc[n-2]<2 (falling radices)
// This is the so-called "Lehmer code" of a permutation.

void ffact2perm(const ulong *fc, ulong n, ulong *x, left_right_array &LR);
// Inverse of perm2ffact():
// Convert the (n-1) digit factorial representation in fc[0,...,n-2].
// into permutation in x[0,...,n-1]
// Must have: fc[0]<n, fc[1]<n-1, ..., fc[n-2]<2 (falling radices)

void ffact2invperm(const ulong *fc, ulong n, ulong *x, left_right_array &LR);
// Convert the (n-1) digit factorial representation in fc[0,...,n-2]
// into permutation in x[0,...,n-1] such that
// the permutation is the inverse of the one computed via ffact2perm().
// Must have: fc[0]<n, fc[1]<n-1, ..., fc[n-2]<2 (falling radices)

void perm2rfact(const ulong *x, ulong n, ulong *fc, left_right_array &LR);
// Convert permutation in x[0,...,n-1] into
//   the (n-1) digit factorial representation in fc[0,...,n-2].
// We have: fc[0]<2, fc[1]<3, ..., fc[n-2]<n (rising radices)

void rfact2perm(const ulong *fc, ulong n, ulong *x, left_right_array &LR);
// Inverse of perm2rfact():
// Convert the (n-1) digit factorial representation in fc[0,...,n-2].
//  into permutation in x[0,...,n-1]
// Must have: fc[0]<2, fc[1]<3, ..., fc[n-2]<n (rising radices)

void rfact2invperm(const ulong *fc, ulong n, ulong *x, left_right_array &LR);
// Convert the (n-1) digit factorial representation in fc[0,...,n-2].
//  into permutation in x[0,...,n-1] such that
// the permutation is the inverse of the one computed via rfact2perm().
// Must have: fc[0]<2, fc[1]<3, ..., fc[n-2]<n (rising radices)

// ========== HEADER FILE src/comb/binary-debruijn.h: ==========

class binary_debruijn : public binary_necklace;
// Lexicographically minimal binary De Bruijn sequence.

// ========== HEADER FILE src/comb/binary-huffman.h: ==========

class binary_huffman;
// Partitions of 1 into n powers of 1/2:
//   1 == a[0]/1 + a[1]/2 + a[2]/4 + a[3]/8 + ... a[m]/(2^m)  (for n>=1),
//   n == a[0] + a[1] + a[2] + a[3] + ... + a[m].
// Same as: binary Huffman codes (canonical trees) with n terminal nodes,
//   a[k] is the number of terminal nodes of depth k.
// Reversed lexicographic order.
// See:
//   Christian Elsholtz, Clemens Heuberger, Helmut Prodinger:
//   "The number of Huffman codes, compact trees, and sums of unit fractions",
//   arXiv:1108.5964 [math.CO], (30-August-2011).
//
// Cf. OEIS sequence A002572.

// ========== HEADER FILE src/comb/binary-necklace.h: ==========

class binary_necklace;
// Binary necklaces, pre-necklaces, and Lyndon words.
// Cf. OEIS sequences A062692 (pre-necklaces), A000031 (necklaces),
// and A001037 (Lyndon words).

// ========== HEADER FILE src/comb/binary-sl-gray.h: ==========

class binary_sl_gray;
// Binary numbers in a minimal-change order
// related so subset-lex order ("SL-Gray" order).
// Loopless generation, only O(1) data beyond the array of bits.
// Successive transitions are mostly adjacent,
// and otherwise have distance 3.
// Special case of class mixed_radix_sl_gray for base 2.
// Cf. OEIS sequence A217262.

// ========== HEADER FILE src/comb/catalan-gslex.h: ==========

class catalan_gslex;
// Catalan restricted growth strings (RGS),
// ordering similar to gslex (and subset-lex) order.
// Loopless algorithm.

// ========== HEADER FILE src/comb/catalan-path-lex.h: ==========

class catalan_path_lex;
// Catalan paths in lexicographic order, CAT algorithm.
// Steps are +1, 0, -1 (up, horizontal, down),
// the first and last elements are 0, all elements are non-negative,
// and even/odd positions respectively have even/odd entries only.

// ========== HEADER FILE src/comb/catalan-rgs-gray.h: ==========

class catalan_rgs_gray;
// Catalan restricted growth strings (RGS),
// Gray code for parenthesis strings (but *not* for the RGS).

// ========== HEADER FILE src/comb/catalan-rgs.h: ==========

class catalan_rgs;
// Catalan restricted growth strings (RGS), lexicographic order.
// The number of length-n RGS is (OEIS sequence A000108)
//  1, 1, 2, 5, 14, 42, 132, 429, 1430, 4862, 16796, ...

// ========== HEADER FILE src/comb/catalan-step-rgs-colex.h: ==========

class catalan_step_rgs_colex;
// Catalan step RGS (restricted growth strings), co-lexicographic order.
// RGS are a[] such that a[k] >= a[k-1] (non-decreasing) and a[k]<=k.
// The RGS describe lattice paths from (0,0) to (n,n) with steps
// (+1,0) and (+1,+1) that do not go below the diagonal.
// Cf. OEIS sequence A000108.

// ========== HEADER FILE src/comb/catalan-step-rgs-lex.h: ==========

class catalan_step_rgs_lex;
// Catalan step RGS (restricted growth strings), lexicographic order.
// RGS are a[] such that a[k] >= a[k-1] (non-decreasing) and a[k]<=k.
// The RGS describe lattice paths from (0,0) to (n,n) with steps
// (+1,0) and (+1,+1) that do not go below the diagonal.
// Same as: rising factorial numbers where the digits are sorted.
// Cf. OEIS sequence A000108.

// ========== HEADER FILE src/comb/catalan-step-rgs-print-aa.h: ==========

// ----- SRCFILE=src/comb/catalan-step-rgs-print-aa.cc: -----
void catalan_step_rgs_print_aa(const ulong *a, ulong n);
// Render the lattice path for the RGS as ASCII art.
// The path for the RGS a[] starts at (0, 0)==(0, a[0]),
// goes over the points (k, a[k]) for 1 <= k <= n-1,
// and ends at (n, n)==(n, a[n]).
// Steps are (+1,0) and (+1,+1) and the path does not
// go below the diagonal (k, k) for 0 <= k <= n.

// ========== HEADER FILE src/comb/catalan-step-rgs-subset-lexrev.h: ==========

class catalan_step_rgs_subset_lexrev;
// Catalan step RGS (restricted growth strings), subset-lexrev order.
// RGS are a[] such that a[k] >= a[k-1] (non-decreasing) and a[k]<=k.
// The RGS describe lattice paths from (0,0) to (n,n) with steps
// (+1,0) and (+1,+1) that do not go below the diagonal.
// Same as: rising factorial numbers where the digits are sorted.

// ========== HEADER FILE src/comb/catalan-subset-lex.h: ==========

class catalan_subset_lex;
// Catalan restricted growth strings (RGS), subset-lex order.

// ========== HEADER FILE src/comb/catalan.h: ==========

class catalan;
// Catalan restricted growth strings (RGS)
// By default in a minimal-change order, i.e.
//  exactly two symbols in paren string change with each step.
// Most changes are adjacent or skip-2
// Non adjacent changes move a bit over ones.

// ========== HEADER FILE src/comb/cayley-perm.h: ==========

class cayley_perm;
// Cayley permutations:  Length-n words such that all elements
//   from 0 to the maximum value occur at least once.
// Same as: permutations of the (RGS for) set partitions of n.
// Same as: weak orders on n elements (weak orders are
//   relations that are transitive and complete).
// Same as: preferential arrangements of n labeled elements.
// Generation such that the major order is by content, and
//   the minor order is lexicographic.
// Cf. OEIS sequence A000670.

// ========== HEADER FILE src/comb/check-kpermgen.h: ==========

class check_kpermgen : bitarray;
// Checking validity of list of k-permutations.

// ========== HEADER FILE src/comb/check-mixedradix.h: ==========

class check_mixedradix : public bitarray;
// Checking validity of list of mixed radix numbers.

// ========== HEADER FILE src/comb/check-permgen.h: ==========

class check_permgen : bitarray;
// Checking validity of list of permutations.

// ========== HEADER FILE src/comb/comb-print.h: ==========

// ----- SRCFILE=src/comb/print-set.cc: -----
void print_set(const char *bla, const ulong *x, ulong n, ulong off/*=0*/);
// Print x[0,..,n-1] as set, n is the number of elements in the set.
// Example:  x[]=[0,1,3,4,8]  ==> "{0,1,3,4,8}"

void print_set_as_deltaset(const char *bla, const ulong *x, ulong n, ulong N, const char *c01/*=0*/);
// Print x[0,..,n-1], a subset of {0,1,...,N-1} as delta set,
// n is the number of elements in the set.
// Example:  x[]=[0,1,3,4,8]  ==> "11.11...1"

void print_set1_as_deltaset(const char *bla, const ulong *x, ulong n, ulong N, const char *c01/*=0*/);
// Print x[0,..,n-1], a subset of {1,...,N} as delta set,
// n is the number of elements in the set.
// Example:  x[]=[1,2,4,5,9]  ==> "11.11...1"

ulong print_deltaset_as_set(const char *bla, const ulong *x, ulong n, int eq/*=0*/);
// Print delta set x[0,..,n-1] as set.
// Example:  x[]=[0,0,1,0,1,1] ==> "{2,4,5}"
// if eq!=0 then print spaces for empty positions:
// With example above:  "{ , , 2, , 4, 5}"
// Return number of elements (3 in example).

ulong print_deltaset_as_set1(const char *bla, const ulong *x, ulong n, int eq/*=0*/);
// Print delta set x[0,..,n-1] as set, lowest element one.
// Example:  x[]=[0,0,1,0,1,1] ==> "{3,5,6}"
// if eq!=0 then print spaces for empty positions:
// With example above:  "{ , , 3, , 5, 6}"
// Return number of elements (3 in example).

void print_deltaset(const char *bla, const ulong *x, ulong n, const char *c01/*=0*/);
// Print the delta set x[0,..,n-1]
// n is the number of elements in the set.
// Example:  x[]=[1,0,1,1,0,0,0,1]  ==> "11.11...1"

// ----- SRCFILE=src/comb/print-mset.cc: -----
ulong print_multi_deltaset_as_set(const char *bla, const ulong *x, ulong n, bool cq/*=true*/);
// Print multi delta set x[0,..,n-1]  as set.
// Example:  x[]=[0,0,1,0,3,0,1] ==> "{2,4,4,4,6}"
// Return number of elements (5 in example).
// Parameter cq determines whether commas (and spaces) are printed between elements.

ulong print_multi_deltaset_as_set_alph(const char *bla, const ulong *x, ulong n, bool cq/*=true*/);
// Print multi delta set x[0,..,n-1]  as set of letters.
// Example:  x[]=[0,1,3,0,1] ==> "{b,c,c,c,e}"
// Return number of elements (5 in example).
// Parameter cq determines whether commas (and spaces) are printed between elements.

// ----- SRCFILE=src/comb/print-perm.cc: -----
void print_perm(const char *bla, const ulong *f, ulong n, bool dfz/*=false*/);
// Print n-digit permutation in f[].
// If dfz is true then Dots are printed For Zeros.

// ----- SRCFILE=src/comb/print-setpart.cc: -----
void print_setpart(const char *bla, const ulong *r, ulong n, ulong ns, ulong off/*=1*/);
// Print length-n RGS s[] for set partition as set partition.
// Offset off is added to all elements.
// ns should be the number of sets, it is computed if given as zero.

// ----- SRCFILE=src/comb/print-vec.cc: -----
void print_vec(const char *bla, const ulong *x, ulong n, bool dfz/*=false*/);
// Print x[0,..,n-1] as vector, n is the number of elements in the set.
// If dfz is true then Dots are printed For Zeros.

void print_vec_rev(const char *bla, const ulong *x, ulong n, bool dfz/*=false*/);
// Print x[0,..,n-1] as vector in reversed order, n is the number of elements in the set.
// If dfz is true then Dots are printed For Zeros.

void print_sign_vec(const char *bla, const ulong *x, ulong n);
// Print x[0,..,n-1] as vector of signs

void print_sym_vec(const char *bla, const ulong *x, ulong n);
// Print x[0,..,n-1] as vector of symbols where
// symbols are 0,1,..,9, A,B...,Z, a,b,...,z

// ----- SRCFILE=src/comb/print-mixedradix.cc: -----
void print_mixedradix(const char *bla, const ulong *f, ulong n, bool dfz/*=false*/);
// Print n-digit mixed radix number in f[].
// If dfz is true then Dots are printed For Zeros.

// ----- SRCFILE=src/comb/print-gray.cc: -----
void print_gray(const ulong *f, ulong n);
// Pretty print Gray path

void print_gray_delta(const ulong *f, ulong n, ulong lb/*=0*/);
// Print delta seqeunce (base-36).
// If lg!=0 then break line after lg characters.

// ========== HEADER FILE src/comb/combination-chase.h: ==========

class combination_chase;
// Combinations (n choose k) in strong minimal-change order.
// The delta set is generated.
// "Chase's sequence", algorithm as given by Knuth.

// ========== HEADER FILE src/comb/combination-colex.h: ==========

class combination_colex;
// Combinations n choose k (co-lexicographic order)

// ========== HEADER FILE src/comb/combination-emk.h: ==========

class combination_emk;
// Combinations in strong minimal-change order (Eades-McKay sequence).
// The set (as opposed to delta set) is generated.
// Generation via modulo steps counting.

// ========== HEADER FILE src/comb/combination-endo.h: ==========

class combination_endo;
// Combinations (n choose k) in strong minimal-change order ("Chase's sequence").
// The set (as opposed to delta set) is generated.
// Generation via endo/enup counting.

// ========== HEADER FILE src/comb/combination-enup.h: ==========

class combination_enup;
// Combinations in strong minimal-change order (enup steps).
// The set (as opposed to delta set) is generated.
// Generation via enup/endo counting.

// ========== HEADER FILE src/comb/combination-lex.h: ==========

class combination_lex;
// Combinations n choose k (lexicographic order)

// ========== HEADER FILE src/comb/combination-mod.h: ==========

class combination_mod;
// Combinations in strong minimal-change order.
// The set (as opposed to delta set) is generated.
// Generation via modulo steps counting.
// Obtained by a slight modification of the Eades-McKay sequence.

// ========== HEADER FILE src/comb/combination-pref.h: ==========

class combination_pref;
// Combinations via prefix shifts ("cool-lex" order) as delta sets.
//.
//  Algorithm as in
//  Frank Ruskey, Aaron Williams:
//    "Generating combinations by prefix shifts"
//    Lecture Notes in Computer Science, vol.3595, 2005.
//    Extended Abstract for COCOON 2005.

// ========== HEADER FILE src/comb/combination-rec.h: ==========

class comb_rec;
// Combinations in lexicographic, Gray code,
// complemented enup, and complemented Eades-McKay order.
// Recursive algorithm.

// ========== HEADER FILE src/comb/combination-revdoor.h: ==========

class combination_revdoor;
// Combinations (n choose k) in minimal-change order.
// "Revolving door" algorithm following Knuth.
// See:
//   W. H. Payne, F. M. Ives: "Combination Generators",
//   ACM Transactions on Mathematical Software (TOMS),
//   vol.5, no.2, pp.163-172, June-1979.

// ========== HEADER FILE src/comb/comp2comb.h: ==========

// Conversion between combinations and compositions
inline void comp2comb_nk(ulong n, ulong k, ulong &N, ulong &K);
// A composition P(n,k) of n into (at most) k parts corresponds to
// a combination B(N,K) of K=n parts from N=n+k-1 elements:
//   P(n, k)  <-->  B(N, K) == B(n+k-1, n)

inline void comb2comp_nk(ulong N, ulong K, ulong &n, ulong &k);
// A combination B(N,K) of K elements out of N
// corresponds to a composition P(n,k) of n into (at most) k parts
// where k=N-K+1 and n=K:
//   B(N, K)  <-->  P(n, k) == P(K, N-K+1)

inline void comp2comb(const ulong *p, ulong k, ulong *b);
// Convert composition P(*, k) in p[] to combination in b[]

inline void comb2comp(const ulong *b, ulong N, ulong K, ulong *p);
// Convert combination B(N, K) in b[] to composition P(*,k) in p[]
// Must have: K>=1

inline void reverse_combination(ulong *b, ulong N, ulong K);
// Reverse order and complement values in combination b[]
// Equivalent to order reversal of the corresponding composition:
//   B <--> P  ==>  reverse_combination(B) <--> reverse(P)

// ========== HEADER FILE src/comb/composition-colex.h: ==========

class composition_colex;
// Compositions of n into (at most) k parts (k-compositions of n),
// co-lexicographic (colex) order

// ========== HEADER FILE src/comb/composition-colex2.h: ==========

class composition_colex2;
// Compositions of n into (at most) k parts (k-compositions of n),
// co-lexicographic (colex) order.
// Implementation efficient also with sparse case, i.e. k much greater than n.
// Loopless algorithm.

// ========== HEADER FILE src/comb/composition-ex-colex.h: ==========

class composition_ex_colex;
// Compositions of n into exactly k parts (k-compositions of n),
// co-lexicographic (colex) order.
// Must have:  n>=k.

// ========== HEADER FILE src/comb/composition-nz-carlitz.h: ==========

class composition_nz_carlitz;
// Compositions of n into positive parts, such that
// adjacent parts are different.  Lexicographic order.
// Cf. OEIS sequence A003242.

// ========== HEADER FILE src/comb/composition-nz-conj.h: ==========

inline ulong composition_nz_conj(const ulong *x, ulong m, ulong *c);
// Write conjugate of composition x[] (m non-zero parts) to c[].
// Return number of parts written to c[].
// Conjugation is swapping separators and non-separators
//   in the "stars and bars" representation.
// For example, [5,3,1,2,2] and [1,1,1,1,2,1,3,2,1] are conjugates:
//
//       5       3   1  2   2
//  |* * * * *|* * *|*|* *|* *|
//  |*|*|*|*|* *|*|* * *|* *|*|
//   1 1 1 1  2  1   3    2  1
//

// ========== HEADER FILE src/comb/composition-nz-left-smooth.h: ==========

class composition_nz_left_smooth;
// Left-smooth compositions in lexicographic order.
// Cf. OEIS sequence A005169.

// ========== HEADER FILE src/comb/composition-nz-max.h: ==========

class composition_nz_max;
// Compositions of n into positive parts <= mx.
// Lexicographic order.

// ========== HEADER FILE src/comb/composition-nz-min.h: ==========

class composition_nz_min;
// Compositions of n into positive parts >= mi.
// Lexicographic order.

// ========== HEADER FILE src/comb/composition-nz-minc.h: ==========

class composition_nz_minc;
// Compositions of n into positive parts with first part c and
//   each part <= f times its predecessor.
// For c=1 the same as: f-ary Huffman codes (canonical trees) with
//   (f-1)*n+1 terminal nodes, a[k] is the number of internal nodes of depth k.
// Such compositions (for f=2) are treated in
//   Henryk Minc: "A Problem in Partitions: Enumeration of Elements of a
//     given Degree in the free commutative entropic cyclic Groupoid",
//   Proceedings of the Edinburgh Mathematical Society (2),
//   vol.11, no.4, pp.223-224, (November-1959).
// The compositions for f=2 are also called "Cayley compositions", see
//   George E. Andrews, Peter Paule, Axel Riese, Volker Strehl:
//   "MacMahon's Partition Analysis V: Bijections, Recursions, and Magic Squares",
//   in: Algebraic Combinatorics and Applications, proceedings of Euroconference Alcoma 99,
//   September 12-19, 1999, Goessweinstein, Germany,
//   A. Betten, A. Kohnert, R. Laue, A. Wassermann eds., Springer-Verlag, pp.1-39, (2001).
// See also:
//   Christian Elsholtz, Clemens Heuberger, Helmut Prodinger:
//   "The number of Huffman codes, compact trees, and sums of unit fractions",
//   arXiv:1108.5964 [math.CO], (30-August-2011).
//
// Cf. OEIS sequences:
// f=2:  A002572 (c=1), A002573 (c=2), A002574 (c=3),
//       A049284 (c=4), A049285 (c=5).
// c=1:  A002572 (f=2), A176485 (f=3), A176503 (f=4),
//       A194628 (f=5), A194629 (f=6), A194630 (f=7),
//       A194631 (f=8), A194632 (f=9), A194633 (f=10).

// ========== HEADER FILE src/comb/composition-nz-numparts.h: ==========

class composition_nz_numparts;
// Compositions of n into nonzero parts.
// Ordering is firstly by number of parts  (1, 2, ..., n)
//   and secondly co-lexicographic (colex).

// ========== HEADER FILE src/comb/composition-nz-odd-subset-lex.h: ==========

class composition_nz_odd_subset_lex;
// Compositions of n into positive odd parts, subset-lex order.
// Loopless algorithm.
// Cf. OEIS sequence A000045.

// ========== HEADER FILE src/comb/composition-nz-odd.h: ==========

class composition_nz_odd;
// Compositions of n into positive odd parts, lexicographic order.
// Loopless algorithm.
// Cf. OEIS sequence A000045.

// ========== HEADER FILE src/comb/composition-nz-rank.h: ==========

inline ulong composition_nz_rank(const ulong *x, ulong m);
// Return rank r of composition x[], 0 <= r < 2**(n-1)
// where n is the sum of all parts.

inline ulong composition_nz_unrank(ulong r, ulong *x, ulong n);
// Return number of parts m of generated composition, 1 <= m <= n.

inline ulong composition_nz_rl_rank(const ulong *x, ulong m);
// Return (run-length) rank r of composition x[], 0 <= r < 2**(n-1)
// where n is the sum of all parts.

inline ulong composition_nz_rl_unrank(ulong r, ulong *x, ulong n);
// Return number of parts m of generated composition, 1 <= m <= n.

// ========== HEADER FILE src/comb/composition-nz-restrpref.h: ==========

class composition_nz_restrpref;
// Compositions of n into positive parts with restricted prefixes.
// Lexicographic order.

// ========== HEADER FILE src/comb/composition-nz-rl.h: ==========

class composition_nz_rl;
// Compositions of n into positive parts, order by run-length rank.
// Loopless algorithm.

// ========== HEADER FILE src/comb/composition-nz-smooth.h: ==========

class composition_nz_smooth;
// Smooth compositions in lexicographic order.
// Same as "1-dimensional sand piles", see OEIS sequence A186085.

// ========== HEADER FILE src/comb/composition-nz-sorts.h: ==========

class composition_nz_sorts;
// Compositions of n into positive parts of s sorts.
// Lexicographic order: major order by sorts, minor by parts.
// Loopless algorithm.
// Cf. OEIS sequences (compositions of n into parts of s kinds):
// A011782 (s=1), A025192 (s=2), A002001 (s=3), A005054 (s=4),
// A052934 (s=5), A055272 (s=6), A055274 (s=7), and A055275 (s=8).

// ========== HEADER FILE src/comb/composition-nz-sorts2-pp.h: ==========

class composition_nz_sorts2_pp;
// Compositions of n into positive parts of s[k] sorts for part (size) k.
// Lexicographic order: major order by parts, minor by sorts.
// Loopless algorithm.
// Cf. OEIS sequence A088305
//   compositions of n into one sort of 1's, two sorts of 2's, ..., k sorts of k's.
// Cf. OEIS sequences (compositions of n into (all) parts of s kinds):
// A011782 (s=1), A025192 (s=2), A002001 (s=3), A005054 (s=4),
// A052934 (s=5), A055272 (s=6), A055274 (s=7), and A055275 (s=8).

// ========== HEADER FILE src/comb/composition-nz-sorts2.h: ==========

class composition_nz_sorts2;
// Compositions of n into positive parts of s sorts.
// Lexicographic order: major order by parts, minor by sorts.
// Loopless algorithm.
// Cf. OEIS sequences (compositions of n into parts of s kinds):
// A011782 (s=1), A025192 (s=2), A002001 (s=3), A005054 (s=4),
// A052934 (s=5), A055272 (s=6), A055274 (s=7), and A055275 (s=8).

// ========== HEADER FILE src/comb/composition-nz-subset-lex.h: ==========

class composition_nz_subset_lex;
// Compositions of n into positive parts.
// Gray code such that either two adjacent positions change
//   or one unit is moved by two positions.
// The number of parts changes by one at each transition.
// Loopless algorithm.

// ========== HEADER FILE src/comb/composition-nz-superdiagonal.h: ==========

class composition_nz_superdiagonal;
// Superdiagonal compositions: compositions a[1] + a[2] + ... + a[m] = n
//   such that a[k] >= k.
// Lexicographic order.
// Same as: superdiagonal bargraphs, see
//   Emeric Deutsch, Emanuele Munarini, Simone Rinaldi:
//   "Skew Dyck paths, area, and superdiagonal bargraphs",
//   Journal of Statistical Planning and Inference,
//   vol.140, no.6, pp.1550-1562, (June-2010).
// Cf. OEIS sequence A219282.

// ========== HEADER FILE src/comb/composition-nz-upstep.h: ==========

class composition_nz_upstep;
// Compositions of n into positive parts, with limit on up-step.
// Lexicographic order.
// Cf. OEIS sequences A003116 (max up-step 1)
// and A224959 (max up-step 2).
// Max up-step 0 gives partitions as non-increasing lists.

// ========== HEADER FILE src/comb/composition-nz-weakly-unimodal.h: ==========

class composition_nz_weakly_unimodal;
// Weakly unimodal compositions, lexicographic order.
// Cf. OEIS sequence A001523.

// ========== HEADER FILE src/comb/composition-nz.h: ==========

class composition_nz;
// Compositions of n into positive parts, lexicographic order.
// Loopless algorithm for successor.

// ========== HEADER FILE src/comb/composition-print-aa.h: ==========

// ----- SRCFILE=src/comb/composition-print-aa.cc: -----
void print_composition_aa(const ulong *a, ulong m);

// ========== HEADER FILE src/comb/composition-rank.h: ==========

class composition_rank : public num_compositions;
// Ranking and unranking compositions in
//   lexicographic, minimal-change, or enup (two-close) order.
// The routines rank_*(x,n,k) have complexity k*k.
// The routines unrank_*(x,n,k) have complexity k * X
//   where X is the complexity of unrank_get_el();
//   X=n as given but can be reduced to log(n).
// Note: the two-close order corresponds to the enup order for combinations.

// ========== HEADER FILE src/comb/cyclic-perm.h: ==========

class cyclic_perm;
// Cyclic permutations in minimal-change order.
// CAT algorithm based on mixed radix Gray code
//   for the factorial number system.

// ========== HEADER FILE src/comb/debruijn.h: ==========

class debruijn : public necklace;
// Lexicographic minimal De Bruijn sequence.

// ========== HEADER FILE src/comb/delta2gray.h: ==========

// ----- SRCFILE=src/comb/delta2gray.cc: -----
void delta2gray(const unsigned char *d, ulong ldn, ulong *g, ulong g0/*=0*/);
// Fill into g[0..N-1] (N=2**ldn) the Gray path
//  corresponding to the delta sequence d[0..N-2].

void gray2delta(ulong ldn, const ulong *g, unsigned char *d);
// Inverse of delta2gray().

// ========== HEADER FILE src/comb/descent-rgs.h: ==========

class descent_rgs;
// Descent sequences (restricted growth strings, RGS), lexicographic order.
// A descent sequence is a sequence [d(1), d(2), ..., d(n)] where d(1)=0,
//   d(k)>=0, and d(k) <= 1 + desc([d(1), d(2), ..., d(k-1)]) and desc(.)
//   counts the number of descents of its argument.
// The number of length-n RGS is (OEIS sequence A225588)
//   1, 1, 2, 4, 9, 23, 67, 222, 832, 3501, 16412, 85062, 484013, ...

// ========== HEADER FILE src/comb/dyck-gray.h: ==========

class dyck_gray;
// Gray code for k-ary Dyck words with all transitions homogenous.
// Loopless algorithm following
//   Dominique Roelants van Baronaigien:
//   "A Loopless Gray-Code Algorithm for Listing k-ary Trees",
//   Journal of Algorithms, vol.35, pp.100-107, (2000).

// ========== HEADER FILE src/comb/dyck-gray2.h: ==========

class dyck_gray2;
// Loopless generation of k-ary Dyck words (same as: k-ary trees)
// (two-close Gray code with homogeneous moves).
// Adapted from:
//   Vincent Vajnovszki, Timothy R. Walsh:
//   "A loop-free two-close Gray-code algorithm for listing k-ary Dyck words",
//   Journal of Discrete Algorithms, vol.4, no.4, pp.633-648, (December-2006)

// ========== HEADER FILE src/comb/dyck-pref.h: ==========

class dyck_pref;
// k-ary Dyck words
// Algorithm "coolkat" as given (left in figure "Algorithms 1") in
//   Stephane Durocher, Pak Ching Li, Debajyoti Mondal, Aaron Williams:
//   "Ranking and Loopless Generation of k-ary Dyck Words in Cool-lex Order",
//   The 22nd International Workshop on Combinatorial Algorithms,
//   Victoria, Canada, IWOCA, (2011).

// ========== HEADER FILE src/comb/dyck-pref2.h: ==========

class dyck_pref2;
// k-ary Dyck words
// Algorithm "coolKat" as given (right in figure "Algorithms 1") in
//   Stephane Durocher, Pak Ching Li, Debajyoti Mondal, Aaron Williams:
//   "Ranking and Loopless Generation of k-ary Dyck Words in Cool-lex Order",
//   The 22nd International Workshop on Combinatorial Algorithms,
//   Victoria, Canada, IWOCA, (2011).

// ========== HEADER FILE src/comb/dyck-rgs-subset-lex.h: ==========

class dyck_rgs_subset_lex;
// Restricted growth strings (RGS) for k-ary Dyck words, subset-lex order.

// ========== HEADER FILE src/comb/dyck-rgs.h: ==========

class dyck_rgs;
// Restricted growth strings (RGS) corresponding to k-ary Dyck words (k=i+1):
//  s[0,...,n-1] such that s[k] <= s[k-1]+i
// Lexicographic order.
// Number of RGS is binomial(i*n,n)/((i-1)*n+1), (Catalan numbers for i=1).

// ========== HEADER FILE src/comb/endo-enup.h: ==========

static inline ulong next_endo(ulong x, ulong m);
// Return next number in endo order
// (endo := "Even Numbers DOwn, odd numbers up")
// m := max digit
//  m:   endo sequence
//  1:   1 0
//  2:   1 2 0
//  3:   1 3 2 0
//  4:   1 3 4 2 0
//  5:   1 3 5 4 2 0
//  6:   1 3 5 6 4 2 0
//  7:   1 3 5 7 6 4 2 0
//  8:   1 3 5 7 8 6 4 2 0
//  9:   1 3 5 7 9 8 6 4 2 0
// The routine computes one for the input zero (wrap around).

static inline ulong next_enup(ulong x, ulong m);
// Return next number in enup order
// (enup := "Even Numbers UP, odd numbers down")
// enup order is reversed endo order.
// m := max digit
//  m:   enup sequence
//  1:   0 1
//  2:   0 2 1
//  3:   0 2 3 1
//  4:   0 2 4 3 1
//  5:   0 2 4 5 3 1
//  6:   0 2 4 6 5 3 1
//  7:   0 2 4 6 7 5 3 1
//  8:   0 2 4 6 8 7 5 3 1
//  9:   0 2 4 6 8 9 7 5 3 1
// The routine computes zero for the input one (wrap around).

static inline ulong prev_endo(ulong x, ulong m);
// Return previous number in endo order
// Inverse of next_endo()

static inline ulong prev_enup(ulong x, ulong m);
// Return previous number in enup order
// Inverse of next_enup()

static inline ulong endo_num(ulong x, ulong m);
// Return the x-th number in endo order.
// m := max digit
// For example, with m=5:
//  x:   0 1 2 3 4 5
//  r:   1 3 5 4 2 0
// Must have  x<=m.

static inline ulong endo_idx(ulong x, ulong m);
// Inverse of endo_num()
// For example, with m=5:
//  x:   0 1 2 3 4 5
//  r:   5 0 4 1 3 2
// Must have  x<=m.

static inline ulong enup_num(ulong x, ulong m);
// Return the x-th number in enup order.
// m := max digit
// For example, with m=5:
//  x:   0 1 2 3 4 5
//  r:   0 2 4 5 3 1
// Must have  x<=m.

static inline ulong enup_idx(ulong x, ulong m);
// Inverse of enup_num()
// m := max digit
// For example, with m=5:
//  x:   0 1 2 3 4 5
//  r:   0 5 1 4 2 3
// Must have  x<=m.

// ========== HEADER FILE src/comb/fact2num.h: ==========

// ----- SRCFILE=src/comb/fact2num.cc: -----
ulong ffact2num(const ulong *fc, ulong n);
// Convert (falling) factorial in fc[] to number.
// Note: n!-1 must fit into a ulong ==> only good for _tiny_ n

bool num2ffact(ulong x, ulong *fc, ulong n);
// Convert number x to (falling) factorial in fc[0,...,n-1].
// Return whether x fits into fc[]

ulong rfact2num(const ulong *fc, ulong n);
// Convert (rising) factorial in fc[] to number.
// Note: n!-1 must fit into a ulong ==> only good for _tiny_ n

bool num2rfact(ulong x, ulong *fc, ulong n);
// Convert number x to (rising) factorial in fc[0,...,n-1].
// Return whether x fits into fc[]

// ========== HEADER FILE src/comb/fact2num2perm.h: ==========

// all conversions between factorials, permutations, and numbers
// ========== HEADER FILE src/comb/fact2perm.h: ==========

// ----- SRCFILE=src/comb/fact2perm.cc: -----
void perm2ffact(const ulong *x, ulong n, ulong *fc);
// Convert permutation in x[0,...,n-1] into
//   the (n-1) digit falling factorial representation in fc[0,...,n-2].
// We have: fc[0]<n, fc[1]<n-1, ..., fc[n-2]<2 (falling radices)
// Works as long as all elements in x[] are distinct.
// This is the so-called "Lehmer code" of a permutation.
// On return fc[k] contains the number of right inversions of position k,
//  the number of j > k where x[j] < x[k].

void ffact2perm(const ulong *fc, ulong n, ulong *x, bool iq/*=true*/);
// Inverse of perm2ffact():
// Convert the (n-1) digit falling factorial representation
//  in fc[0,...,n-2] into a permutation in x[0,...,n-1].
// Must have: fc[0]<n, fc[1]<n-1, ..., fc[n-2]<2 (falling radices)
// Set iq==true if permutation shall be initialized with 0,1,...,n-1.

void ffact2invperm(const ulong *fc, ulong n, ulong *x, bool iq/*=true*/);
// Convert the (n-1) digit falling factorial representation in fc[0,...,n-2]
// into permutation in x[0,...,n-1] such that
// the permutation is the inverse of the one computed via ffact2perm().
// Must have: fc[0]<n, fc[1]<n-1, ..., fc[n-2]<2 (falling radices)
// Set iq==true if permutation shall be initialized with 0,1,...,n-1.

void perm2rfact(const ulong *x, ulong n, ulong *fc);
// Convert permutation in x[0,...,n-1] into
//   the (n-1) digit rising factorial representation in fc[0,...,n-2].
// We have: fc[0]<2, fc[1]<3, ..., fc[n-2]<n (rising radices)
// Works as long as all elements in x[] are distinct.
// On return fc[k] contains the number of left inversions of position k,
//  the number of j < k where x[j] > x[k].

void rfact2perm(const ulong *fc, ulong n, ulong *x, bool iq/*=true*/);
// Inverse of perm2rfact():
// Convert the (n-1) digit rising factorial representation in fc[0,...,n-2].
//  into permutation in x[0,...,n-1]
// Must have: fc[0]<2, fc[1]<3, ..., fc[n-2]<n (rising radices)
// Set iq==true if permutation shall be initialized with 0,1,...,n-1.

void rfact2invperm(const ulong *fc, ulong n, ulong *x, bool iq/*=true*/);
// Convert the (n-1) digit rising factorial representation in fc[0,...,n-2].
//  into permutation in x[0,...,n-1] such that
// the permutation is the inverse of the one computed via rfact2perm().
// Must have: fc[0]<2, fc[1]<3, ..., fc[n-2]<n (rising radices)
// Set iq==true if permutation shall be initialized with 0,1,...,n-1.

void perm_rev_compl(ulong *x, ulong n, bool zb/*=true*/);
// Reverse and complement permutation in x[].
// zb shell reflect if the entires start from 0 (else from 1).

// ----- SRCFILE=src/comb/fact2perm-swp.cc: -----
void perm2ffact_swp(const ulong *x, ulong n, ulong *fc);
// Convert permutation in x[0, 1, ..., n-1] into
//   the (n-1) digit (swaps) factorial representation in fc[0, 1, ..., n-2].
// We have: fc[0]<n, fc[1]<n-1, ..., fc[n-2]<2 (falling radices)
// Work is proportional to n.

void ffact2perm_swp(const ulong *fc, ulong n, ulong *x, bool iq/*=true*/);
// Inverse of perm2ffact_swp().
// Permutation is different than that obtained via ffact2perm().
// Work is proportional to n.
// Set iq==true if permutation shall be initialized with 0,1,...,n-1.

void ffact2invperm_swp(const ulong *fc, ulong n, ulong *x, bool iq/*=true*/);
// Generate inverse permutation wrt. ffact2perm_swp().
// Work is proportional to n.
// Set iq==true if permutation shall be initialized with 0,1,...,n-1.

void perm2rfact_swp(const ulong *x, ulong n, ulong *fc);
// Convert permutation in x[0, 1, ..., n-1] into
//   the (n-1) digit (swaps) factorial representation in fc[0, 1, ..., n-2].
// We have: fc[0]<2, fc[1]<3, ..., fc[n-2]<n (rising radices)
// Work is proportional to n.

void rfact2perm_swp(const ulong *fc, ulong n, ulong *x, bool iq/*=true*/);
// Inverse of perm2rfact_swp().
// Permutation is different than that obtained via rfact2perm().
// Work is proportional to n.
// Set iq==true if permutation shall be initialized with 0,1,...,n-1.

void rfact2invperm_swp(const ulong *fc, ulong n, ulong *x, bool iq/*=true*/);
// Generate inverse permutation wrt. rfact2perm_swp().
// Work is proportional to n.
// Set iq==true if permutation shall be initialized with 0,1,...,n-1.

// ----- SRCFILE=src/comb/fact2perm-rev.cc: -----
void perm2ffact_rev(const ulong *x, ulong n, ulong *fc);
// Convert permutation in x[0,...,n-1] into
//   the (n-1) digit (reversal) factorial representation in fc[0,...,n-2].
// We have: fc[0]<n, fc[1]<n-1, ..., fc[n-2]<2 (falling radices)

void ffact2perm_rev(const ulong *fc, ulong n, ulong *x, bool iq/*=true*/);
// Convert the (n-1) digit falling factorial representation in fc[0,...,n-2].
// into permutation in x[0,...,n-1]
// Must have: fc[0]<n, fc[1]<n-1, ..., fc[n-2]<2 (falling radices)
// Inverse of perm2ffact_rev().
// Set iq==true if permutation shall be initialized with 0,1,...,n-1.

void perm2rfact_rev(const ulong *x, ulong n, ulong *fc);
// Convert permutation in x[0,...,n-1] into
//   the (n-1) digit (reversal) factorial representation in fc[0,...,n-2].
// We have: fc[0]<2, fc[1]<3, ..., fc[n-2]<n (rising radices)

void rfact2perm_rev(const ulong *fc, ulong n, ulong *x, bool iq/*=true*/);
// Convert the (n-1) digit rising factorial representation in fc[0,...,n-2].
//  into permutation in x[0,...,n-1]
// Must have: fc[0]<2, fc[1]<3, ..., fc[n-2]<n (rising radices)
// Inverse of perm2rfact_rev().
// Set iq==true if permutation shall be initialized with 0,1,...,n-1.

// ----- SRCFILE=src/comb/fact2perm-rot.cc: -----
void perm2ffact_rot(const ulong *x, ulong n, ulong *fc);
// Convert permutation in x[0,...,n-1] into
//   the (n-1) digit (rot) factorial representation in fc[0,...,n-2].
// We have: fc[0]<n, fc[1]<n-1, ..., fc[n-2]<2 (falling radices)

void ffact2perm_rot(const ulong *fc, ulong n, ulong *x, bool iq/*=true*/);
// Inverse of perm2ffact_rot().
// Convert the (n-1) digit falling factorial representation in fc[0,...,n-2].
// into permutation in x[0,...,n-1]
// Must have: fc[0]<n, fc[1]<n-1, ..., fc[n-2]<2 (falling radices)
// Set iq==true if permutation shall be initialized with 0,1,...,n-1.

void perm2rfact_rot(const ulong *x, ulong n, ulong *fc);
// Convert permutation in x[0,...,n-1] into
//   the (n-1) digit (swaps) factorial representation in fc[0,...,n-2].
// We have: fc[0]<2, fc[1]<3, ..., fc[n-2]<n (rising radices)

void rfact2perm_rot(const ulong *fc, ulong n, ulong *x, bool iq/*=true*/);
// Inverser of perm2rfact_rot().
// Convert the (n-1) digit rising factorial representation in fc[0,...,n-2].
//  into permutation in x[0,...,n-1]
// Must have: fc[0]<2, fc[1]<3, ..., fc[n-2]<n (rising radices)
// Set iq==true if permutation shall be initialized with 0,1,...,n-1.

// ----- SRCFILE=src/comb/fact2cyclic.cc: -----
void ffact2cyclic(const ulong *fc, ulong n, ulong *x, bool iq/*=true*/);
// Generate cyclic permutation in x[]
//   from the (n-2) digit factorial number in fc[0,...,n-3].
// Falling radices:  [n-1, ..., 3, 2]
// Set iq==true if permutation shall be initialized with 0,1,...,n-1.

void rfact2cyclic(const ulong *fc, ulong n, ulong *x, bool iq/*=true*/);
// Generate cyclic permutation in x[]
//   from the (n-2) digit factorial number in fc[0,...,n-3].
// Rising radices:  [2, 3, ..., n-1]
// Set iq==true if permutation shall be initialized with 0,1,...,n-1.

// ========== HEADER FILE src/comb/gray-cycle-leaders.h: ==========

class gray_cycle_leaders;
// Generate cycle leaders for Gray permutation
// where highest bit is at position ldn.

// ========== HEADER FILE src/comb/hilbert-ndim-rec.h: ==========

class hilbert_ndim_rec;
// Fred Lunnon's recursive algorithm to convert linear coordinate
// into coordinates of d-dimensional Hilbert curve.
// Note: the iterative version (class hilbert_ndim) is much faster.

// ========== HEADER FILE src/comb/hilbert-ndim.h: ==========

class hilbert_ndim;
// Fred Lunnon's iterative algorithm to convert linear coordinate
// into coordinates of d-dimensional Hilbert curve.

// ========== HEADER FILE src/comb/involution-zero-map-rgs.h: ==========

class involution_zero_map_rgs;
// Restricted growth strings (RGS):
//   each digit a[k] is either zero or a[k] < k, a[a[k]] == 0,
//   and there is at most one digit a[k] in the RGS.
// Same as: maps from {1, 2, 3, ..., n} to {0, 1, 2, 3, ..., n}
//   such that f(x) < x and f(f(x)) == 0 and there is no t!=x with f(t) = f(x).
// Lexicographic order.
// Cf. OEIS sequence A000085.

// ========== HEADER FILE src/comb/is-arrangement-rgs.h: ==========

inline bool is_arrangement_rgs(const ulong *a, ulong n);
// Return whether a[] is a valid arrangement RGS:
// every digit is at most 1 + the number of nonzero digits in the prefix.

// ========== HEADER FILE src/comb/is-ascent-rgs.h: ==========

inline bool is_ascent_rgs(const ulong *a, ulong n);
// Return whether a[] is a valid ascent sequence.
// An ascent sequence is a sequence [d(1), d(2), ..., d(n)] where d(1)=0,
//   d(k)>=0, and d(k) <= 1 + asc([d(1), d(2), ..., d(k-1)]) and asc(.)
//   counts the number of ascents of its argument.

// ========== HEADER FILE src/comb/is-catalan-path.h: ==========

inline bool is_catalan_path(const ulong *x, ulong n2);
// Return whether x[0..n] is a valid Catalan path, i.e.,
// x[0] = 0,  abs(x[j]-x[j-1]) == 1,  and x[n-1] <= 1.

// ========== HEADER FILE src/comb/is-catalan-rgs.h: ==========

inline bool is_catalan_rgs(const ulong *rgs, ulong n);
// Return whether rgs[] is a valid Catalan RGS.

inline bool is_rev_catalan_rgs(const ulong *rgs, ulong n);
// Return whether reversed rgs[] is a valid Catalan RGS.

// ========== HEADER FILE src/comb/is-catalan-step-rgs.h: ==========

inline bool is_catalan_step_rgs(const ulong *rgs, ulong n);
// Return whether rgs[] is a valid Catalan (step-)RGS.

// ========== HEADER FILE src/comb/is-cayley-perm.h: ==========

inline bool is_cayley_perm(const ulong *a, ulong n, bitarray *B);
// Return whether a[] is a valid Cayley permutation:
// all elements from 0 to the maximum value occur at least once.

// ========== HEADER FILE src/comb/is-descent-rgs.h: ==========

inline bool is_descent_rgs(const ulong *a, ulong n);
// Return whether a[] is a valid descent sequence.
// A descent sequence is a sequence [d(1), d(2), ..., d(n)] where d(1)=0,
//   d(k)>=0, and d(k) <= 1 + desc([d(1), d(2), ..., d(k-1)]) and desc(.)
//   counts the number of descents of its argument.

// ========== HEADER FILE src/comb/is-mixedradix-num.h: ==========

inline bool is_mixedradix_num(const ulong *a, ulong n, const ulong *m1);
// Return whether a[j] <= m1[j] for 0<=j<n.

// ========== HEADER FILE src/comb/is-motzkin-path.h: ==========

inline bool is_motzkin_path(const ulong *x, ulong n);
// Return whether x[0..n] is a valid Motzkin path, i.e.,
// x[0] = 0,  abs(x[j]-x[j-1]) <= 1,  and x[n-1] <= 1.

// ========== HEADER FILE src/comb/is-motzkin-step-rgs.h: ==========

inline bool is_motzkin_step_rgs(const ulong *rgs, ulong n);
// Return whether rgs[] is a valid Motzkin (step-)RGS,
// i.e., a Catalan (step-)RGS with no increments by 1.

// ========== HEADER FILE src/comb/is-nonsquashing.h: ==========

inline bool is_nonsquashing(const ulong *a, ulong m);
// Return whether a[k] >= sum(j=k+1..m-1, a[j] )

inline bool is_strongly_decreasing(const ulong *a, ulong m);
// Return whether a[k] > sum(j=k+1..m-1, a[j] )

// ========== HEADER FILE src/comb/is-paren-position-word.h: ==========

inline bool is_paren_position_word(const Type *x, ulong n);
// Return whether x[] is a valid word of parenthesis positions.

// ========== HEADER FILE src/comb/is-paren-string.h: ==========

inline bool is_paren_string(const Type *str, ulong n2);
// Return whether parenthesis string is valid.
// Works for any pair of symbols.

// ========== HEADER FILE src/comb/is-partition-rgs.h: ==========

bool is_partition_rgs(const Type *f, ulong n, bool dq=true);
// Return whether sequence is rgs for partition.
// dq determines whether the RGS is for a partition as descending list.

// ========== HEADER FILE src/comb/is-schroeder-path.h: ==========

inline bool is_schroeder_path(const ulong *x, ulong n2);
// Return whether x[0..n2] is a valid Schroeder path, i.e.,
// whether it is a valid Motzkin path and
// all horizontal stretches have even length.

// ========== HEADER FILE src/comb/is-setpart-ccf-perm.h: ==========

inline bool is_setpart_ccf_perm(ulong const *f, ulong n);
// Return whether f[], read as canonical cyle form (CCF) of a permutation
// is valid as a set partition of the form
//  (a1, a2, ..., ai), (b1, b2, ..., bj), (c1, c2, ..., ck), ...
// such that ai < bj < ck < ...
// and the last element in each group is the minimal element and
// the other elements in each group appear in increasing order.

// ========== HEADER FILE src/comb/is-setpart-rgs.h: ==========

inline bool is_setpart_rgs(const ulong *x, ulong n);
// Return whether x[0,1,...,n-1] is a valid RGS of a set partition.

// ========== HEADER FILE src/comb/is-smooth.h: ==========

inline bool is_smooth(const ulong *a, ulong n, ulong d=1);
// Return whether a[] is smooth, that is, abs(a[k]-a[k-1]) <= d

// ========== HEADER FILE src/comb/is-unimodal.h: ==========

bool is_weakly_unimodal(const Type *f, ulong n);
// Return whether sequence is weakly unimodal.

bool is_strongly_unimodal(const Type *f, ulong n);
// Return whether sequence is strongly unimodal.

// ========== HEADER FILE src/comb/is-young-tab-rgs.h: ==========

inline bool is_young_tab_rgs(const ulong *x, ulong n, ulong *st, bool cst=false);
// Return whether x[0..n-1] is a valid restricted growth strings (RGS)
// for a standard Young tableau: the k-th occurrence of a digit d must
// precede the k-th occurrence of d-1.
// If cst is set then st[] should contain the partition corresponding
// to the digit statistics.

// ========== HEADER FILE src/comb/is-zero-map-rgs.h: ==========

inline bool is_zero_map_rgs(const ulong *a, ulong n);
// Return whether a[] is a zero-map RGS:
//   each digit a[k] is either zero or the (one-based) index
//   of a zero in the prefix.

inline bool is_zero_map_rgs(const ulong *a, ulong n, ulong s, ulong *t);
// Return whether a[] is a zero-map RGS with at most s repeats:
//   each digit a[k] is either zero or the (one-based) index
//   of a zero in the prefix and there are at most s digits pointing
//   to the same zero in the prefix.

// ========== HEADER FILE src/comb/kperm-gray.h: ==========

class kperm_gray;
// Gray code for k-permutations of n elements.
// Same as: k-prefixes of permutations of n elements.
// Same as: arrangements of k out of n elements.
// CAT algorithm based on mixed radix Gray code
//   for the factorial number system (falling base).

// ========== HEADER FILE src/comb/kperm-lex.h: ==========

class kperm_lex;
// k-permutations of n elements in lexicographic order.
// Same as: k-prefixes of permutations of n elements.
// Same as: arrangements of k out of n elements.

// ========== HEADER FILE src/comb/ksubset-gray.h: ==========

class ksubset_gray;
// k-subsets (kmin<=k<=kmax) of the set {1,2,...,n}
// in minimal-change (Gray code) order.
// Algorithm following Jenkyns ("Loopless Gray Code Algorithms")
// Limitation: cannot mix calls to next() and prev().

// ========== HEADER FILE src/comb/ksubset-rec.h: ==========

class ksubset_rec;
// k-subsets where kmin<=k<=kmax in various orders.
// Recursive CAT algorithm.

// ========== HEADER FILE src/comb/ksubset-twoclose.h: ==========

class ksubset_twoclose;
// k-subsets (kmin<=k<=kmax) in a two-close order with homogeneous moves.
// Recursive algorithm.

// ========== HEADER FILE src/comb/lex-compare.h: ==========

int lex_compare(Type *a, ulong na, Type *b, ulong nb);
// Compare a[] and [] lexicographically.
// Return +1 if a[] >> b[], -1 if a[] << b[], 0 if a[]==b[].

// ========== HEADER FILE src/comb/map23-rgs.h: ==========

class map23_rgs;
// Restricted growth strings (RGS) for maps
// f: [n] -> [n] with f(x)<=x and f(f(x)) == f(f(f(x))).
// Lexicographic order.
// Cf. OEIS sequence A187761.

// ========== HEADER FILE src/comb/mixedradix-colex.h: ==========

class mixedradix_colex;
// Mixed radix counting.

// ========== HEADER FILE src/comb/mixedradix-endo-gray.h: ==========

class mixedradix_endo_gray;
// Gray code for mixed radix numbers in endo order.
// (endo := "Even Numbers Down, Odd (numbers up)")
// CAT algorithm.

// ========== HEADER FILE src/comb/mixedradix-endo.h: ==========

class mixedradix_endo;
// Mixed radix counting in endo order.
// (endo := "Even Numbers Down, Odd (numbers up)")

// ========== HEADER FILE src/comb/mixedradix-gray.h: ==========

class mixedradix_gray;
// Gray code for mixed radix numbers.
// CAT algorithm.

// ========== HEADER FILE src/comb/mixedradix-gray2.h: ==========

class mixedradix_gray2;
// Gray code for mixed radix numbers.
// Loopless algorithm. Implementation following Knuth.

// ========== HEADER FILE src/comb/mixedradix-gslex-alt.h: ==========

class mixedradix_gslex_alt;
// Mixed radix numbers in alternative gslex (generalized subset-lex) order.

// ========== HEADER FILE src/comb/mixedradix-gslex-alt2.h: ==========

class mixedradix_gslex_alt2;
// Mixed radix numbers in alternative gslex (generalized subset-lex) order.

// ========== HEADER FILE src/comb/mixedradix-gslex.h: ==========

class mixedradix_gslex;
// Mixed radix numbers in gslex (generalized, subset-lexicographic) order.

// ========== HEADER FILE src/comb/mixedradix-gslex2.h: ==========

class mixedradix_gslex2;
// Mixed radix numbers in gslex (generalized, subset-lexicographic) order.
// Loopless generation.

// ========== HEADER FILE src/comb/mixedradix-lex.h: ==========

class mixedradix_lex;
// Mixed radix counting.

// ========== HEADER FILE src/comb/mixedradix-modular-gray.h: ==========

class mixedradix_modular_gray;
// Modular Gray code for mixed radix numbers.
// Implementation following Knuth (loopless algorithm).

// ========== HEADER FILE src/comb/mixedradix-modular-gray2.h: ==========

class mixedradix_modular_gray2;
// Modular Gray code for mixed radix numbers.
// Constant amortized time (CAT) algorithm.

// ========== HEADER FILE src/comb/mixedradix-naf-gray.h: ==========

class mixedradix_naf_gray;
// Gray code for mixed radix non-adjacent forms (NAF).

// ========== HEADER FILE src/comb/mixedradix-naf-subset-lex.h: ==========

class mixedradix_naf_subset_lex;
// Mixed radix non-adjacent forms (NAF), subset-lex order.
// Loopless generation.

// ========== HEADER FILE src/comb/mixedradix-naf.h: ==========

class mixedradix_naf;
// Mixed radix non-adjacent forms (NAF), counting order.

// ========== HEADER FILE src/comb/mixedradix-restrpref.h: ==========

class mixedradix_restrpref;
// Mixed radix counting with restricted prefixes.

// ========== HEADER FILE src/comb/mixedradix-rfact.h: ==========

class mixedradix_rfact;
// Counting in rising factorial base,
// special case of mixed radix counting.

// ========== HEADER FILE src/comb/mixedradix-sl-gray.h: ==========

class mixedradix_sl_gray;
// Mixed radix numbers in a minimal-change order
// related so subset-lex order ("SL-Gray" order).

// ========== HEADER FILE src/comb/mixedradix-sod-lex.h: ==========

class mixedradix_sod_lex;
// Mixed radix numbers with prescribed sum of digits s, in lexicographic order.
// Same as: s-combinations of a multiset.
// Same as: compositions of s with prescribed maximum at each place.

// ========== HEADER FILE src/comb/mixedradix-subset-lex.h: ==========

class mixedradix_subset_lex;
// Mixed radix numbers in subset-lexicographic order.
// Successive numbers differ in at most three digits.

// ========== HEADER FILE src/comb/mixedradix-subset-lexrev.h: ==========

class mixedradix_subset_lexrev;
// Mixed radix numbers in reversed subset-lexicographic order.
// Words are reversed with respect to subset-lexicographic order.
// Successive numbers differ in at most three digits.

// ========== HEADER FILE src/comb/mixedradix.h: ==========

// ----- SRCFILE=src/comb/mixedradix-init.cc: -----
void mixedradix_init(ulong n, ulong mm, const ulong *m, ulong *m1); // aux
// Auxiliary function used to initialize vector of nines in mixed radix classes.

// ----- SRCFILE=src/comb/mixedradix2num.cc: -----
ulong mixedradix2num(const ulong *x, const ulong *m1, ulong n);
// Convert n-digit mixed radix number in x[] to (unsigned) integer.
// Radices minus one (that is, "nines") must be given in m1[].

void num2mixedradix(ulong N, ulong *x, const ulong *m1, ulong n);
// Convert N to n-digit mixed radix number in x[].
// Radices minus one (that is, "nines") must be given in m1[].

ulong product(const ulong *x, ulong n);

ulong product_p1(const ulong *m1, ulong n);

// ========== HEADER FILE src/comb/monotonic-gray.h: ==========

// ----- SRCFILE=src/comb/monotonic-gray.cc: -----
void monotonic_gray_delta(unsigned char *d, ulong ldn);
// Write the delta sequence for the Savage-Winkler monotonic Gray path
// into the array d[].
// Algorithm as given in Knuth, TAOCP vol.4
// (exercise 73, fascicle 2A, 7.2.1.1: "Generating all n-tuples").

void monotonic_gray(ulong *g, ulong ldn);
// Write the monotonic (Savage-Winkler) Gray path
// into g[0..N-1] (N=2**ldn).

// ========== HEADER FILE src/comb/motzkin-nonflat-rgs-lex.h: ==========

class motzkin_nonflat_rgs_lex;
// Motzkin (nonflat) restricted growth strings (RGS), lexicographic order.
// Same as: Catalan RGS without flat steps.
// Cf. OEIS sequences A086246 and A001006.
// The number of length-n RGS is
//  1, 1, 1, 2, 4, 9, 21, 51, 127, 323, 835, 2188, 5798, 15511, 41835, ...
// G.f. is (1+x-sqrt(1-2*x-3*x^2))/(2*x)

// ========== HEADER FILE src/comb/motzkin-path-lex.h: ==========

class motzkin_path_lex;
// Motzkin paths in lexicographic order, CAT algorithm.
// Steps are +1, 0, -1 (up, horizontal, down),
// the first and last elements are 0,
// and all elements are non-negative.
// Cf. OEIS sequence A001006.

// ========== HEADER FILE src/comb/motzkin-rgs-lex.h: ==========

class motzkin_rgs_lex;
// Motzkin restricted growth strings (RGS), lexicographic order.
// Cf. OEIS sequence A001006.

// ========== HEADER FILE src/comb/motzkin-step-rgs-lex.h: ==========

class motzkin_step_rgs_lex;
// Motzkin step RGS (restricted growth strings), lexicographic order.
// RGS are a[] such that a[k] >= a[k-1] (non-decreasing), a[k]<=k, and
// a[k] - a[k-1] != 1 (no increments by 1).
// Same as: rising factorial numbers where the digits are sorted
// where increments by 1 are disallowed.
// Cf. OEIS sequence A001006.

// ========== HEADER FILE src/comb/mpartition.h: ==========

class mpartition;
// Partitions into m parts.
// Representation as list of parts in non-decreasing order.
// Same as: compositions into m non-decreasing parts.
// Cf. OEIS sequence A008284.

// ========== HEADER FILE src/comb/mset-perm-gray.h: ==========

class mset_perm_gray;
// Multiset permutations in minimal-change order (Fred Lunnon's Gray code).
//.
// Adaptation of Java code by Fred Lunnon.
// Original documentation at end of file.

// ========== HEADER FILE src/comb/mset-perm-lex-rec.h: ==========

class mset_perm_lex_rec;
// Multiset permutations in lexicographic order, recursive algorithm.

// ========== HEADER FILE src/comb/mset-perm-lex.h: ==========

class mset_perm_lex;
// Multiset permutations in lexicographic order, iterative algorithm.

// ========== HEADER FILE src/comb/mset-perm-pref.h: ==========

class mset_perm_pref;
// Multiset permutations via prefix shifts ("cool-lex" order).
//.
// See
// Aaron Williams:
//   "Loopless generation of multiset permutations by prefix shifts"
//   Symposium on Discrete Algorithms, New York, 2009.

// ========== HEADER FILE src/comb/necklace.h: ==========

class necklace;
// Generate necklaces, iterative algorithm.

// ========== HEADER FILE src/comb/num-compositions.h: ==========

class num_compositions;
// Table of number of compositions: nc[n-1][k-1] = binomial(n+k-1, n).
// Used by class composition_rank.

// ========== HEADER FILE src/comb/num-necklaces.h: ==========

// num_necklaces_tab[n] == number of binary n-bit necklaces
// num_lyndon_tab[n] == number of binary n-bit Lyndon words
// ========== HEADER FILE src/comb/num2perm.h: ==========

// ----- SRCFILE=src/comb/num2perm.cc: -----
void num2perm_rfact(ulong x, ulong *f, ulong n);
// Create permutation number x according to (rising factorial) unrank.

ulong perm2num_rfact(const ulong *f, ulong n);
// Inverse of num2perm_rfact()

void num2perm_ffact(ulong x, ulong *f, ulong n);
// Create permutation number x according to (falling factorial) unrank.

ulong perm2num_ffact(const ulong *f, ulong n);
// Inverse of num2perm_ffact()

void num2perm_swp(ulong x, ulong *f, ulong n);
// Create permutation number x according to (rising factorial) unrank by swaps.

ulong perm2num_swp(const ulong *f, ulong n);
// Inverse of num2perm_swp()

ulong permlex2num(const ulong *f, ulong n);
// The following function computes the rank of the given permutation
// corresponding to lexicographic order:
//   1, 2, ..., n-1, n   is index 0
//   1, 2, ..., n, n-1   is index 1
//   n, n-1, ..., 2, 1   is index n! -1
// The actual values of the elements are immaterial, only the relative
// ordering of the values is used.
// f[] is the array of elements of length n.
// Note 1: complexity is n*n
// Note 2:  n!-1 must fit into a ulong ==> only good for _tiny_ n

// ========== HEADER FILE src/comb/paren-gray.h: ==========

class paren_gray;
// Parentheses strings in a homogeneous minimal-change order.

// ========== HEADER FILE src/comb/paren-lex.h: ==========

class paren_lex;
// Parentheses strings, lexicographic order.
// Representation as list of positions of opening parenthesis.

// ========== HEADER FILE src/comb/paren-pref.h: ==========

class paren_pref;
// All strings of t ones and s zeros (t>=s>0) where the number of
// zeros in any prefix does not exceed the number of ones.
// For t==s: well-formed parentheses strings by prefix shifts.
//.
// Loopless algorithm as given in
//   Frank Ruskey, Aaron Williams:
//   "Generating Balanced Parentheses and Binary Trees by Prefix Shifts"
//   CATS 2008, Computing: The Australasian Theory Symposium,
//   Wollongong, Australia, (2008)

// ========== HEADER FILE src/comb/paren-string-to-rgs.h: ==========

// ----- SRCFILE=src/comb/paren-string-to-rgs.cc: -----
void rgs_to_paren_string(const ulong *rgs, ulong n, char *str, bool rq=false);
// Convert restricted growth string (Catalan-RGS) to paren-string.
// If rq is set then the reversed paren string is computed.

bool paren_string_to_rgs(const char *str, ulong *rgs);
// Convert paren-string to RGS,
// return whether parenthesis string is valid.
// rgs[j] = number of unclosed open parenthesis when
//  the j-th opening is found (j>=0).
// If rq is set then the RGS for the reversed paren string is computed.

void rgs_to_paren_bit_string(const ulong *rgs, ulong n, char *str, bool rq=false);
// Convert restricted growth string (Catalan-RGS) to paren-bit-string.
// If rq is set then the reversed paren string is computed.

bool paren_bit_string_to_rgs(const char *str, ulong *rgs);
// Convert paren-bit-string to RGS.
// Return whether parenthesis string is valid.
// If rq is set then the RGS for the reversed paren string is computed.

// ========== HEADER FILE src/comb/paren.h: ==========

class paren;
// Parentheses strings, co-lexicographic order.
// Representation as list of positions of opening parenthesis.

// ========== HEADER FILE src/comb/partition-2fall-desc.h: ==========

class partition_2fall_desc;
// Partitions of n is a partition a[1] + a[2] + ... + a[m] = n
//   such that 2*a[k] <= a[k-1].
// Representation as non-increasing list of parts.
// Lexicographic order.
// Cf. OEIS sequence A000929.

// ========== HEADER FILE src/comb/partition-asc-sorts2-pp.h: ==========

class partition_asc_sorts2_pp;
// Partitions into parts of s[k] sorts for part (size) k.
// Representation as non-decreasing lists.
// Lexicographic order: major order by parts, minor by sorts.
// Cf. OEIS sequence A000219 (planar partitions).
// Cf. OEIS sequences (partitions of n into parts of s kinds):
// A000041 (s=1), A000712 (s=2), A000716 (s=3), A023003 (s=4),
// A023004 (s=5), A023005 (s=6), A023006 (s=7), and A023007 (s=8).

// ========== HEADER FILE src/comb/partition-asc-sorts2.h: ==========

class partition_asc_sorts2;
// Partitions into parts of s sorts, as non-decreasing lists.
// Lexicographic order: major order by parts, minor by sorts.
// Cf. OEIS sequences (partitions of n into parts of s kinds):
// A000041 (s=1), A000712 (s=2), A000716 (s=3), A023003 (s=4),
// A023004 (s=5), A023005 (s=6), A023006 (s=7), and A023007 (s=8).

// ========== HEADER FILE src/comb/partition-asc-subset-lex.h: ==========

class partition_asc_subset_lex;
// Partitions of n into positive parts as ascending list of parts.
// Subset-lexicographic order:
// The length of consecutive partitions changes by at most one.
// Only two adjacent positions in a partition at the end change,
//   with the single exception that one only position changes with
//   the partition into one part.
// Loopless algorithm.

// ========== HEADER FILE src/comb/partition-asc.h: ==========

class partition_asc;
// Integer partitions.
// Representation as list of parts in non-decreasing order.
// Same as: compositions into non-decreasing parts.
// Lexicographic order.
// Cf. OEIS sequence A000041.

// ========== HEADER FILE src/comb/partition-binary-asc.h: ==========

class partition_binary_asc;
// Binary partitions as non-decreasing list of parts.
// Same as: compositions into non-decreasing parts that are powers of 2.
// Lexicographic order.
// Cf. OEIS sequences A018819 and A000123.

// ========== HEADER FILE src/comb/partition-binary-desc.h: ==========

class partition_binary_desc;
// Binary partitions as non-increasing list of parts.
// Same as: compositions into non-increasing parts that are powers of 2.
// Lexicographic order.
// Cf. OEIS sequences A018819 and A000123.

// ========== HEADER FILE src/comb/partition-conj.h: ==========

// ----- SRCFILE=src/comb/partition-conj.cc: -----
ulong partition_asc_conj(const ulong *a, ulong m, ulong *b);
// Write conjugate partition of a[]
// (a non-decreasing list with m parts) into b[].
// Return number of parts in b[].
// The first element in both arrays is at index 0.

bool partition_asc_is_conj(const ulong *a, ulong ma, const ulong *b=0, ulong mb=0);
// Return if a[] (ma parts) and b[] (mb parts) are mutually conjugate partitions.
// Both a[] and b[] must be non-decreasing lists with
// the first element at index 0.

bool partition_asc_is_self_conj(const ulong *a, ulong m);
// Return whether the partition in a[] (m parts) is self-conjugate.

ulong partition_desc_conj(const ulong *a, ulong m, ulong *b);
// Write conjugate partition of a[]
// (a non-increasing list with m parts) into b[].
// Return number of parts in b[].
// The first element in both arrays is at index 0.

bool partition_desc_is_conj(const ulong *a, ulong ma, const ulong *b=0, ulong mb=0);
// Return if a[] (ma parts) and b[] (mb parts) are mutually conjugate partitions.
// Both a[] and b[] must be non-increasing lists with
// the first element at index 0.

bool partition_desc_is_self_conj(const ulong *a, ulong m);
// Return whether the partition in a[] (m parts) is self-conjugate.

// ========== HEADER FILE src/comb/partition-desc.h: ==========

class partition_desc;
// Integer partitions.
// Representation as list of parts in non-increasing order.
// Same as: compositions into non-increasing parts.
// Lexicographic order.
// Cf. OEIS sequence A000041.

// ========== HEADER FILE src/comb/partition-dist-asc-subset-lex.h: ==========

class partition_dist_asc_subset_lex;
// Integer partitions into distinct parts.
// Representation as list of parts in increasing order.
// Subset-lexicographic order:
// The length of consecutive partitions changes by at most one.
// Only the last two positions in a partition at the end change.
// Same as: compositions into distinct increasing parts.
// Loopless algorithm.
// Cf. OEIS sequence A000009.

// ========== HEADER FILE src/comb/partition-dist-asc.h: ==========

class partition_dist_asc;
// Integer partitions into distinct parts.
// Representation as list of parts in increasing order.
// Same as: compositions into distinct increasing parts.
// Lexicographic order.
// Cf. OEIS sequence A000009.

// ========== HEADER FILE src/comb/partition-dist-d-asc.h: ==========

class partition_dist_d_asc;
// Integer partitions such that parts differ by at least d.
// Representation as list of parts in increasing order.
// Lexicographic order.
// Cf. OEIS sequences
//  A000041 (all partitions; d=0), A000009 (distinct parts; d=1),
//  A003114 (d=2), A025157 (d=3), A025158 (d=4), A025159 (d=5),
//  A025160 (d=6), A025161 (d=7), and A025162 (d=8).

// ========== HEADER FILE src/comb/partition-dist-desc.h: ==========

class partition_dist_desc;
// Partitions into distinct parts as decreasing list of parts.
// Same as: compositions into distinct decreasing parts.
// Lexicographic order.
// Cf. OEIS sequence A000009.

// ========== HEADER FILE src/comb/partition-gen.h: ==========

class partition_gen;
// Integer partitions into parts pv[0], pv[1], ..., pv[n-1].
// pv[] defaults to [1, 2, 3, ...] (all positive parts).

// ========== HEADER FILE src/comb/partition-hook-prod.h: ==========

Type partition_desc_hook_prod(const ulong *a, ulong m, ulong *b);
// Return product of all hook lengths in the partition a[].
// The partition must be a non-increasing list of length m.

Type partition_asc_hook_prod(const ulong *a, ulong m, ulong *b);
// Return product of all hook lengths in the partition a[].
// The partition must be a non-decreasing list of length m.

// ========== HEADER FILE src/comb/partition-nonsquashing-desc.h: ==========

class partition_nonsquashing_desc;
// Non-squashing partitions as non-increasing list of parts.
// A non-squashing partition of n is a partition a[1] + a[2] + ... + a[m] = n
//   such that a[k] >= sum(j=k+1..m, a[j] ).
// Lexicographic order.
// See:
//  N. J. A. Sloane, James A. Sellers: "On Non-Squashing Partitions",
//    arXiv:math/0312418 [math.CO], (22-December-2003).
// Cf. OEIS sequences A018819 and A000123.

// ========== HEADER FILE src/comb/partition-odd-asc-subset-lex.h: ==========

class partition_odd_asc_subset_lex;
// Integer partitions into odd parts.
// Representation as list of parts in non-decreasing order.
// Subset-lexicographic order:
// The length of consecutive partitions changes by at most two.
// Only two or three adjacent positions in a partition at the end change,
//   with the single exception that one only position changes with
//   the partition into one part when n is odd.
// Same as: compositions into odd non-decreasing odd parts.
// Loopless algorithm.
// Cf. OEIS sequence A000009.

// ========== HEADER FILE src/comb/partition-odd-asc.h: ==========

class partition_odd_asc;
// Integer partitions into odd parts.
// Representation as list of parts in non-decreasing order.
// Same as: compositions into non-decreasing odd parts.
// Lexicographic order.
// Cf. OEIS sequence A000009.

// ========== HEADER FILE src/comb/partition-odd-desc.h: ==========

class partition_odd_desc;
// Integer partitions into odd parts.
// Representation as list of parts in non-increasing order.
// Same as: compositions into non-increasing odd parts.
// Lexicographic order.
// Cf. OEIS sequence A000009.

// ========== HEADER FILE src/comb/partition-odd-nonsquashing-desc.h: ==========

class partition_odd_nonsquashing_desc;
// Non-squashing partitions into odd parts as non-increasing list of parts.
// A non-squashing partition of n is a partition a[1] + a[2] + ... + a[m] = n
//   such that a[k] >= sum(j=k+1..m, a[j] ).
// Lexicographic order.
// Cf. OEIS sequence A187821.

// ========== HEADER FILE src/comb/partition-print-aa.h: ==========

// ----- SRCFILE=src/comb/partition-print-aa.cc: -----
void print_partition_asc_aa(const ulong *a, ulong m);

void print_partition_asc_conj_aa(const ulong *a, ulong m);

void print_partition_desc_aa(const ulong *a, ulong m);

void print_partition_desc_conj_aa(const ulong *a, ulong m);

// ========== HEADER FILE src/comb/partition-rgs-lex.h: ==========

class partition_rgs_lex;
// Restricted growth strings (RGS) for partitions as descending lists,
// lexicographic order.
// Same as: least Young tableau (as RGS) with fixed shape (partition).
// Cf. OEIS sequence A000041.

// ========== HEADER FILE src/comb/partition-s-desc.h: ==========

class partition_s_desc;
// S-partitions: integer partitions into parts 2^n-1.
// Representation as list of parts in non-increasing order.
// Lexicographic order.
// Cf. OEIS sequence A000929.

// ========== HEADER FILE src/comb/partition-strongly-decr-desc.h: ==========

class partition_strongly_decr_desc;
// Strongly decreasing partitions as list of parts.
// A strongly decreasing partition of n is a partition
//   a[1] + a[2] + ... + a[m] = n  such that a[k] > sum(j=k+1..m, a[j] ).
// Lexicographic order.
// Cf. OEIS sequences A040039 and A033485.

// ========== HEADER FILE src/comb/partition.h: ==========

class partition;
// Integer partitions.
// Order is such that the conjugates are in Abramowitz/Stegun order.
// Representation as array of multiplicities of parts.
// Cf. OEIS sequence A000041.

// ========== HEADER FILE src/comb/perm-colex.h: ==========

class perm_colex;
// Permutations in co-lexicographic (colex) order.
// Generation via rising factorial numbers.

// ========== HEADER FILE src/comb/perm-derange.h: ==========

class perm_derange;
// Permutations in derangement order.
// There is no derangement order for n=3 elements.

// ========== HEADER FILE src/comb/perm-gray-ffact.h: ==========

class perm_gray_ffact;
// Gray code for permutations (Trotter/Johnson ordering).
// CAT algorithm based on mixed radix Gray code
//   for the factorial number system (falling base).

// ========== HEADER FILE src/comb/perm-gray-ffact2.h: ==========

class perm_gray_ffact2;
// Gray code for permutations (Trotter/Johnson ordering).
// Loopless algorithm based on mixed radix Gray code
//   for the factorial number system.

// ========== HEADER FILE src/comb/perm-gray-lipski.h: ==========

class perm_gray_lipski;
// Four Gray codes for permutations.
// Algorithms following
//   W. Lipski, Jr.: More on permutation generation methods,
//   Computing, vol.23, no.4, pp.357-365, December-1979.

// ========== HEADER FILE src/comb/perm-gray-rfact.h: ==========

class perm_gray_rfact;
// Gray code for permutations.
// CAT algorithm based on mixed radix Gray code for rising factorial base.

// ========== HEADER FILE src/comb/perm-gray-rot1.h: ==========

class perm_gray_rot1;
// Gray code for permutations.
// Let e be the largest even number not greater than n:
// the e first elements in the last permutation are a cyclic shift
// to the left by one position of the first e elements.
// For example, e==6 with n==6 and n==7:
//             first                last
//  n=6:   [ 0 1 2 3 4 5 ]    [ 1 2 3 4 5 0 ]
//  n=7:   [ 0 1 2 3 4 5 6 ]  [ 1 2 3 4 5 0 6 ]
//
// CAT algorithm based on mixed radix Gray code for rising factorial base
// with last two nines swapped for odd n.

// ========== HEADER FILE src/comb/perm-gray-wells.h: ==========

class perm_gray_wells;
// Three Gray codes for permutations (Wells' order and two variants of it).
// Algorithms following
//   W. Lipski, Jr.: More on permutation generation methods,
//   Computing, vol.23, no.4, pp.357-365, December-1979.

// ========== HEADER FILE src/comb/perm-heap.h: ==========

class perm_heap;
// Gray code for permutations.
// Algorithm following
//   B. R. Heap: "Permutations by interchanges" (1963)

// ========== HEADER FILE src/comb/perm-heap2-swaps.h: ==========

class perm_heap2_swaps;
// Swaps for Gray code for permutations.
// Algorithm following
//   B. R. Heap: "Permutations by interchanges" (1963)
// Optimized implementation, very fast.

// ========== HEADER FILE src/comb/perm-heap2.h: ==========

class perm_heap2;
// Gray code for permutations.
// Algorithm following
//   B. R. Heap: "Permutations by interchanges" (1963)
// Optimized implementation, very fast.

// ========== HEADER FILE src/comb/perm-involution.h: ==========

class perm_involution;
// Involutions (self-inverse permutations).
// Cf. OEIS sequence A000085.

// ========== HEADER FILE src/comb/perm-ives.h: ==========

class perm_ives;
// Permutation in an order given by Ives.
// The permutations are the order c of
//   F. M. Ives: {Permutation enumeration: four new permutation algorithms},
//   Communications of the ACM, vol.19, no.2, pp.68-72,  February-1976.
// The inverse permutations are Ives' order a.

// ========== HEADER FILE src/comb/perm-lex-inv.h: ==========

class perm_lex_inv;
// Permutations in lexicographic order, with inverse permutations.
// Generation via rising factorial numbers.

// ========== HEADER FILE src/comb/perm-lex.h: ==========

class perm_lex;
// Permutations in lexicographic order

// ========== HEADER FILE src/comb/perm-lex2.h: ==========

class perm_lex2;
// Permutations in lexicographic order.
// Generation via rising factorial numbers.

// ========== HEADER FILE src/comb/perm-mv0.h: ==========

class perm_mv0;
// Inverse permutations corresponding to falling factorial numbers.
// CAT algorithm based on mixed radix Gray code
//   for the factorial number system (falling base).

// ========== HEADER FILE src/comb/perm-pref.h: ==========

class perm_pref;
// Permutations via prefix shifts ("cool-lex" order).
// Specialization of class mset_perm_pref.

// ========== HEADER FILE src/comb/perm-rec.h: ==========

class perm_rec;
// Permutations (and cyclic permutations).
// Recursive algorithm

// ========== HEADER FILE src/comb/perm-restrpref.h: ==========

class perm_restrpref;
// Generate all permutations with restricted prefixes,
// in lexicographic order.
// Algorithm as given by Knuth.

// ========== HEADER FILE src/comb/perm-rev.h: ==========

class perm_rev;
// Permutations by reversing prefixes, CAT algorithm

// ========== HEADER FILE src/comb/perm-rev2.h: ==========

class perm_rev2;
// Permutations by reversing prefixes, CAT algorithm.
// Optimized version.

// ========== HEADER FILE src/comb/perm-rot.h: ==========

class perm_rot;
// All permutations, by rotations (cyclic shifts).
// Algorithm of G. G. Langdon Jr., as given by Knuth.
// Array x[] unused here (commented out)!

// ========== HEADER FILE src/comb/perm-st-gray.h: ==========

class perm_st_gray;
// Gray code for single track permutations:
// one transposition per update with odd n,
// one extra transposition once in (n-1)! updates with even n (optimal).

// ========== HEADER FILE src/comb/perm-st-pref.h: ==========

class perm_st_pref;
// Permutations in single track order:
// all columns are cyclic shifts of the first column.
// swaps of inverse permutation are done in prefix.

// ========== HEADER FILE src/comb/perm-st.h: ==========

class perm_st;
// Permutations in single track order:
// all columns are cyclic shifts of the first column.

// ========== HEADER FILE src/comb/perm-star-swaps.h: ==========

class perm_star_swaps;
// Permutations in star-transposition order (a Gray code).
// Compute swaps only.
// Algorithm of Gideon Ehrlich, as given by Knuth

// ========== HEADER FILE src/comb/perm-star.h: ==========

class perm_star;
// Permutations in star-transposition order (a Gray code).
// Algorithm of Gideon Ehrlich, as given by Knuth

// ========== HEADER FILE src/comb/perm-trotter-lg.h: ==========

class perm_trotter_lg;
// Gray code for permutations
// Trotter/Johnson algorithm.
// Largest element moves most often.

// ========== HEADER FILE src/comb/perm-trotter.h: ==========

class perm_trotter;
// Gray code for permutations, Trotter/Johnson algorithm.
// Smalles element moves most often.

// ========== HEADER FILE src/comb/print-arrangement-rgs-perm.h: ==========

// ----- SRCFILE=src/comb/print-arrangement-rgs-perm.cc: -----
void print_arrangement_rgs_perm(const char *bla,
                           const ulong *a, ulong n,
                           ulong *rfc,
                           ulong *p,
                           bool zb/*=false*/);
// The positions of nonzero digits determine the subset, and
//   their values (decreased by 1) are the (left) inversion table
//   (a rising factorial number) for the permutation.

// ========== HEADER FILE src/comb/print-composition-by-sorts.h: ==========

// ----- SRCFILE=src/comb/print-composition-by-sorts.cc: -----
void print_composition_by_sorts(const ulong *va, const ulong *vs, ulong m);

// ========== HEADER FILE src/comb/print-zero-map-rgs.h: ==========

// ----- SRCFILE=src/comb/print-zero-map-rgs.cc: -----
void print_zero_map_rgs_as_zero_dist_rgs(const char *bla,
                                    const ulong *a, ulong n,
                                    bool dfz/*=true*/);
// Print corresponding zero-dist RGS,
// all zeros are replaced by fixed points.

void print_zero_map_rgs_as_fp_rgs(const char *bla,
                             const ulong *a, ulong n,
                             bool dfz/*=true*/,
                             bool zb/*=true*/);
// Print corresponding fixed-point RGS,
// all zeros are replaced by fixed points.
// zb determines whether printed elements are zero based.

void print_zero_map_rgs_as_fp_dist_rgs(const char *bla,
                                  const ulong *a, ulong n,
                                  bool dfz/*=true*/,
                                  bool zb/*=true*/);
// Print corresponding fixed-point-dist RGS,
// all zeros are replaced by fixed points.

void print_zero_map_rgs_setpart(const char *bla,
                           const ulong *a, ulong n,
                           bool zb/*=false*/,
                           bool iq/*=false*/);
// Print set partition corresponding to RGS.
// zb determines whether the output is zero-based.
// Set iq to use '()', not '{}', (use to print involutions).

// ========== HEADER FILE src/comb/reverse-paren-string.h: ==========

inline void reverse_paren_string(const Type *str, ulong n2, Type *st2);
// Reverse string and swap '(' and ')'
// Works for any pair of symbols.
// Works in-place if str==0.

inline void reverse_paren_string(Type *str, ulong n2);
// Reverse string and swap '(' and ')'
// Works for any pair of symbols.
// Works in-place if str==0.

// ========== HEADER FILE src/comb/rgs-fincr.h: ==========

class rgs_fincr;
// Restricted growth strings (RGS) s[0,...,n-1] so that
//  s[k] <= F[k]+i  where
//  F[0]=0, F[k+1]=( s[k+1]-s[k]==i ?  F[k]+i : F[k] )
// Lexicographic order.
// Cf. OEIS sequences
//  A000110 (i=1),  A004211 (i=2),  A004212 (i=3),
//  A004213 (i=4),  A005011 (i=5),  A005012 (i=6).

// ========== HEADER FILE src/comb/rgs-kincr.h: ==========

class rgs_kincr;
// Restricted growth strings (RGS) s[0,...,n-1] so that s[k] <= s[k-1]+k
// Lexicographic order.
// Cf. OEIS sequence A107877.

// ========== HEADER FILE src/comb/rgs-maxincr.h: ==========

class rgs_maxincr;
// Restricted growth strings (RGS) s[0,...,n-1] so that
//  s[k] <= max_{j<k}(s[j]+i)
// Lexicographic order

// ========== HEADER FILE src/comb/ruler-func-s.h: ==========

class ruler_func_s : public composition_nz_sorts;
// Ruler function (one-based), s-valuations of s*n:
// s=2:  1 2 1 3 1 2 1 4 1 2 1 3 1 2 1 5 1 2 1 3 1 2 1 ...
//   cf. OEIS sequence A001511 and A007814 (zero based)
// s=3:  1 1 2 1 1 2 1 1 3 1 1 2 1 1 2 1 1 3 1 1 2 1 1 ...
//   cf. OEIS sequences A051064 and A007949 (zero based)
// Loopless algorithm.

// ========== HEADER FILE src/comb/ruler-func.h: ==========

class ruler_func;
// Ruler function (zero-based), 2-valuations of n:
//   0 1 0 2 0 1 0 3 0 1 0 2 0 1 0 4 0 1 0 2 0 1 ...
// Loopless algorithm (specialization of Knuth's method
//   for mixed radix Gray code).
// Cf. OEIS sequence A007814.

// ========== HEADER FILE src/comb/ruler-func1.h: ==========

class ruler_func1 : public composition_nz;
// Ruler function (one-based), 2-valuations of 2*n:
//   1 2 1 3 1 2 1 4 1 2 1 3 1 2 1 5 1 2 1 3 1 2 1 ...
// Loopless algorithm.
// Cf. OEIS sequence A001511.

// ========== HEADER FILE src/comb/schroeder-path-lex.h: ==========

class schroeder_path_lex;
// Schroeder paths in lexicographic order, CAT algorithm.
// Steps are +1, 0, -1 (up, horizontal, down),
// the first and last elements are 0, all elements are non-negative, and
// horizontal steps appear consecutively an even number of times.
// Cf. OEIS sequence A006318: large Schroeder numbers.

// ========== HEADER FILE src/comb/setpart-ccf-rgs-lex.h: ==========

class setpart_ccf_rgs_lex;
// Restricted growth strings (RGS) for set partitions:
//   each digit a[k] < k and a[k-1] != 0 implies a[k] <= a[k-1].
// The RGS correspond to permutations in canonical cycle form (CCF)
//   that are valid set partitions.
// Same as: maps from {1, 2, 3, ..., n} to {0, 1, 2, 3, ..., n}
//   such that f(x) < x and f(x-1) != 0 implies f(x) <= f(x-1).
// Lexicographic order.

// ========== HEADER FILE src/comb/setpart-ck-rgs.h: ==========

class setpart_ck_rgs;
// Restricted growth strings (RGS) for set partitions:
// each digit is either a fixed point or a digit from the prefix.
// Lexicographic order.
// See
//   C. Cooper, R. E. Kennedy:
//   "Patterns, Automata, and Stirling Numbers of the Second Kind",
//    Mathematics and Computer Education Journal, vol.26, (1992),
// where these RGS are called "n-pattern sequences", a term
// we will not use because "pattern sequences" better describe
// the "usual" RGS for set partitions.  Instead we call them
// Cooper-Kennedy RGS, abbreviated here as CK-RGS.

// ========== HEADER FILE src/comb/setpart-p-rgs-lex.h: ==========

class setpart_p_rgs_lex;
// Set partitions of the n-set into p parts (where 2<=p<=n)
// as restricted growth strings (RGS).
// Lexicographic order.
// Cf. OEIS sequence A008277.

// ========== HEADER FILE src/comb/setpart-rgs-gray.h: ==========

class setpart_rgs_gray;
// Set partitions of the n-set as restricted growth strings (RGS).
// Minimal-change order for set partitions,
//  note that the RGS can change in more than one position.

// ========== HEADER FILE src/comb/setpart-rgs-lex.h: ==========

class setpart_rgs_lex;
// Set partitions of the n-set as restricted growth strings (RGS).
// Lexicographic order.

// ========== HEADER FILE src/comb/setpart-rgs-subset-lex.h: ==========

class setpart_rgs_subset_lex;
// Restricted growth strings (RGS) for set partitions, subset-lex order.

// ========== HEADER FILE src/comb/setpart-s-zero-map-rgs.h: ==========

class setpart_s_zero_map_rgs;
// Set partitions into sets of size <= s+1 represented as
// restricted growth strings (RGS):
//   each digit a[k] is either zero or the (one-based) index
//   of a zero in the prefix and there are at most s digits pointing
//   to the same zero in the prefix.
// Same as: maps from {1, 2, 3, ..., n} to {0, 1, 2, 3, ..., n}
//   such that f(x) < x and f(f(x)) == 0 and there are at most s
//   values t such that f(t) = f(x).
// Lexicographic order.
// Cf. OEIS sequences A000085 (for s=1), A001680 (s=2), A001681 (s=3),
//   A110038 (s=4), and A000110 (for s>=n-1).

// ========== HEADER FILE src/comb/setpart-zero-map-rgs.h: ==========

class setpart_zero_map_rgs;
// Restricted growth strings (RGS) for set partitions:
//   each digit a[k] is either zero or a[k] < k and a[a[k]] == 0.
// Same as: maps from {1, 2, 3, ..., n} to {0, 1, 2, 3, ..., n}
//   such that f(x) < x and f(f(x)) == 0.
// Lexicographic order.

// ========== HEADER FILE src/comb/setpart.h: ==========

class setpart;
// Set partitions of the set {1,2,3,...,n}
// By default in minimal-change order.

// ========== HEADER FILE src/comb/smooth-rfact-rgs.h: ==========

class smooth_rfact_rgs;
// Restricted growth strings (RGS) [d(0), d(1), d(2), ..., d(n-1)] where
//  0 <= d(k) <= k and abs(d(k)-d(k-1)) <= 1 (smooth factorial numbers).
// Lexicographic order.
// Cf. OEIS sequence A005773.

// ========== HEADER FILE src/comb/stringsubst.h: ==========

class string_subst;
// String substitution engine (Lindenmayer system, or L-system).

// ========== HEADER FILE src/comb/subset-debruijn.h: ==========

class subset_debruijn : public binary_debruijn;
// Subsets of the set {0,1,2,...,n-1} in an order
// determined by a De Bruijn sequence.
// Note: work per subset is proportional to n.

// ========== HEADER FILE src/comb/subset-deltalex.h: ==========

class subset_deltalex;
// Subsets in lexicographic order for delta sets

// ========== HEADER FILE src/comb/subset-gray-delta.h: ==========

class subset_gray_delta;
// Subsets of the set {0,1,2,...,n-1} in minimal-change (Gray code) order.
// Loopless algorithm.

// ========== HEADER FILE src/comb/subset-gray.h: ==========

class subset_gray;
// Subsets of the set {1,2,...,n} in minimal-change (Gray code) order.
// Loopless algorithm following Jenkyns ("Loopless Gray Code Algorithms").

// ========== HEADER FILE src/comb/subset-lex.h: ==========

class subset_lex;
// Nonempty subsets of the set {0,1,2,...,n-1} in lexicographic order.
// Representation as list of parts.
// Loopless generation.

// ========== HEADER FILE src/comb/test-gray.h: ==========

// ----- SRCFILE=src/comb/test-gray.cc: -----
ulong test_gray_path(const ulong *f, ulong n);
// Test whether the sequence f[] is a Gray path.
// If so, return zero, else return the index of the second element
//   of the first pair whose difference is not one bit.

bool is_gray_path(const ulong *f, ulong n);
// Return true if f[] is a Gray path,
//  else return false.

ulong test_canonical_gray(const ulong *f, ulong n);
// Test whether the sequence f[] is canonical.
// If so, return zero, else return the index of the second element
//   of the first pair whose difference is the on wrong track.
// Does NOT check that the sequence is a Gray path.

bool is_canonical_gray(const ulong *f, ulong n);
// Return true if f[] is a Gray path,
//  else return false.
// Does NOT check that the sequence is a Gray path.

bool is_monotonic_gray(const ulong *f, ulong n);
// Return true if f[] is a monotonic Gray path,
//  else return false.
// Does NOT check that the sequence is a Gray path.

bool is_complementary_gray(const ulong *f, ulong n);
// Return whether the sequence f[] is complementary.
// Does NOT check that the sequence is a Gray path.

// ========== HEADER FILE src/comb/weakly-unimodal-rgs-lex.h: ==========

class weakly_unimodal_rgs_lex;
// Weakly unimodal RGS (restricted growth strings), lexicographic order.
// Cf. OEIS sequences:
//  A088536: unimodal maps [1..n] -> [1..n].
//  A225006: unimodal maps [1..n] -> [1..n+1].
//  A000000: unimodal maps [1..n] -> [1..n+2] (not in the OEIS).
//  A000000: unimodal maps [1..n] -> [1..2*n] (not in the OEIS).
//  A000000: unimodal maps [1..2*n] -> [1..n] (not in the OEIS).
//  A000000: unimodal maps [1..n] -> [1..n-1] (not in the OEIS).
//  A000000: unimodal maps [1..n] -> [1..floor(n/2)] (not in the OEIS).
//  A000124: unimodal maps [1..n] -> [1,2].
//  A000000: unimodal maps [1..n] -> [1,2,3] (not in the OEIS).
//  A002412: unimodal maps [1,2,3] -> [1..n].
//  A006324: unimodal maps [1,2,3,4] -> [1..n].

// ========== HEADER FILE src/comb/wfl-hilbert.h: ==========

class wfl_cell;
// Container used in class wfl_hilbert.

class wfl_hilbert;
// Fred Lunnon's (second) iterative algorithm to convert linear coordinate
// into coordinates of d-dimensional Hilbert curve (and back).
// Translated and adapted from Java code by Fred Lunnon.

// ========== HEADER FILE src/comb/word-stats.h: ==========

class word_stats;
// Various statistics for length-n arrays of type ulong.

// ========== HEADER FILE src/comb/young-tab-rgs.h: ==========

class young_tab_rgs;
// Restricted growth strings (RGS) for standard Young tableaux:
// the k-th occurrence of a digit d in the RGS must precede
// the k-th occurrence of the digit d+1.
// Generation in lexicographic order.
// Cf. OEIS sequences A000085 (all tableaux),
//   A001405 (tableaux with height <= 2, central binomial coefficients)
//   A001006 (tableaux with height <= 3, Motzkin numbers)
//   A005817 (height <= 4),  A049401 (height <= 5),  A007579 (height <= 6)
//   A007578 (height <= 7),  A007580 (height <= 8)
//   A001189 (height <= n-1),
//   A014495 (height = 2),  A217323 (height = 3),  A217324 (height = 4),
//   A217325 (height = 5),  A217326 (height = 6),  A217327 (height = 7),
//   A217328 (height = 8).
// Cf. OEIS sequences A061343 (all shifted tableaux; using condition is_shifted(1)):
// A210736 (height <= 2), A082395 (height <= 3).

