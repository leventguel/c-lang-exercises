Listing 1Comparison operators.// class definitionclass FP{   ...public:   ...   // relational tests   short unsigned_greater(const FP &x);   short unsigned_less(const FP &x);   // relational operators   short operator == (const FP &x);   short operator != (const FP &x);    short operator > (const FP &x);   short operator < (const FP &x);   short operator >= (const FP &x);   short operator <= (const FP &x);   ...};//Compare Two _POSITIVE_ FP Numbers for//Relative Size//Return true if *this > x   short FP::unsigned_greater(const FP    &x){   short e1 = e & 0x7f;   short e2 = x.e & 0x7f;   if(e1 > e2) return TRUE;   if(e1 < e2) return FALSE;   return (m > x.m);}//Compare Two _POSITIVE_ FP Numbers for //Relative Size//Return true if *this < xshort FP::unsigned_less(const FP &x){   short e1 = e & 0x7f;   short e2 = x.e & 0x7f;   if(e1 > e2) return FALSE;   if(e1 < e2) return TRUE;   return (m < x.m);}// Comparison operatorsshort FP::operator ==(const FP &x){   return((e==x.e) && (m==x.m));}short FP::operator !=(const FP &x){   return ((e != x.e) || (m != x.m));}short FP::operator > (const FP &x){   short s1 = test_sign();   short s2 = signof(x);   if(s1)   if(s2)   return unsigned_less(x);      else   return FALSE;   else   if(s2)   return TRUE;   else   return unsigned_greater(x);}short FP::operator < (const FP &x){   short s1 = test_sign();   short s2 = signof(x);   if(s1)   if(s2)   return unsigned_greater(x);      else   return TRUE;   else   if(s2)   return FALSE;   else   return unsigned_less(x);}short FP::operator >= (const FP &x){   return !(*this < x);}short FP::operator <= (const FP &x){      return !(*this > x);}listing 2Normalization.{   // preserve sign   short exp = e & 0x7f;   // don’t try to normalize 0   if(m==0){   e=0;   return;   }      // loop until normalized   while(!(m & 0x8000))   {   m <<= 1;   —exp;	   }       // did exponent underflow?   if(exp < 1)   {   // if so, make it zero   e = m = 0;	   return;   }   // new exponent, old sign   e &= 0x80;   e |= exp;}listing 3Type conversions.// convert unsigned short to short floatvoid FP::from_unsigned(const UWORD n){   e = 0x50;   m = n;   normalize();}// convert signed short to short floatvoid FP::from_short(const short n){// take care of special case   if((UWORD)n==0x8000){      e = 0xd0;      return;   }// process according to sign   if(n >= 0){      e = 0x50;      m = (UWORD)n;   }   else{      e = 0xd0;      m = (UWORD)(-n);   }   normalize();}// convert long int to short floatvoid FP::from_long(long n)   {   short sign;// take care of special case   if(n==0x80000000){      m = 0x8000;      e = 0xe0;      return;   }   // set sign bit   sign = 0;   if(n < 0){      sign = 0x80;      n = -n;   }// set the exponent   e = 0x50;   // we may need to shift right// to avoid overflow   while(n & 0xffff0000)   {      n >>= 1;      e++;   }   // now it’ll fit   m = (UWORD)n;   e |= sign;      normalize();}// convert C double to short floatvoid FP::from_float(double x){   // skip if zero   if(x==0.0)   {      e = 0;      m = 0;      return;   }   // default exponent       e = 0x40;// strip sign bit   short sign = (x < 0);   x = abs(x);   // get x in range 0.5..1.0   while(x > 0.999984741){      x /= 2;      ++e;   }   while(x < 0.5){      x *= 2;      —e;   }   m = (UWORD)(x * 65536.0);   // restore sign bit   if(sign)      e ^= 0x80;}Listing 4Type conversions II.// convert short float to unsigned shortUWORD FP::to_unsigned(void){	UWORD retval = m;   short shift = 0x50 - e;   if(shift < 0)      return MAXUINT;   retval >>= shift;   return retval;}   // convert short float to signed shortshort FP::to_short(void){   // get the mantissa   long retval = m;   // sign = +/- 1   short sign = 1 - ((e >> 7) << 1);   // how many bits to shift?   short shift = 0x50 - (e & 0x7f);   // will result fit?   if(shift <= 0)      return sign * MAXINT;   // shift result   retval >>= shift;   return sign * (short)retval;}// convert short float to long intlong FP::to_long(void){   // get the mantissa   long retval = (long)m;   // sign = +/- 1   short sign = 1 - ((e >> 7) << 1);   // how many shifts?   short shift = (e & 0x7f) - 0x50;   // too many?   if(shift > 15)      return sign * MAXLONG;   // shift can be left or right   if(shift > 0)      retval <<= shift;   else      retval >>= -shift;   return sign * retval;}// convert short float to C doubledouble FP::to_double(void){   short exp;   double retval;   // don’t try to convert zero   if(e==0)      return 0.0;   // convert mantissa to float   retval = (double)m/65536.0;   // strip sign bit   exp =  e & 0x7f;   // multiply for + exp   while(exp > 0x40){      retval *= 2;      —exp;   }   // divide for - exp   while(exp < 0x40){      retval /= 2;      ++exp;   }   // restore sign bit   if(e & 0x80)      retval = -retval;   return retval;}listing 5Multiply and divide.// multiplicationvoid FP::operator *=(const FP x){   // working mantissa   typedef unsigned long ULONG;   ULONG mant;   short sign = (e^x.e) & 0x80;   short   exp = (e & 0x7f) + (x.e &      0x7f) - 0x41;      // check for underflow   if(exp < 1){      e = 0;      m = 0;      return;   }   // and overflow   if(exp > 0x7e){      m = 0xffff;      e = 0x7f | sign;      return;   }   // compute result mantissa   mant = ((ULONG)m * (ULONG)x.m)>>15;   // it could be zero   if(mant==0){      e = 0;      m = 0;      return;      }   // we may need to right shift once more   if(mant & 0xffff0000){      mant >>= 1;      exp++;        }              e = exp | sign;   m = (UWORD)mant;}// divisionvoid FP::operator /= (const FP &x){   // working mantissa   ULONG mant;   // compute sign of result   short sign = (e^x.e) & 0x80;      // compute exponent of result   short exp = (e &0x7f) - (x.e &0x7f) + 0x40;   // check for overflow   // also divide by zero   if((exp > 0x7e) || (x.e==0)){      m = 0xffff;      e = 0x7f | sign;      return;   }      // and underflow            if(exp < 1)   {      e = 0;      m = 0;      return;   }                           // compute result mantissa      mant = ((ULONG)m << 16) / (ULONG)x.m;   // we may need to right shift once more      if(mant & 0xffff0000)   {      mant >>= 1;      exp++;   }   // assemble result      e = exp | sign;   m = (UWORD)mant;}   