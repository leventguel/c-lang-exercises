LISTING 1Unsigned add.// floating-point Add (unsigned)// *this += xvoid FP::ufadd(const FP &x){   long mant;   // force signs positive   e &= 0x7f;   short exp = x.e & 0x7f;   // compute shift factor   short shift = e - exp;   // which has larger exponent?   if(shift >= 0)   {     exp = (short)e;     mant = (long)m + (x.m >> shift);   }   else   {     shift = -shift;     mant = (long)x.m + (m >> shift);   }   // must we renormalize?   if(mant & 0xffff0000)   {     mant >>= 1;     ++exp;     // maybe it overflowed     if(exp>0x7f)     {       // just return big #       e = 0x7f;       m = 0xffff;       return;        }       }       // update the result       e = exp;       m = (UWORD)mant;}LISTING 2Unsigned subtract.  // floating-point Subtract (unsigned)// *this -= xvoid FP::ufsub(const FP &x) {   long mant;   short sign;   // force signs positive   e &= 0x7f;   short exp = x.e & 0x7f;   // compute shift factor   short shift = e - exp;   // which has larger exponent?   if(shift >= 0)   {     exp = (short)e;     mant = (long)m - (x.m >> shift);     sign = 0;   }   else   {     shift = -shift;     mant = (long)x.m - (m >> shift);     sign = 0x80;   }   // We could get negative result   if(mant < 0)   {     mant = -mant;     sign ^= 0x80;   }   // Results canÕt overflow, but will   // need normalizing   e = exp | sign;   m = (UWORD)mant;   normalize();}LISTING 3Signed addition.  // floating-point Add (signed)// *this += xvoid FP::operator += (const FP &x) {   // signs of operands   short s1 = e & 0x80;   short s2 = x.e & 0x80;   // same signs?   if(s1==s2)   {     // then add     ufadd(x);     // and restore sign     e |= s1;   }   else   {     // subtract     ufsub(x);     // and make sign right     e ^= s1;   }}// floating-point Subtract (signed)//*this -= xvoid FP::operator -= (const FP &x) {   // signs of operands   short s1 = e & 0x80;   short s2 = x.e & 0x80;   // different signs?   if(s1 != s2)   {     // then add     ufadd(x);     // and restore sign     e |= s1;   }   else   {     // subtract     ufsub(x);     // and make sign right     e ^= s1;   }}LISTING 4Signed addition.  #include <iostream.h>#include <jmath.h>#define FALSE 0#define TRUE (!FALSE)#define MAXINT       0x7fff;#define MAXUINT      0xffff;#define MAXLONG      0x7fffffff;// base typestypedef unsigned char UBYTE;typedef unsigned short UWORD;typedef unsigned long ULONG;// class definitionclass FP{    UBYTE e;    UWORD m;public:    // constructors    FP();    FP(const FP & x);        FP(UBYTE exp, UWORD mant);FP(const double x);    // destructor    ~FP();    // assignment operators    FP & operator = (const FP & x);    // test elements of *this    short is_zero(void);    short is_negative(void);    short is_positive(void);    UBYTE sign_of(void);    UBYTE exponent_of(void);    // modify elements of *this    void negate(void);    void make_positive(void);    void normalize(void);    // generate new FP number    friend FP operator -(const FP &x);    friend FP abs(const FP &x);    // relational tests    short unsigned_greater(const FP       &x);    short unsigned_less(const FP &x);    // relational operators    short operator == (const FP &x);    short operator != (const FP &x);    short operator > (const FP &x);    short operator < (const FP &x);    short operator >= (const FP &x);    short operator <= (const FP &x);    // data conversions    void from_float(double x);    double to_float(void);    void from_unsigned(const UWORD n);     UWORD to_unsigned(void);    void from_short(const short n);    short to_short(void);    void from_long(long n);    long to_long(void);    // hex I/O    void gethex(void);    void puthex(void);    // stream I/O    friend istream & operator >>       (istream & is, FP & x);    friend ostream & operator <<      (ostream & os, FP & x);    // math operators    void operator *=(const FP &x);    friend FP operator *(const FP &x,     const FP &y);    void operator /=(const FP &x);    friend FP operator /(const FP &x,     const FP &y);    void ufadd(const FP &x);    void ufsub(const FP &x);    void operator += (const FP &x);    void operator -= (const FP &x);};// handy constantsFP zero   (0x00, 0x0000);FP one    (0x41, 0x8000);FP two    (0x42, 0x8000);FP three  (0x42, 0xc000);FP four   (0x43, 0x8000);FP five   (0x43, 0xa000);FP six    (0x43, 0xc000);FP seven  (0x43, 0xe000);FP eight  (0x44, 0x8000);FP nine   (0x44, 0x9000);FP ten    (0x44, 0xa000);FP eleven (0x44, 0xb000);FP twelve (0x44, 0xc000);FP thirteen   (0x44, 0xd000);FP fourteen   (0x44, 0xe000);FP fifteen    (0x44, 0xf000);FP sixteen    (0x45, 0x8000);  FP half     (0x40, 0x8000);FP third    (0x3f, 0xaaab);FP fourth   (0x3f, 0x8000);FP fifth    (0x3e, 0xcccd);FP sixth    (0x3e, 0xaaab);FP seventh    (0x3e, 0x9249);FP eighth   (0x3e, 0x8000);FP ninth    (0x3d, 0xe38e);FP tenth    (0x3d, 0xcccd);FP eleventh   (0x3d, 0xba2f);FP twelfth    (0x3d, 0xaaab);FP thirteenth   (0x3d, 0x9d8a);FP fourteenth   (0x3d, 0x9249);FP fifteenth    (0x3d, 0x8889);FP sixteenth    (0x3d, 0x8000);FP big_FP     (0x7f, 0xffff);FP pi      (0x42, 0xc910);// default constructorFP::FP(){    e = 0;    m = 0;}// copy constructorFP::FP(const FP & x){    e = x.e;    m = x.m;}// conversion constructorsFP::FP(UBYTE exp, UWORD mant){    e = exp;    m = mant;}FP::FP(const double x){    from_float(x);}// destructorFP::~FP(){} // assignment operatorinline FP & FP::operator =   (const FP &      x){    e = x.e;    m = x.m;    return *this;}// testsshort FP::is_zero(void){   return !e;}short FP::is_negative(void){   return e & 0x80;}short FP::is_positive(void){   return !(e & 0x80);}UBYTE FP::sign_of(void){   return e & 0x80;}UBYTE FP::exponent_of(void){   return e & 0x7f;}// value modifiersvoid FP::negate(void){   e ^= 0x80;}void FP::make_positive(void){   e &= 0x7f;}void FP::normalize(void){   // temp for exponent adjust      short exp = e & 0x7f;      // make sure number isn't zero      if(m == 0){     e=0;     return;   }   // shift left until normalized   while(!(m & 0x8000)){     m <<= 1;     --exp;   }   // did exponent underflow?      if(exp<1){     // if so, make it zero     e = 0;     m = 0;     return;   }   // restore sign bit, store exp   e &= 0x80;   e |= exp;}// return absolute valueFP abs(const FP &x){   FP retval(x);   retval.e &= 0x7f;   return retval;}// unary minus operatorFP operator -(const FP &x){   FP retval(x);   retval.e ^= 0x80;   return retval;}// display FP in hexvoid FP::puthex(void){   cout.fill('0');   cout.width(2);   cout << hex << (short)e;   cout << '.';   cout.width(4);   cout << hex << m << ' ';   cout.fill(' ');}// input FP in hexvoid FP::gethex(void){   short temp;      cin >> hex >> temp >> m;   e = (UBYTE)temp;}// I/O stream operatorsistream & operator >> (istream &is, FP &x){   double temp;   cin >> temp;   x.from_float(temp);   return is;}ostream & operator << (ostream &os, FP &x){   double temp = x.to_float();   cout << temp << ' ';   return os;}// Comparison operatorsshort FP::unsigned_greater(const FP &x){   short e1 = e & 0x7f;   short e2 = x.e & 0x7f;   if(e1 > e2) return TRUE;   if(e1 < e2) return FALSE;   return (m > x.m);}short FP::unsigned_less(const FP &x){   short e1 = e & 0x7f;   short e2 = x.e & 0x7f;   if(e1 > e2) return FALSE;   if(e1 < e2) return TRUE;   return (m < x.m);}short FP::operator ==(const FP &x){   return((e == x.e) && (m == x.m));}short FP::operator !=(const FP &x){   return ((e != x.e) || (m != x.m));}short FP::operator > (const FP &x){   short s1 = e & 0x80;   short s2 = x.e & 0x80;   if(s1)     if(s2)       return unsigned_less(x);     else       return FALSE;   else     if(s2)       return TRUE;     else       return unsigned_greater(x);}short FP::operator < (const FP &x){   short s1 = e & 0x80;   short s2 = x.e & 0x80;   if(s1)     if(s2)       return unsigned_greater(x);     else       return TRUE;   else     if(s2)       return FALSE;     else       return unsigned_less(x);}short FP::operator >= (const FP &x){   return !(*this < x);}short FP::operator <= (const FP &x){   return !(*this > x);}// type conversionsvoid FP::from_unsigned(const UWORD n){   e = 0x50;   m = n;   normalize();}UWORD FP::to_unsigned(void){   UWORD retval = m;   short shift = 0x50 - e;   if(shift < 0)     return MAXUINT;   retval >>= shift;   return retval;}   void FP::from_short(const short n){   // take care of special case   if((UWORD)n == 0x8000){     e = 0xd0;     return;   }   // process according to sign   if(n >= 0){     e = 0x50;     m = (UWORD)n;   }   else{     e = 0xd0;     m = (UWORD)(-n);   }   normalize();}short FP::to_short(void){   // get the mantissa   long retval = m;   // sign = +/- 1   short sign = 1 - ((e >> 7) << 1);   // how many bits to shift?   short shift = 0x50 - (e & 0x7f);   // will result fit?   if(shift <= 0)     return sign * MAXINT;   // shift result   retval >>= shift;   return sign * (short)retval;}void FP::from_long(long n)   {   short sign;   // take care of special case   if(n == 0x80000000){     m = 0x8000;     e = 0xe0;     return;   }      // set sign bit          sign = 0;   if(n < 0){     sign = 0x80;     n = -n;   }             // set the exponent          e = 0x50;      // we may need to shift right   // to avoid overflow              while(n & 0xffff0000)   {     n >>= 1;     e++;   }      // now it'll fit                        m = (UWORD)n;   e |= sign;      normalize();   }long FP::to_long(void){   // get the mantissa                  long retval = (long)m;  // sign = +/- 1   short sign = 1 - ((e >> 7) << 1);   // how many shifts?   short shift = (e & 0x7f) - 0x50;   // too many?   if(shift > 15)     return sign * MAXLONG;   // shift can be left or right   if(shift > 0)     retval <<= shift;   else     retval >>= -shift;   return sign * retval;}void FP::from_float(double x){   // skip if zero      if(x == 0.0)   {     e = 0;     m = 0;     return;   }           // default exponent      e = 0x40;      // strip sign bit        short sign = (x < 0);   x = abs(x);      // get x in range 0.5..1.0      while(x > 0.999984741){     x /= 2;     ++e;   }   while(x < 0.5){     x *= 2;     --e;   }   // create return value      m = (UWORD)(x * 65536.0);      // restore sign bit      if(sign)     e ^= 0x80;}double FP::to_float(void){   short exp;   double retval;   // don't try to convert zero   if(e == 0)    return 0.0;   // convert mantissa to float   retval = (double)m/65536.0;   // strip sign bit   exp =  e & 0x7f;   // multiply for + exp   while(exp > 0x40){     retval *= 2;     --exp;   }   // divide for - exp   while(exp < 0x40){     retval /= 2;     ++exp;   }   // restore sign bit   if(e & 0x80)     retval = -retval;   return retval;}// multiplicationvoid FP::operator *=(const FP &x){   // working mantissa   ULONG mant;   // compute sign of product         short sign = (e^x.e) & 0x80;              // compute exponent of product        short   exp = (e & 0x7f) + (x.e &      0x7f) - 0x41;      // check for underflow   if(exp < 1){     e = 0;     m = 0;     return;   }   // and overflow   if(exp > 0x7e){     m = 0xffff;     e = 0x7f | sign;     return;   }      // compute result mantissa        mant = ((ULONG)m *      (ULONG)x.m) >> 15;   // it could be zero   if(mant == 0){     e = 0;     m = 0;     return;   }       // we may need to right shift once    // more      if(mant & 0xffff0000){     mant >>= 1;     exp++;      }       // build the result          e = exp | sign;   m = (UWORD)mant;}   // divisionvoid FP::operator /= (const FP &x){   // working mantissa   ULONG mant;   // compute sign of result   short sign = (e^x.e) & 0x80;      // compute exponent of result   short exp = (e &0x7f) -      (x.e &0x7f) +  0x40;   // check for overflow   // also divide by zero   if((exp > 0x7e) || (x.e == 0)){     m = 0xffff;     e = 0x7f | sign;     return;   }      // and underflow         if(exp < 1)   {     e = 0;     m = 0;     return;   }             // compute result mantissa      mant = ((ULONG)m << 16) /     (ULONG)x.m; // we may need to right shift once more      if(mant & 0xffff0000)   {     mant >>= 1;     exp++;   }   // assemble result   e = exp | sign;   m = (UWORD)mant;}FP operator *(const FP &x,  const FP &y){   FP retval(x);   retval *= y;   return retval;}FP operator /(const FP &x,  const FP &y){   FP retval(x);   retval /= y;   return retval;}// addition (unsigned)// *this += xvoid FP::ufadd(const FP &x){   long mant;   // force signs positive   e &= 0x7f;   short exp = x.e & 0x7f;   // compute shift factor   short shift = e - exp;   // which has larger exponent?   if(shift >= 0)   {     exp = (short)e;     mant = (long)m + (x.m >> shift);   }   else   {     shift = -shift;     mant = (long)x.m + (m >> shift);   }   // must we renormalize?   if(mant & 0xffff0000)   {     mant >>= 1;     ++exp;     // maybe it overflowed     if(exp>0x7f)     {         // just return big #      e = 0x7f;      m = 0xffff;      return;     }   }   // update the result   e = exp;   m = (UWORD)mant;}// subtraction (unsigned)// *this -= xvoid FP::ufsub(const FP &x){   long mant;   short sign;   // force signs positive   e &= 0x7f;   short exp = x.e & 0x7f;   // compute shift factor   short shift = e - exp;   // which has larger exponent?   if(shift >= 0)   {     exp = (short)e;     mant = (long)m - (x.m >> shift);     sign = 0;   }   else   {     shift = -shift;     mant = (long)x.m - (m >> shift);     sign = 0x80;   }// We could get negative resultif(mant < 0){   mant = -mant;   sign ^= 0x80;   }// Results can't overflow, but will// need normalizinge = exp | sign;m = (UWORD)mant;normalize();}// addition  (signed)//   *this += xvoid FP::operator += (const FP &x){   // signs of operands   short s1 = e & 0x80;   short s2 = x.e & 0x80;   // same signs?   if(s1==s2)   {     // then add     ufadd(x);     // and restore sign     e |= s1;   }   else   {     // subtract     ufsub(x);     // and make sign right     e ^= s1;   }}//  subtraction (signed)//   *this -= xvoid FP::operator -= (const FP &x){   // signs of operands   short s1 = e & 0x80;   short s2 = x.e & 0x80;   // different signs?   if(s1 != s2)   {     // then add     ufadd(x);     // and restore sign     e |= s1;   }   else   {     // subtract     ufsub(x);     // and make sign right     e ^= s1;   }}FP operator +(const FP &x,   const FP &y){   FP retval(x);   retval += y;   return retval;}FP operator -(const FP &x,   const FP &y){   FP retval(x);   retval -= y;   return retval;}